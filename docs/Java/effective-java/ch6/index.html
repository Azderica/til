<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">Lambdas and Streams | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/Java/effective-java/ch6"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Lambdas and Streams | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="Java 8에서 함수 객체를 더 쉽게 만들 수 있도록, functional interface, 람다 및 메소드 참조가 추가되었습니다. 스트림 API는 이러한 언어 변경과 함께 추가되어 데이터 요소들의 시퀀스 처리를 위한 라이브러리 지원을 제공합니다."><meta data-react-helmet="true" property="og:description" content="Java 8에서 함수 객체를 더 쉽게 만들 수 있도록, functional interface, 람다 및 메소드 참조가 추가되었습니다. 스트림 API는 이러한 언어 변경과 함께 추가되어 데이터 요소들의 시퀀스 처리를 위한 라이브러리 지원을 제공합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/Java/effective-java/ch6"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/Java/effective-java/ch6" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/Java/effective-java/ch6" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.07564d68.js" as="script">
<link rel="preload" href="/til/assets/js/main.c4550fed.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch1">객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch2">모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch3">클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch4">제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch5">Enums 와 Annotation</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/Java/effective-java/ch6">Lambdas and Streams</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch7">Methods</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch8">General Programming</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch9">Exceptions</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch10">Concurrency (동시성)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/Java/effective-java/ch11">Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Java/optimizing-java/ch1">성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Java/optimizing-java/ch2">JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Java/optimizing-java/ch3">하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Java/optimizing-java/ch4">성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Java/optimizing-java/ch5">마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Java/optimizing-java/ch6">가비지 수집 기초</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/Web/http-perfect-guide/ch1">HTTP : 웹의 기초</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Lambdas and Streams</h1></header><div class="markdown"><p>Java 8에서 함수 객체를 더 쉽게 만들 수 있도록, <code>functional interface</code>, 람다 및 메소드 참조가 추가되었습니다. 스트림 API는 이러한 언어 변경과 함께 추가되어 데이터 요소들의 시퀀스 처리를 위한 라이브러리 지원을 제공합니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-42-익명-클래스보다-람다를-선택합니다"></a>Item 42. 익명 클래스보다 람다를 선택합니다.<a class="hash-link" href="#item-42-익명-클래스보다-람다를-선택합니다" title="Direct link to heading">#</a></h2><p>과거에는 하나의 추상 메소드를 가진 인터페이스가 function types로 사용되었습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 함수 객체로서의 익명 클래스 인스턴스 - 폐기되었음</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Collections.sort(words, new Comparator&lt;String&gt;() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public int compare(String s1, String s2) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Integer.compare(s1.length(), s2.length());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">});</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 익명 클래스는 object-oriented 객체를 필요로 하는 고전적인 객체 지향 디자인 패턴(특히. Strategy pattern)에 적합했습니다. 그러나 이는 매우 애매모호했기 때문에 이를 대체할 수단이 필요하게 되었습니다.</p><p>Java 8에서는 단일 추성 메서드와의 인터페이스가 필요하다는 개념을 공식화하였고, 이를 <code>function interface</code>라고 알려져 있으며, 람다식이나 람다를 통해서 이를 만들 수 있게 되었습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 함수 객체로서의 람다 표현식 (익명 클래스 대체)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Collections.sort (words,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (s1, s2)-&gt; Integer.compare (s1.length (), s2.length () ));</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>프로그램이 명확해지지 않는 한, 모든 람다 파라미터의 유형을 생략하는 방법이 좋습니다. (컴파일러가 이를 유추할 수 없기 때문에 그렇습니다.) 그렇기 때문에 <strong>앞선 주제에서 말했듯이 Raw 타입을 사용하지 않는 것</strong>이 여기서 중요합니다.</p><p>또한 이러한 람다식을 통해서 더 짧게 만들 수 있고, 의미적으로도 잘 보일 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Before 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Collections.sort(words, comparingInt(String::length));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// After 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">words.sort(comparingInt(String::length));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 뒤의 코드가 앞의 코드보다 직관적입니다.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이전 챕터에서 나왔던 Enum형을 아래처럼 수정할 수도 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public enum Operation {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PLUS  (&quot;+&quot;, (x, y) -&gt; x + y),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  MINUS (&quot;-&quot;, (x, y) -&gt; x - y),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  TIMES (&quot;*&quot;, (x, y) -&gt; x * y),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  DIVIDE(&quot;/&quot;, (x, y) -&gt; x / y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final String symbol;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final DoubleBinaryOperator op;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Operation(String symbol, DoubleBinaryOperator op) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.symbol = symbol;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.op = op;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public String toString() { return symbol; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public double apply(double x, double y) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return op.applyAsDouble(x, y);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그러나, 이러한 <strong>람다는 name과 document가 없기 때문에 계산이 확실하지 않거나, 몇줄을 초과하는 경우에는 람다에 넣는 것은 좋지않습니다.</strong> (일반적으로 1줄 ~ 3줄 사이가 적합)</p><p>현재는 람다의 등장으로 익명 클래스를 거의 사용하지 않지만, 익명 클래스만 할 수 있는 부분이 있습니다.</p><ul><li>람다는 기능 인터페이스로 제한되나, 추상 클래스의 인스턴스를 만들려면 람다가 아닌 익명 클래스로 만들 수 있습니다.</li><li>익명 클래스를 사용해서 여러 추상 메서드가 있는 인터페이스의 인스턴스를 만들 수 있습니다.</li><li>람다는 자신에 대한 참조를 얻을 수 없습니다. 즉, 본문 내에서 함수 객체에 액세스해야하는 경우 익명 클래스를 사용해야합니다.</li></ul><p>람다는 구현 중에 안정적으로 직렬화 및 역 직렬화 할 수 없는 속성은 익명 클래스와 공유합니다. 따라서 람다나 익명 클래스 인스턴스를 직렬화하는 경우는 거의 없습니다. Comparator 등의 직렬화를 쓸때는 nested class를 사용하는 것이 좋습니다.</p><p>이를 요약하면 Java 8에서 람다는 작은 함수 객체를 표현하는 가장 좋은 방법입니다. <strong>기능 인터페이스가 아닌 유형의 인스턴스를 만들어야하는 경우가 아니면, 함수 개체에 익명 클래스를 사용하면 안됩니다.</strong></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-43-람다보다-메서드-참조를-선택합니다"></a>Item 43. 람다보다 메서드 참조를 선택합니다.<a class="hash-link" href="#item-43-람다보다-메서드-참조를-선택합니다" title="Direct link to heading">#</a></h2><p>익명 클래스에 비해 람다의 주요 장점은 더 간결한 것입니다. 그러나 자바에서는 메서드 참조를 하는 람다보다 더 간결한 함수 객체를 생성하는 방법이 존재합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 람다식을 사용한 경우.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">map.merge (key, 1, (count, incr)-&gt; count + incr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 더 짧은 코드, 메서드 참조</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">map.merge (key, 1, Integer::sum);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>메서드에 파라미터가 많을수록 메서드 참조로 제거할 수 있는 상용구가 많아집니다. 다음은 그에 대한 주의사항입니다.</p><ul><li>람다로 할 수 없는 경우, 메서드 참조로도 할 수 있는 방법은 없습니다.</li><li>IDE로 프로그래밍하는 경우, 가능한 경우에 한해 람다를 메서드 참조로 대체할 수 있습니다.</li></ul><p>그러나 항상 이가 옳지는 않습니다. 특히 메서드가 같은 클래스에 있을 때 자주 발생합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 메서드 참조</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">service.execute (GoshThisClassNameIsHumongous :: action);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 람다식 사용 (여기서는 이게 더 좋음.)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">service.execute (()-&gt; action ());</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>메서드 참조의 종류는 다음과 같습니다.</p><table><thead><tr><th>Method Ref Type</th><th>Example</th><th>Lambda Equivalent</th></tr></thead><tbody><tr><td>Static</td><td><code>Integer::parseInt</code></td><td><code>str -&gt; Integer.parseInt(str)</code></td></tr><tr><td>Bound</td><td><code>Instant.now()::isAfter</code></td><td><code>Instant then = Instant.now();</code><br><code>t-&gt;then.isAfter(t)</code></td></tr><tr><td>UnBound</td><td><code>String::toLowerCase</code></td><td><code>str -&gt; str.toLowerCase()</code></td></tr><tr><td>Class Constructor</td><td><code>TreeMap&lt;K, V&gt;::new</code></td><td><code>() -&gt; new TreeMap&lt;K, V&gt;</code></td></tr><tr><td>Array Constructor</td><td><code>int[]::new</code></td><td><code>len -&gt; new int[len]</code></td></tr></tbody></table><p>이를 정리하면 메서드 참조는 종종 람다보다 간결한 대안을 제공합니다. 따라서, <strong>메소드 참조가 더 짧고 명확한 경우에는 이를 사용하고 그렇지 않은 경우에는 람다를 사용하는 것이 중요합니다.</strong></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-44-표준-기능-인터페이스를-선택합니다"></a>Item 44. 표준 기능 인터페이스를 선택합니다.<a class="hash-link" href="#item-44-표준-기능-인터페이스를-선택합니다" title="Direct link to heading">#</a></h2><p>Java에 람다가 들어오고 난 이후, API 작성 가이드가 변경되었습니다.</p><p>대표적으로 Map을 쓰는 경우에는 LinkedHashMap 등을 사용하는 것이 좋습니다. 예를 들어 Map에서 removeEldestEntry를 사용한다고 했을 때, LinkedHashMap 의 경우에는 삭제할 수 있지만 Map의 경우에는 수동적으로 생성해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 불필요한 기능 인터페이스; 대신 표준을 사용하십시오.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@FunctionalInterface interface EldestEntryRemovalFunction &lt;K, V&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  boolean remove (Map &lt;K, V&gt; map, Map.Entry &lt;K, V&gt; eldest);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>즉, 표준 기능 인터페이스의 기능을 사용하는 경우, <strong>특수 목적으로 만든 인터페이스보다는 표준 기능 인터페이스를 사용하는 것이 중요합니다.</strong></p><p>아래는 기본적인 기능 인터페이스입니다.</p><table><thead><tr><th>Interface</th><th>Function Signature</th><th>Example</th></tr></thead><tbody><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T apply (T t)</code></td><td><code>String::toLowerCase</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>T apply (T t1, T t2)</code></td><td><code>BigInteger::add</code></td></tr><tr><td><code>Predicate&lt;T&gt;</code></td><td><code>boolean test (T t)</code></td><td><code>Collection::isEmpty</code></td></tr><tr><td><code>Function&lt;T&gt;</code></td><td><code>R apply (T t)</code></td><td><code>Arrays::asList</code></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td><code>T get ()</code></td><td><code>Instant::now</code></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td><code>void accept (T t)</code></td><td><code>System.out::println</code></td></tr></tbody></table><p>이를 사용해서 여러 변형 케이스로 만들 수도 있습니다. 이를 사용하는 여러 변형 케이스가 존재하지만, 대부분의 표준 기능 인터페이스는 기본 유형에 대한 지원을 위해 존재합니다.</p><p>즉, 기본 기능 인터페이스 대신 다른 요소(boxed primitives)가 있는 인터페이스를 사용하는 것은 좋지않습니다.</p><p>목적에 맞는 <strong>인터페이스가 필요한 경우</strong>에는 아래의 조건인 경우인지를 잘 생각해봐야합니다.</p><ul><li>일반적으로 사용되며 설명이 포함된 이름이 도움이 될 수 있는 경우.</li><li>관련된 강력한 결합(contract)가 있는 경우.</li><li>사용자 커스텀 메소드가 이점을 가지고 있는 경우.</li></ul><p>다만 이러한 경우에는 신중하게 설계가 필요합니다. 그리고, <code>@FunctionalInterface</code>와 같이 기능적 인터페이스에는 어노테이션을 추가해야합니다.</p><p>요약하면, Java에서는 람다가 있기 때문에 이를 생각하고 API를 생계하는 것이 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-45-스트림을-신중하게-사용합니다"></a>Item 45. 스트림을 신중하게 사용합니다.<a class="hash-link" href="#item-45-스트림을-신중하게-사용합니다" title="Direct link to heading">#</a></h2><p>Stream API는 대량 작업을 순차적으로 또는 병렬적으로 수행하는 작업을 쉽게하기 위해서 Java 8에 추가되었습니다.</p><p>Stream API는 다음의 특징을 가집니다.</p><ul><li>Stream pipeline은 source stream과 0개 이상의 intermediate operation, 하나의 terminal operation으로 나눠집니다.</li><li>Stream pipeline은 lazily하게 평가됩니다. (호출될 때까지 시작되지 않으며, 필요없는 데이터 요소는 계산되지 않습니다.)</li><li>Stream API는 유연합니다. (모든 호출이 단일 표현식으로 연결 가능합니다.)</li><li>Stream pipeline은 순차적으로 실행됩니다.</li><li>Stream API는 다재다능하지만, 항상 이렇게 해야하지는 않습니다. (잘못 사용하면, 유지보수성이 떨어집니다.)</li></ul><p>Stream을 남용한 코드는 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Overuse of streams - don&#x27;t do this!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Anagrams {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) throws IOException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Path dictionary = Paths.get(args[0]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int minGroupSize = Integer.parseInt(args[1]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try (Stream&lt;String&gt; words = Files.lines(dictionary)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      words.collect(groupingBy(word -&gt; word.chars()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .sorted()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .collect(StringBuilder::new, (sb, c) -&gt; sb.append((char) c),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          StringBuilder::append).toString()))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .values().stream()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .filter(group -&gt; group.size() &gt;= minGroupSize)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .map(group -&gt; group.size() + &quot;: &quot; + group)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .forEach(System.out::println);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이 경우, 프로그램을 읽고 유지하기가 매우 어렵습니다. Stream을 잘사용한 케이스는 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 세련된 스트림 사용으로 명확성과 간결함 향상</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Anagrams {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) throws IOException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Path dictionary = Paths.get(args[0]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int minGroupSize = Integer.parseInt(args[1]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try (Stream&lt;String&gt; words = Files.lines(dictionary)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      words</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .collect(groupingBy(word -&gt; alphabetize(word)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .values().stream()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .filter(group -&gt; group.size() &gt;= minGroupSize)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .forEach(g -&gt; System.out.println(g.size() + &quot;: &quot; + g));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// alphabetize method is the same as in original version</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같이 표현하면, 프로그램을 이해하기 어렵지 않습니다. 그리고, 람다 매개 변수의 이름도 신중하게 선정해야합니다. 명시적 유형이 없기 때문에, 스트림 파이프파린의 가독성을 높이기 위해서라도 이름 선정은 중요한 역할을 가지고 있습니다.</p><p>또한, <strong>파이프 라인에서는 명시적인 유형 정보와 임시 변수가 없기 때문에 도우미 메서드를 사용하는 것은 반복 코드보다 스트림 파이프라인에서 가독성을 위해 매우 중요합니다.</strong></p><p>예를 들어, 아래 코드는 이러한 스트림을 잘못 사용한 케이스입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;Hello world!&quot;.chars().forEach(System.out :: print);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// output : 721011081081113211911111410810033 (type을 모르므로)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;Hello world!&quot;.chars().forEach(x-&gt; System.out.print ((char) x));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 수정한 케이스, but 이렇게 사용하는 것은 좋지않음</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같이 스트림 파이프라인에서 사용할 수 없는 몇가지 작업이 있습니다.</p><ul><li>코드 블록에서는 범위의 모든 지역 변수를 읽거나 수정이 가능하지만, 람다에서는 최종만 읽을 수 있기때문에 지역변수를 수정할 수 없습니다.</li><li>코드 블록 return에서 둘러싸는 메서드 break, continue, 예외 throw 등이 가능하지만 람다에서는 불가능합니다.</li></ul><p>그러나 스트림에서 적절한 동작은 다음과 같습니다.</p><ul><li>요소 시퀀스를 균일하게 변경</li><li>요소 시퀀스 필터링</li><li>단일 작업을 사용하여 요소 시퀀스 결합(요소 추가 및 최소값 계산)</li><li>요소의 시퀀스를 컬렉션으로 합쳐서, 공통 속성별로 그룹화</li><li>일부 기준을 충족하는 요소에 대한 요소 시퀀스를 검색</li></ul><p>이러한 경우에 매우 좋습니다.</p><p>스트림을 사용하면 아래처럼 이쁜 코드를 구성할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 가장 큰 메르센 소수 20개를 출력하는 코드.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  primes().map(p -&gt; TWO.pow(p.intValueExact()).subtract(ONE))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .filter(mersenne -&gt; mersenne.isProbablePrime(50))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .limit(20)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .forEach(System.out::println);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그러나 항상 Stream을 쓸지, 혹은 iteration을 사용할지는 애매한 경우가 많습니다. 이러한 경우에서는 개발자의 취향에 가깝습니다. 즉, <strong>어떤 작업이 Stream이나 Iteration에 의해 더 나은건지 확실하지 않기 때문에, 두가지 모두를 시도하고 어떤 것이 나을지 고르는 것이 중요합니다.</strong></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-46-스트림에서-부작용이-없는-함수를-선택합니다"></a>Item 46. 스트림에서 부작용이 없는 함수를 선택합니다.<a class="hash-link" href="#item-46-스트림에서-부작용이-없는-함수를-선택합니다" title="Direct link to heading">#</a></h2><p>스트림은 단순한 API가 아니라, 함수형 프로그래밍을 기반으로 하는 패러다임입니다. 이러한 스트림이 제공해야하는 표현성과 속도, 경우에 따라 병렬화 가능성을 얻기위해서는 패러다임과 API를 채택해야합니다.</p><p>스트림 패러다임의 가장 중요한 부분은 각 단계의 결과가 이전 단계의 <code>pure function</code>에 최대한 가까운 변환 시퀀스로 계산을 구성하는 것입니다. (<code>pure function</code>은 결과가 입력에만 의존하는 함수입니다. 즉, 변경 가능한 상태에 의존하지 않으며 어떤 상태도 업데이트가 없습니다.)</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Map &lt;String, Long&gt; freq = new HashMap &lt;&gt; ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 잘못 스트림을 사용한 경우.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">try (Stream &lt;String&gt; words = new Scanner (file) .tokens ()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  words.forEach (word-&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    freq.merge (word.toLowerCase (), 1L, Long::sum);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  });</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 스트림 API를 잘 사용한 경우.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">try (Stream &lt;String&gt; words = new Scanner (file) .tokens ()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  freq = words.collect(groupingBy(String::toLowerCase, counting()));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위와 같이 <code>forEach</code> 연산은 동작 연산을 수행하지 않게 <strong>스트림 결과를 보고하는 목적으로 사용</strong>해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// freq 테이블에서 상위 10 개 단어 목록을 가져 오는 파이프 라인</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">List &lt;String&gt; topTen = freq.keySet().stream()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .sorted (comparison(freq::get).reversed()).limit(10)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .collect (toList ());</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그리고 해당 코드처럼, Collectors의 member를 정적으로 가져오는 것이 스트림 파이프라인을 더 읽기 쉽게 만듭니다.</p><p>이외에도 여러개의 Collectors들이 존재합니다. 스트림 파이프 라인 프로그래밍의 본질은 부작용이 없는 함수 객체를 구성하는 것입니다. 이는 스트림 및 관련 개체에 전달된 많은 함수 개체 모두에 적용됩니다.</p><ul><li><code>forEach</code> : 계산을 수행하는 것이 목적이 아니라, 스트림에 의해 수행된 계산 결과를 보고해야하는 곳에 사용해야합니다.</li><li><code>toList</code>, <code>toSet</code>, <code>toMap</code>, <code>groupingBy</code>, <code>joining</code> 등의 Collector factories를 사용하는 것이 중요합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-47-return-타입으로-스트림보다는-컬렉션을-선택합니다"></a>Item 47. Return 타입으로 스트림보다는 컬렉션을 선택합니다.<a class="hash-link" href="#item-47-return-타입으로-스트림보다는-컬렉션을-선택합니다" title="Direct link to heading">#</a></h2><p>많은 메서드들은 element 시퀀스를 반환합니다. 그러나 Java 8에서 스트림이 여러 플랫폼에 추가되어서 sequence 반환 방법에 대해 적절한 반환 유형을 선정하는 방법이 어려워졌습니다. 다만 이에 대한 명확한 해결책은 없습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Stream &lt;E&gt;에서 Iterable &lt;E&gt; 로의 Adapter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static &lt;E&gt; Iterable &lt;E&gt; iterableOf (Stream &lt;E&gt; stream) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return stream::iterator;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Iterable &lt;E&gt;에서 Stream &lt;E&gt; 로의 Adapter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static &lt;E&gt; Stream &lt;E&gt; streamOf (Iterable &lt;E&gt; iterable) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return StreamSupport.stream (iterable.spliterator (), false);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음과 같이 for-each 문으로 변환 할 수 있습니다. Collection 인터페이스 하위 유형 Iterable 및 보유 stream이 반복 스트림 액세스를 모두 제공하기 때문에, <strong>Collection이나 적절한 subType 등이 public, sequence-returning 메서드에 가장 적합합니다.</strong> 다만, <strong>Collection 반환을 위해 메모리에 큰 시퀀스를 저장하는 것은 좋지 않습니다.</strong></p><p>이를 사용한 코드는 아래와 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Returns the power set of an input set as custom collection</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class PowerSet {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static final &lt;E&gt; Collection&lt;Set&lt;E&gt;&gt; of(Set&lt;E&gt; s) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    List&lt;E&gt; src = new ArrayList&lt;&gt;(s);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (src.size() &gt; 30)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      throw new IllegalArgumentException(&quot;Set too big &quot; + s);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return new AbstractList&lt;Set&lt;E&gt;&gt;() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      @Override public int size() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return 1 &lt;&lt; src.size(); // 2 to the power src.size()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      @Override public boolean contains(Object o) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return o instanceof Set &amp;&amp; src.containsAll((Set)o);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      @Override public Set&lt;E&gt; get(int index) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Set&lt;E&gt; result = new HashSet&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for (int i = 0; index != 0; i++, index &gt;&gt;= 1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">          if ((index &amp; 1) == 1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            result.add(src.get(i));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 입력 목록의 모든 하위 목록 스트림을 반환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class SubLists {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static &lt;E&gt; Stream &lt;List&lt;E&gt;&gt; of (List &lt;E&gt; list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Stream.concat (Stream.of (Collections.emptyList) ()),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        prefixes (list) .flatMap (SubLists :: suffixes));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static &lt;E&gt; Stream &lt;List&lt;E&gt;&gt; prefixes (List &lt;E&gt; list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return IntStream.rangeClosed (1, list.size ())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .mapToObj (end-&gt; list.subList (0, end)) ;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static &lt;E&gt; Stream &lt;List&lt;E&gt;&gt; suffixes (List &lt;E&gt; list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return IntStream.range (0, list.size ())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .mapToObj (start-&gt; list.subList (start, list.size ( )));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 입력 목록의 모든 하위 목록 스트림을 반환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static &lt;E&gt; Stream &lt;List &lt;E &gt;&gt; of (List &lt;E&gt; list) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return IntStream.range (0, list.size ())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .mapToObj (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        start- &gt; IntStream.rangeClosed (start + 1, list.size ())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            .mapToObj (end-&gt; list.subList (start, end)))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .flatMap (x-&gt; x);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같이, element 시퀀스를 반환하는 메서드를 작성할 때, 일부 사용자는 stream으로 처리하고 다른 사용자는 iteration으로 사용하는 것을 좋아할 수 있습니다. 그러나 둘다 잘못된 것이 아니고, 이 두개를 필요에 따라 사용하는 것이 좋습니다. 그리고 Collections로 반환할 수 있으면 좋습니다. (작은 경우, ArrayList / 큰 경우, 사용자 지정 컬렉션)</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-48-스트림을-병렬로-만들-때-주의합니다"></a>Item 48. 스트림을 병렬로 만들 때 주의합니다.<a class="hash-link" href="#item-48-스트림을-병렬로-만들-때-주의합니다" title="Direct link to heading">#</a></h2><p>Java는 동시 프로그래밍 작업을 용이하게 하기 위해 많은 노력을 했습니다.</p><p>예를 들어 다음의 코드를 병렬로 구성하는 경우입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 처음 20 개의 Mersenne 소수를 생성하는 스트림 기반 프로그램</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main (String [] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  primes (). map (p-&gt; TWO.pow (p.intValueExact ()). subtract (ONE))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .filter (mersenne-&gt; mersenne.isProbablePrime (50))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .limit ( 20) .forEach (System.out :: println);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static Stream &lt;BigInteger&gt; primes () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return Stream.iterate (TWO, BigInteger :: nextProbablePrime);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이 작업을 parallel() 스트림 파이프 라인에 호출을 추가해서 속도를 높일려고하면, 이를 병렬화 하는 방법을 모르기 때문에 실패합니다. 즉, <strong>최상의 상황에서 Stream.iteration이거나 intermediate operation limited가 사용되는 경우 파이프 라인을 병렬화해도 성능적인 이득은 없습니다.</strong> 따라서 스트림 파이프라인을 무차별적으로 병렬화하는 것이 좋지 않습니다.</p><p>일반적으로 <code>ArrayList</code>, <code>HashMap</code>, <code>HashSet</code>, <code>ConcurrentHashMap</code>, <code>arrays</code>, int 범위, long 범위 등이 병렬 처리의 성능 향상을 통해 스트림에 가장 적합합니다.</p><p>스트림을 병렬화를 하게 되었을 때, 장애 및 성능 저하가 발생할 수 있게 되었으며 잘못된 결과 및 예측할 수 없는 동작으로 이어지게 됩니다.</p><p>다만 적절한 상황에서, 스트림 파이프라인에 parallel(병렬) 호출을 추가하는 것만으로 프로세서 코어 수에서 거의 선형에 가까운 속도 향상을 달성할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 소수 계산 스트림 파이프 라인-병렬화의 이점</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static long pi (long n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return LongStream.rangeClosed (2, n)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .mapToObj (BigInteger :: valueOf)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .filter (i-&gt; i.isProbablePrime (50))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .count();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 아래는 parallel()을 통해 시간 단축을 한 경우입니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static long pi (long n) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return LongStream.rangeClosed (2, n)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .parallel ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .mapToObj (BigInteger :: valueOf)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .filter (i-&gt; i.isProbablePrime (50 ))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      .count ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><strong>계산의 정확성을 유지하고 속도를 높일 것이라고 믿을 충분한 이유가 없는 경우, 스트림 파이프 라인을 병렬화하는 것은 좋지않습니다.</strong> 이를 사용할 때는, 올바른 상태를 유지하고, 신중한 성능 측정을 수행해서 사용하는 것이 꼭 필요합니다.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/main/docs/Java/effective-java/ch6.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/Java/effective-java/ch5"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Enums 와 Annotation</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/Java/effective-java/ch7"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Methods »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-42-익명-클래스보다-람다를-선택합니다" class="table-of-contents__link">Item 42. 익명 클래스보다 람다를 선택합니다.</a></li><li><a href="#item-43-람다보다-메서드-참조를-선택합니다" class="table-of-contents__link">Item 43. 람다보다 메서드 참조를 선택합니다.</a></li><li><a href="#item-44-표준-기능-인터페이스를-선택합니다" class="table-of-contents__link">Item 44. 표준 기능 인터페이스를 선택합니다.</a></li><li><a href="#item-45-스트림을-신중하게-사용합니다" class="table-of-contents__link">Item 45. 스트림을 신중하게 사용합니다.</a></li><li><a href="#item-46-스트림에서-부작용이-없는-함수를-선택합니다" class="table-of-contents__link">Item 46. 스트림에서 부작용이 없는 함수를 선택합니다.</a></li><li><a href="#item-47-return-타입으로-스트림보다는-컬렉션을-선택합니다" class="table-of-contents__link">Item 47. Return 타입으로 스트림보다는 컬렉션을 선택합니다.</a></li><li><a href="#item-48-스트림을-병렬로-만들-때-주의합니다" class="table-of-contents__link">Item 48. 스트림을 병렬로 만들 때 주의합니다.</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.07564d68.js"></script>
<script src="/til/assets/js/main.c4550fed.js"></script>
</body>
</html>