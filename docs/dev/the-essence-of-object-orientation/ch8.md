---
sidebar_position: 8
---

# 부록. 추상화 기법

- 추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단입니다.
- 사람들은 도메인에 존재하는 개념을 구조화하고 단순화하기 위해 다양한 추상화 기법을 사용합니다.
  - 분류와 인스턴스화 : 분류는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정. 분류의 역이 인스턴스화
  - 일반화와 특수화 : 일반화는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조합니다. 일반호의 역이 특수화
  - 집합과 분해 : 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정, 집합의 반대 과정은 전체를 부분으로 분리하는 분해 과정
- 객체 지향은 동일한 추상화 기법을 통해 프로그램으 분석, 설계, 구현 단계에 걸쳐 일관성 있게 적용할 수 있습니다.

## 1. 분류와 인스턴스화

### 개념과 범주

- 객체를 분류하고 **범주**로 묶는 것은 객체들의 특정 집합에 공통의 **개념**을 적용하는 것
- 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류(classification)** 이라고 합니다.
- 사람들은 분류를 통해서 개별 현상을 하나의 개념으로 다룹니다. 이때 수많은 현상을 **객체**, 하나의 개념을 **타입**이라 합니다.
- 분류는 객체를 타입과 연관시키는 것입니다. 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 합니다.
- 객체지향의 세계에서 개념을 가리키는 용어는 **타입**입니다.
- 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 인스턴스라고 합니다.

### 타입

- 타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요합니다.
  - 심볼 : 타입을 가리키는 간략한 이름이나 명칭
  - 내연 : 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있습니다.
  - 외연 : 타입에 속하는 모든 객체들의 집합

### 외연과 집합

- 타입의 외연은 타입에 속하는 객체들의 집합으로 표현합니다.
- 객체들은 서로 다른 집합에 표현될 수 있습니다.
- 단일 분류와 다중 분류의 차이는 다음과 같습니다.
  - 단일 분류(single classification) : 한 객체가 한 시점에 하나의 타입에 속하는 경우
  - 다중 분류(multiple classification) : 한 객체가 한 시점에 여러 타입에 속하는 경우 (다중 상속과 다릅니다.)
- 객체가 타입을 변경할 수 있는가에 따라 동적 분류과 정적 분류로 나눠집니다.
  - 동적 분류(dynamic classification) : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
  - 정적 분류(static classification) : 객체가 자신의 타입을 변경할 수 없는 경우 (일반적인 언어)
- 유연성이 반드시 필요한 경우, 다중 분류와 동적 분류를 구현할 수 있는 디자인 템플릿을 사용하는 것이 좋으며 일반적으로는 단일 분류와 정적 분류를 선택하는 것이 현명합니다.

### 클래스

- 클래스 기반의 객체지향 언어에서는 클래스는 객체가 공유하는 본질적인 속성을 정의합니다.
- 분류는 분류를 하는 사람과 기준에 따라 결과도 달라집니다.
- 클래스가 없는 프로토타입 언어에서 분류와 인스턴스화는 프로토타입이라는 객체의 복사를 통해 이뤄집니다. (js)

<br/>

## 2. 일반화와 특수화

### 범주의 타입

- 수많은 생물을 정리하기 위해서 **자연의 체계(Systema Naturae)** 가 등장했습니다.
  - 계(동물계) -> 문(척색동물문) -> 강(포유류강) -> 목(육식동물목) -> 과(고양이과) -> 속(고양이속) -> 종(고양이종)
- 이러한 린네의 계층 구조는 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치합니다.
  - 계층의 상위에 있는 범주가 하위 위치의 **범주의 일반화**, 하위의 범주는 계층의 상위의 위치한 **범주의 특수화**라고 합니다.

### 서브타입

- 객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화의 특수화는 계층 구조 안에 존재하는 타입간의 관계를 의미합니다.
  - **슈퍼타입(supertype)** : 어떤 타입이 다른 타입보다 일반적인 경우
  - **서브타입(subtype)** : 어떤 타입이 다른 타입보다 좀 더 특수한 경우
- 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'Is-a 규칙' 규칙을 준수해야합니다.
  - **100% 규칙** : 슈퍼타입의 정의가 100% 서브 타입에 적용되야합니다. 서브타입을 속성과 연관관계 면에서 슈퍼타입과 100%일치해야 합니다.
  - **Is-a 규칙** : 서브 타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 합니다. 이는 대개 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트합니다.

### 상속

- 프로그래밍 언어 세계에서 일반화, 특수화를 구현하는 대표적인 방법은 클래스 간의 상속입니다. 다만, 모든 상속 관계가 일반화 관계는 아닙니다.
- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서 슈퍼타입에 순응(conformance)해야합니다. 즉, 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미합니다.
- 순응은 구조적인 순응과 행위적인 순응으로 나눠집니다.
  - 구조적인 순응(structural conformance) : 타입의 내연과 관련된 100% 규칙을 의미합니다.
  - 행위적인 순응(behavioral conformance) : 서브타입은 슈퍼타입을 행위적으로 대체가능해야합니다. 이를 **리스코프 치환 원칙(Liskov Substitution Principle, LSP)** 이라고 합니다.
- 상속은 서브타이핑과 서브클래스의 두 가지 용도로 사용될 수 있습니다.
  - 서브타이핑(subtyping) : 서브클래스가 슈퍼클래스를 대체할 수 있는 경우, **인터페이스 상속(interface inheritance)**
  - 서브클래싱(subclassing) : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우, **구현 상속(implementation inheritance)**
- 요약하면 **일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적, 또는 행위적 순응 관계를 의미하며 대체 가능성을 내포합니다.**
- 여러클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스간의 **위임(delegation)** 입니다.
- 클래스가 없는 프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이뤄집니다. 타입의 객체를 특정 객체 타입의 특수화로 만들거나 행동을 공유할 수 있게 만들고 싶은 경우, 객체와 객체를 상속 관계를 통해 연결합니다.
- 클래스 기반 언어와 프로토타입 기반 언어 모두 위임 메커니즘을 기반으로 메시지를 해석할 수 있는 대상을 선택합니다.

<br/>

## 3. 집합과 분해

### 계층적인 복잡성

- 호라와 템프스의 우화에서 얻을 수 있는 것은 다음과 같습니다.
  - 복잡성은 계층의 형태를 띕니다.
  - 단순한 형태로부터 복잡한 형태로 진화하는데 걸리는 시간은 그 사이에 존재하는 안정적인 형태의 수와 분포에 의존합니다.
- 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**, 집합과 반대로 전체를 부분으로 분할하는 것을 **분해**라고 합니다.
- 집합은 전체의 내부로 불필요한 세부 사항을 배제하고 큰 이름에서 대상을 다룰 수 있게 해줍니다.

### 합성 관계

- 객체와 객체 사이의 전체-부분 관게를 구현하기 위해서는 **합성 관계**를 사용해야합니다.
- 합성 관계로 연결된 객체들은 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거되는 경우가 많습니다.
- 연관 관계로 연결된 객체들은 생명주기에 어떤 제약도 없습니다.

### 패키지

- 합성 관계도 클래스가 많아지면 의존성 관리가 어렵습니다.
- **패키지(package) 또는 모듈(module)** : 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성요소
- 합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화합니다.
