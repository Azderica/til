---
sidebar_position: 3
---

# 3. 저장소와 검색

> 항상 주변을 단정히 정돈하는 사람은 단지 찾기를 너무 귀찮아하는 사람이다.

데이터베이스는 기본적으로 데이터를 저장하고 요청하는 기능을 제공합니다.

아래에서는 관계형 데이터베이스와 소위 NoSQL라 불리는 데이터베이스에 사용되는 저장소 엔진에 대해 설명합니다. **로그 구조(log-structured)** 장소 엔진과 B-tree 같은 **페이지 지향(page-oriented)** 계열 저장소에 엔진에 대해 이야기합니다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- 많은 데이터베이스는 내부적으로 추가 적용 데이터 파일인 **로그(log)** 를 사용합니다.
- **색인**을 통해서 데이터베이스에서 특정 키의 값을 효율적으로 찾습니다.
- 색인을 잘 쓰면 읽기 쓰기를 올릴 수 있으나, 모든 색인은 쓰기 속도를 떨어트립니다.

### 해시 색인

- 키-값 저장소는 대부분의 프로그래밍 언어에서 볼 수 있는 **사전 타입(dictionary type)** 과 매우 유사합니다.
- 일반적으로 해시 색인을 구성하는 방법은 **오프셋을 사용해서 저장하는 방식**과 **특정 크기의 세그먼트로 로그를 나누는 방식**으로 나눠집니다.
  - 오프셋을 사용하면 단순하지만, 키 값 갱신이 자주 일어날 때 장점을 가집니다. 그러나 용량에서 단점을 가집니다.
  - 특정 크기의 세그먼트로 나누는 방식을 통해 컴팩션을 수행할 수 있습니다. 즉 최신 정보만 유지합니다.이 경우는 키 파일 오프셋 매핑 자체 인메모리 해시 테이블을 가집니다.

#### 해시 색인의 추가 전용 로그 장점

- 추가와 세그먼트 병합은 순차적인 쓰기 작업이기에 무작위 쓰기보다 빠릅니다.
- 세그먼트 파일이 추가 전용이거나 불변이면 동시성과 고장 복구가 훨씬 간단합니다.
- 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있습니다.

#### 해시 색인의 단점

- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으며 문제가 됩니다.
- 해시 테이블은 범위 질의(range query)에 비효율적입니다.

### SS테이블과 LSM 트리

- 위와 같이 세그먼트는 최선 버전만 유지하고 추가적으로 **키로 정렬**한 형식을 정렬된 **문자열 테이블(Sorted String Table)** 혹은 **SS테이블**이라고 합니다.

#### SS테이블 생성과 유지

- 디스크 상에 정렬된 구조를 유지하는 방법은 B트리, 레드 블랙 트리, AVL 트리등을 사용합니다.
- 저장소 엔진은 다음과 같이 만듭니다.
  - 쓰기가 들어오면 위의 트리에 추가합니다. (이 인메모리 트리는 **맴테이블**, memtable 이라고 합니다.)
  - 맴 테이블이 보통 수 메가바이트 정도의 임곗값 보다 커지면 SS테이블 파일로 디스크에 기록합니다.
  - 읽기 요청을 제공하면 먼저 멤테이블에서 키를 찾은 후, 그 다음 디스크 상의 가장 최신 세그먼트에서 찾습니다.
  - 읽기 요청을 제공시 맴테이블에서 키를 찾고 최신의 세그먼트에서 순서대로 찾습니다.
  - 때로는 세그먼트 파일을 합치고 덮어 쓰거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행합니다.

#### SS테이블에서 LSM 트리 만들기

- 위의 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree, LSM 트리)입니다.
- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 **LSM 저장소 엔진**이라 부릅니다.
- 전문 색인은 키-값 색인보다 어려우며 키를 단어로 값은 단어를 포함한 모든 문서의 ID 목록으로 하는 키-값 구조로 구현합니다.

> LSM 트리

![LSM 트리](https://user-images.githubusercontent.com/42582516/136677625-930d8f2a-406a-45c3-9b5c-395702651db8.png)

- [LSM 트리 출처](https://blog.yugabyte.com/a-busy-developers-guide-to-database-storage-engines-the-basics/)

#### 성능 최적화

- 키가 존재하지 않는다는 사실을 확인하기 위해서는 오래된 세그먼트까지 봐야하는 수고가 있으므로 **블룸 필터(Bloom filter)** 를 추가적으로 사용합니다.
- 블룸 필터는 키가 데이터에비스에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기를 많이 절약할 수 있습니다.
- SS 테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략인 **크기 계층(size-tiered)** 와 **레벨 컴팩션(lveled compaction)** 가 있습니다.
  - 레벨 컴팩션은 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동하며 디스크 공간을 덜 사용합니다.
- LSM 트리의 기본 개념은 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 효과적이며 정렬되어 저장되어 있기 때문에 범위 질의를 효율적으로 실행하기에 높은 쓰기 처리량을 보장합니다.

### B트리

- 가장 보편적인 색인 구조입니다.
- 대부분의 관계형 데이터베이스에서 표준 색인 구현이며 비관계형 데이터베이스에서도 많이 사용합니다.
- 앞의 로그 구조화 색인은 데이터베이스를 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나눴다면 B트리는 4KB (혹은 더 큰) 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 합니다.
- 한 페이지는 B 트리의 루트(root)로 지정되며 색인에서 키를 찾으려면 루트에서 시작합니다.
- 페이지는 여러 키와 하위 페이지의 참조를 포함합니다. 하위 페이지는 키가 계속 이어지는 범위를 담당하고 참조 사이의 키는 해당 범위 경계를 나타냅니다.
- 이러한 순서로 아래를 내려가며 **개별 키(리프 페이지, leaf page)** 를 포함하는 페이지에 도달합니다.
- B 트리의 한 페이지에서 하위 페이지를 참조하는 수를 **분기 계수(branching facotr)** 라고 부릅니다.
- B 트리에 존재하는 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록합니다.
- 이러한 알고리즘을 통해 트리는 계속 균형을 유지하고 깊이는 항상 O(log N)이 됩니다.

> B 트리

![B 트리](https://user-images.githubusercontent.com/42582516/136677676-38ebea8d-921e-4b4b-9cf7-0d88d338a039.png)

- [B 트리 출처](https://blog.yugabyte.com/a-busy-developers-guide-to-database-storage-engines-the-basics/)

#### 신뢰할 수 있는 B 트리 만들기

- B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어씁니다.
- 페이지 관리를 잘못하면 고아 페이지(어떤 페이지와 부모 관계가 없는 페이지)가 생길 수 있습니다.
- 데이터베이스가 고장 상황에서 스스로 복구할려면 쓰기 로그(write-ahead log, WAL) 혹은 재실행 로그(redo log)라고 하는 데이터 구조를 사용합니다.
- 동시성 제어는 보통 **래치(latch)** 로 트리의 데이터 구조를 보호합니다.

#### B 트리 최적화

- 페이지 덮어 쓰기와 고장 복구를 위한 WAL 유지보다 일부 데이터베이스는 쓰기 시 복사 방식을 사용합니다.
- 페이지에 전체 키를 저장하는 것이 아닌 키를 축약해 써서 공가능ㄹ 절약합니다.
- 일반적으로 페이지는 디스크 상 어디에나 위치할 수 있습니다.
- 트리에 포인터를 추가합니다.
- 프랙탈 트리 등을 사용합니다.

### B트리와 LSM 트리 비교

- B트리가 LSM 트리보다 일반적으로 구현 성숙도가 더 높으나 LSM 트리도 장점이 있습니다.
- LSM트리는 보통 쓰기에서 더 빠른 반면 B트리는 읽기에서 더 빠르다고 여겨집니다.

#### LSM 트리의 장점

- B트리 색인은 모든 데이터 조각을 최소한 두 번 기록해야하며 몇바이트만 바뀌어도 한 번에 전체 페이지를 기록해야 하는 **오버헤드**가 있습니다. LSM도 비슷하지만, 순차적인 컴팩션된 SS테이블 파일만 씁니다.
- 일반적으로 LSM 트리는 보통 B 트리보다 **쓰기 처리량을 높게 유지**할 수 있습니다. (저장소 엔진 설정과 작업부하에 따라 다르나.)
- LSM 트리는 **압축률**이 좋습니다. 그렇기 때문에 B트리보다 디스크에 더 적은 파일을 생성합니다.
- 데이터를 밀집해서 표현하면 I/O 대역폭 내에서 더 많은 읽기와 쓰기 요청이 가능합니다.

#### LSM 트리의 단점

- LSM의 단점은 **컴팩션 과정이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다는 점**입니다. (디스크의 자원이 한정적이기 때문에)
- 또 다른 컴팩션 문제로 높은 쓰기 처리량에서 발생하며 디스크의 쓰기 대역폭은 유한하기 때문에 발생합니다.
- 쓰기 처리량이 높더라도 컴팩션 설정을 주의 깊게 하지 않으면 컴팩션이 유입 쓰기 속도를 따라갈 수 없습니다.
- B 트리의 장점은 각 키가 색인의 한 곳에만 정확하게 존재한다는 점입니다. 반면 LSM 저장소엔진은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있습니다.

> B트리와 LSM 트리의 미래

B 트리는 데이터베이스 아키텍처에서 깊게 사용되고 있습니다. 그리고 많은 작업 부하에 대해 지속적으로 좋은 성능을 제공합니다. 그러나 새로운 데이터 저장소에서는 로그 구조화 색인이 인기를 얻고 있습니다.

### 기타 색인 구조

<br/>

## 트랜잭션 처리나 분석

<br/>

## 칼럼 지향 저장소

<br/>

## 정리
