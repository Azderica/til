---
sidebar_position: 3
---

# 3. 저장소와 검색

> 항상 주변을 단정히 정돈하는 사람은 단지 찾기를 너무 귀찮아하는 사람이다.

데이터베이스는 기본적으로 데이터를 저장하고 요청하는 기능을 제공합니다.

아래에서는 관계형 데이터베이스와 소위 NoSQL라 불리는 데이터베이스에 사용되는 저장소 엔진에 대해 설명합니다. **로그 구조(log-structured)** 장소 엔진과 B-tree 같은 **페이지 지향(page-oriented)** 계열 저장소에 엔진에 대해 이야기합니다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- 많은 데이터베이스는 내부적으로 추가 적용 데이터 파일인 **로그(log)** 를 사용합니다.
- **색인**을 통해서 데이터베이스에서 특정 키의 값을 효율적으로 찾습니다.
- 색인을 잘 쓰면 읽기 쓰기를 올릴 수 있으나, 모든 색인은 쓰기 속도를 떨어트립니다.

### 해시 색인

- 키-값 저장소는 대부분의 프로그래밍 언어에서 볼 수 있는 **사전 타입(dictionary type)** 과 매우 유사합니다.
- 일반적으로 해시 색인을 구성하는 방법은 **오프셋을 사용해서 저장하는 방식**과 **특정 크기의  세그먼트로 로그를 나누는 방식**으로 나눠집니다.
  - 오프셋을 사용하면 단순하지만, 키 값 갱신이 자주 일어날 때 장점을 가집니다. 그러나 용량에서 단점을 가집니다.
  - 특정 크기의 세그먼트로 나누는 방식을 통해 컴팩션을 수행할 수 있습니다. 즉 최신 정보만 유지합니다.이 경우는 키 파일 오프셋 매핑 자체 인메모리 해시 테이블을 가집니다.

#### 해시 색인의 추가 전용 로그 장점

- 추가와 세그먼트 병합은 순차적인 쓰기 작업이기에 무작위 쓰기보다 빠릅니다.
- 세그먼트 파일이 추가 전용이거나 불변이면 동시성과 고장 복구가 훨씬 간단합니다.
- 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있습니다.

#### 해시 색인의 단점

- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으며 문제가 됩니다.
- 해시 테이블은 범위 질의(range query)에 비효율적입니다.

### SS테이블과 LSM 트리

- 위와 같이 세그먼트는 최선 버전만 유지하고 추가적으로 **키로 정렬**한 형식을 정렬된 **문자열 테이블(Sorted String Table)** 혹은 **SS테이블**이라고 합니다.

#### SS테이블 생성과 유지

- 디스크 상에 정렬된 구조를 유지하는 방법은 B트리, 레드 블랙 트리, AVL 트리등을 사용합니다.
- 저장소 엔진은 다음과 같이 만듭니다.
  - 쓰기가 들어오면 위의 트리에 추가합니다. (이 인메모리 트리는 **맴테이블**, memtable 이라고 합니다.)
  - 맴 테이블이 보통 수 메가바이트 정도의 임곗값 보다 커지면 SS테이블 파일로 디스크에 기록합니다.
  - 읽기 요청을 제공하면 먼저 멤테이블에서 키를 찾은 후, 그 다음 디스크 상의 가장 최신 세그먼트에서 찾습니다.
  - 읽기 요청을 제공시 맴테이블에서 키를 찾고 최신의 세그먼트에서 순서대로 찾습니다.
  - 때로는 세그먼트 파일을 합치고 덮어 쓰거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행합니다.
  

#### SS테이블에서 LSM 트리 만들기

- 위의 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree, LSM 트리)입니다.
- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 **LSM 저장소 엔진**이라 부릅니다.
- 전문 색인은 키-값 색인보다 어려우며 키를 단어로 값은 단어를 포함한 모든 문서의 ID 목록으로 하는 키-값 구조로 구현합니다.

#### 성능 최적화

- 키가 존재하지 않는다는 사실을 확인하기 위해서는 오래된 세그먼트까지 봐야하는 수고가 있으므로 **블룸 필터(Bloom filter)** 를 추가적으로 사용합니다.
- 블룸 필터는 키가 데이터에비스에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기를 많이 절약할 수 있습니다.
- SS 테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략인 **크기 계층(size-tiered)** 와 **레벨 컴팩션(lveled compaction)** 가 있습니다.
  - 레벨 컴팩션은 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동하며 디스크 공간을 덜 사용합니다.
- LSM 트리의 기본 개념은 데이터셋이 가능한 메모리보다 훨씬 더 크더라도 효과적이며 정렬되어 저장되어 있기 때문에 범위 질의를 효율적으로 실행하기에 높은 쓰기 처리량을 보장합니다.  
  
### B트리

### B트리와 LSM 트리 비교

### 기타 색인 구조

<br/>

## 트랜잭션 처리나 분석

<br/>

## 칼럼 지향 저장소

<br/>

## 정리
