---
sidebar_position: 12
---

# 12. 데이터 시스템의 미래

- 앞에서는 **존재하는** 것에 설명했다면 마지막은 미래에는 **어떻게 돼야 하는지**를 설명합니다.
- 책의 목적은 애플리케이션과 시스템을 **신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게** 만드는 방법을 탐구하는 것입니다.

<br/>

## 데이터 통합

- 책에서는 어떤 문제에 대한 해결책을 놓고 장점과 단점, 트레이드 오프에 대해 설명했습니다.
- 가장 적절한 소프트웨어 도구를 선택하는 것은 상황에 다릅니다.
  - 선택의 폭이 넓을 경우, 소프트웨어 제품과 그 제품이 잘 어울리는 환경 사이의 대응관계를 파악하는 것입니다.
  - 대응관계를 이해해도, 데이터를 사용하는 **모든** 다른 상황에 적합한 소프트웨어가 있을 확률은 낮습니다. 즉, 여러 다른 소프트웨어를 함께 엮어 사용해야 합니다.

### 파생 데이터와 특화된 도구의 결합

- 예를 들어, OLTP 데이터베이스와 임의의 키워드를 대상으로 질의하는 전문 검색 색인을 통합하는 요구는 일반적입니다.
  - PostgreSQL와 같은 데이터베이스는 간단한 애플리케이션을 만들기는 충분하지만 복잡한 검색 기능을 지원하기 위해서는 전문적인 탐색도구가 필요합니다.
  - 역으로 검색 색인은 일반적으로 지속성 있는 레코드 시스템으로는 적합하지 않으므로 많은 애플리케이션은 요구사항을 만족하기 위해 두 도구를 결합합니다.
- 데이터 통합의 필요성은 나무가 아닌 숲을 보기 위해 줌아웃해서 조직 전체 데이터플로를 고려할 때야 비로소 명확해집니다.

#### 데이터플로에 대한 추론

- 다른 데이터 접근 양식을 만족하기 위해 같은 데이터의 사본을 여러 저장소 시스템에 유지해야 할 때 입력과 출력을 분명히 해야합니다.
  - 어디서 데이터를 처음으로 기록하는지, 어떤 표현형이 어떤 원본에서 파생되는지, 데이터를 모두 올바른 장소로 올바른 형식으로 어떻게 넣는지 등에 대해 충분히 고려해야 합니다.
- 파생 데이터 시스템은 이벤트 로크를 기반으로 갱신하면 결정적이록 멱등성을 지녀 결함에서 복구하기가 상당히 쉬워집니다.

#### 파생 데이터 대 분산 트랜잭션

- 파생 데이터와 분산 트랜잭션은 큰 차이점이 있습니다.
  - 트랜잭션 시스템은 일반적으로 선형성을 지원합니다. (자신이 쓴 내용 읽기 같은 유용한 기능을 보장합니다)
  - 파생 데이터 시스템은 대개 비동기로 갱신되기 때문에 기본적으로 동시간 갱신 보장을 하지 않습니다.
- _좀 더 나은 분산 트랜잭션 방법이 있을 것이나, 훌륭한 분산 트랜잭션 프로토콜이 널리 지원되지 않는 상태에서 나는 로그 기반 파생데이터가 이종 데이터 시스템을 통합하는 장래성 있는 접근법이라 생각합니다._
- 즉, **최종적 일관성**을 어떻게 다루는 지에 고민해야 니다.

#### 전체 순서화의 제약

- 작은 시스템에서 이벤트 로그의 순서 전체를 보장하는 것은 가능하나 규모가 커지면 한계가 등장합니다. 아래 모두 순서가 애매합니다.
  - 대부분 전체 순서가 정해진 로그를 구축할 때 순서를 결정하려면 모든 이벤트가 **단일 리더 노드** 를 통해야 합니다. 그러나 규모가 커지면 복수의 장비로 파티셔닝을 해야합니다.
  - 데이터센터 전체가 오프라인 상태가 되는 것에 대처하기 위해 서버가 **지역적으로 분산된** 여러 데이터센터에 걸쳐있다면 각 데이터센터에 독립적 리더를 둡니다.
  - 애플리케이션을 **마이크로서비스**로 배포한다고 가정할 때 흔히 선택하는 설계는 각 서비스와 서비스의 지속적인 관련 상태 정보를 독립단위로 배포하고 지속적인 상태는 서비스 간에 공유하지 않습니다.
  - 애플리케이션은 클라이언트 측 상태를 유지하고 사용자 입력이 들어올 때마다 서버의 확인 응답을 기다리지 않고 바로 갱신합니다.
- 이벤트 전체 순서를 결정하는 것은 **전체 순서 브로드캐스트** 라고 합니다.
  - 브로드캐스트는 합의와 동등하지만 이러한 설게는 아직 해결되지 않은 연구 과정입니다. (2020.07 기준)

#### 인과성 획득을 위한 이벤트 순서화

- 이벤트 간 인과성이 없는 경우 전체 순서가 정해지지 않아도 큰 문제가 아닙니다. 동시에 발생한 이벤트는 임의로 순서를 정할 수 있기 때문입니다.
- 예시로 사회 연결망 서비스에서 관계를 맺은 두 사용자가 관계를 끊고, 한명이 남은 친구들에게 그 친구를 불평하는 메시지를 보냈습니다.
  - 이때 친구 상태를 저장하는 곳과 메시지를 저장하는 곳이 다른 시스템에서는 **친구 끊기** 이벤트와 **메시지 보내기** 이벤트 사이의 순서 의존성이 없습니다.
  - 인과성이을 획득하지 못하면 새 메시지에 대해 알림을 보내는 서비스가 **메시지 보내기** 이벤트를 **친구 끊기 이벤트** 전에 보내서 이전 친구에게 잘못된 알림을 보낼 가능성이 있습니다.
- 위 경우는 조인의 타이밍 문제와 관련이 있습니다. 다만 간단히 해결할 방법은 아직 없습니다.
  - 논리적 타임스탬프를 사용하는 경우, 코디 네이션 없이 전체 순서화를 지원할 수 있기 때문에 전체 순서 브로드캐스를 쓸 수 없는 환경에서는 도움될 수도 있지만 잘못된 순서는 유지되고, 메타데이터 또한 줘야합니다.
  - 사용자가 결정을 내리기 전에 사용자가 본 시스템 상태를 기록하는 이벤트를 로깅할 수 있고 해당 이벤트에 고유 식별자를 부여할 수 있다면 이후 이벤트는 인과적 의존성을 기록하기 위한 이벤트 식별자를 참조할 수 있습니다.
  - 충동 해소 알고리즘은 예상치 못한 순서로 전송된 이벤트를 처리하는 데 도움을 줍니다.
- _향후에는 모든 이벤트가 전체 순서 브로드캐스트의 병목을 거치지 않고서도 인과적 의존성을 효율적으로 캡처하고 파생 상태를 정확히 유지하는 애플리케이션 개발 패턴이 등장할 것입니다._

### 일괄 처리와 스트림 처리

<br/>

## 데이터베이스 언번들링

### 데이터 저장소 기술 구성하기

### 데이터플로 주변 애플리케이션 설계

### 파생 상태 관찰하기

<br/>

## 정확성을 목표로

### 데이터베이스에 관한 종단 간 논증

### 제약 조건 강제하기

### 적시성과 무결성

### 믿어라. 하지만 확인하라

<br/>

## 옳은 일 하기

### 예측 분석

### 사생활과 추적

<br/>

## 정리
