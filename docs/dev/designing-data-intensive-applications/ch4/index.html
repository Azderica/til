<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">4. 부호화와 발전 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch4"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="4. 부호화와 발전 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="만물은 변한다. 그대로 있는 것은 아무것도 없다."><meta data-react-helmet="true" property="og:description" content="만물은 변한다. 그대로 있는 것은 아무것도 없다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch4"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch4" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.3b438ef9.js" as="script">
<link rel="preload" href="/til/assets/js/main.8699dd05.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">4. 부호화와 발전</h1></header><div class="markdown"><blockquote><p>만물은 변한다. 그대로 있는 것은 아무것도 없다.</p></blockquote><ul><li>애플리케이션은 필연적으로 시간이 지남에 따라 변합니다. 새로운 제품이 출시하거나 요구사항을 잘 이해 혹은 환경이 변함에 따라 기능이 추가되거나 변경됩니다.</li><li>이러한 경우, 애플리케이션 기능을 변경하려면 저장하는 데이터도 변경해야합니다. 다만 스키마가 변경될 수도 있기 때문에 이전 데이터 타입과 새로운 데이터 타입이 섞여 포함될 수 있습니다.</li><li>대규모 애플리케이션에서 코드 변경은 즉시 반영이 힘듭니다.<ul><li>서버측에서는 rolling upgrade, 혹은 staged rollout 이라고 불리는 순회식 업그레이드를 진행합니다.</li><li>클라이언트 측은 애플리케이션에 의해 전적으로 좌우되며 업데이트를 설치하지 않을 수도 있습니다.</li></ul></li><li>즉, 예전 버전의 코드와 새로운 버전의 코드가 공존할 수 있다는 이야기입니다.<ul><li><strong>하위 호환성</strong> : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 합니다.</li><li><strong>상위 호환성</strong> : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 합니다.</li><li>하위 호환성은 일반적으로 어렵지 않으나 상위 호환성은 어렵습니다.</li></ul></li><li>아래의 챔터에서는 JSON, XML, Protocol Buffers등의 데이터 부호화를 위한 다양한 형식을 살펴봅니다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-부호화-형식"></a>데이터 부호화 형식<a class="hash-link" href="#데이터-부호화-형식" title="Direct link to heading">#</a></h2><ul><li>프로그램은 보통 두가지 형태로 표현된 데이터를 사용해 동작합니다.<ul><li>object, struct, list, array, hash, tree 등의 데이터 구조, <strong>인메모리</strong></li><li>일련의 <strong>바이트</strong>열(ex, JSON 문서)</li><li>인메모리 표현에서 바이트열로의 전환을 <strong>부호화(직렬화나 마샬링)</strong>이라고 하며 반대를 <strong>복호화(파싱, 역직렬화, 언마샬링)</strong>이라고 합니다.</li></ul></li></ul><blockquote><p>직렬화는 트랜잭션에서도 사용되기 때문에 이 책에서는 부호화라고 합니다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="언어별-형식"></a>언어별 형식<a class="hash-link" href="#언어별-형식" title="Direct link to heading">#</a></h3><ul><li>많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 제공합니다.<ul><li>ex) 자바의 <code>java.io.Serializable</code>, 루비의 <code>Marshal</code>, 파이썬의 <code>pickle</code> 등</li></ul></li><li>프로그래밍 언어에 내장된 부호화 라이브러리는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있기 때문에 매우 편리하나 심각한 문제점 또한 많습니다.<ul><li>부호화는 보통 특정 프로그래밍 언어와 묶여 있는 경우가 많습니다.</li><li>동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 합니다. 이는 보안에서의 문제가 될 수도 있습니다.</li><li>데이터 버전 관리는 보통 부호화 라이브러리에서는 나중에 생각하게 됩니다. 위에 언급된 상위, 하위 호환성의 불편만 문제가 등한시 됩니다.</li><li>효율성도 종종 나중에 생각하게 됩니다. (자바가 그런 경우의 대표라고 합니다.)</li></ul></li><li>매우 일시적인 목적 외에는 언어에 내장된 부호화를 사용하는 방식은 일반적으로 좋지 않습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="json과-xml-이진-변형"></a>JSON과 XML, 이진 변형<a class="hash-link" href="#json과-xml-이진-변형" title="Direct link to heading">#</a></h3><ul><li>많은 프로그래밍에서 읽고 쓸 수 있는 표준화 부호화로 JSON과 XML이 있습니다. 그외에도 CSV가 있습니다.</li><li>JSON, XML, CSV는 텍스트 형식이라 어느 정도 사람이 읽을 수 있습니다. 그러나 몇 가지 문제점이 있습니다.<ul><li>XML과 CSV에서는 수와 digit를 구분할 수 없습니다.</li><li>큰 수를 다룰 때, 부동소수점 수를 사용하는 js 언어에서 파싱할 때 부정확해질 수 있습니다.</li><li>JSON과 XML은 유니코드 문자열을 잘 지원하나 이진 문자열을 지원하지 않습니다.</li></ul></li><li>JSON, XNL, CSV는 다양한 용도에서 장점을 가지며 특히 데이터 교환 형식에서 매우 좋습니다.</li><li>특히 이러한 상황에서는 다른 조직의 동의를 얻는 작업이 어렵습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="이진-부호화"></a>이진 부호화<a class="hash-link" href="#이진-부호화" title="Direct link to heading">#</a></h4><ul><li>조직 내에서 사용하는 경우, 최소공통분모 부호화 형식을 사용해야 하는 부담감이 덜합니다. 즉, 더 간편하고 파싱이 빠른 형식을 쓸 수 있습니다.</li><li>데이터 셋의 크기는 용량이 커질 수록 이득이 커집니다.</li><li>JSON과 XML은 이진 형식에 비교하면 둘 다 훨씬 많은 공간을 사용합니다.</li><li>메시지팩이 대표적인 예시며 JSON용 이진 부호화 형식입니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/137404707-6841c1b9-2f6e-4235-adf1-4b48eaa41548.png" alt="json-messagepack"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스리프트와-프로토콜-버퍼"></a>스리프트와 프로토콜 버퍼<a class="hash-link" href="#스리프트와-프로토콜-버퍼" title="Direct link to heading">#</a></h3><ul><li>아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers)는 같은 원리를 기반으로 한 이진ㄷ 부호화 라이브러리입니다.</li><li>스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요합니다.</li></ul><p>스리프트 예제</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly json"><div tabindex="0" class="prism-code language-json codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct Person </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> required string    userName</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token number" style="color:rgb(247, 140, 108)">2</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> optional i64       favoriteNumber;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token number" style="color:rgb(247, 140, 108)">3</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> optional list&lt;string&gt; interests</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>프로토콜 예제</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly json"><div tabindex="0" class="prism-code language-json codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message Person </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  required string user_name      = </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  optional int64 favorite_number = </span><span class="token number" style="color:rgb(247, 140, 108)">2</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  repeated string interests      = </span><span class="token number" style="color:rgb(247, 140, 108)">3</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>스리프트와 프로토콜 버퍼는 각각 여기서 본 것처럼 스키마 정의를 사용해 코드를 생성하는 도구가 있습니다.<ul><li>이 도구를 통해서 다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성합니다.</li><li>애플리케이션 코드는 생성된 코드를 호출해 스키마의 레코드를 부호화하고 복호화합니다.</li></ul></li><li>스리프트는 <strong>바이너리프로토콜(BinaryProtocol)</strong> 과 <strong>컴팩트프로토콜(CompactProtocol)</strong> 이라는 두 가지 이진 부호화 형식이 있습니다.<ul><li>바이너리프로토콜은 필드 이름 대신 <strong>필드 태그(field tag)</strong> 를 포함합니다.</li><li>컴팩트프로토콜은 의미는 같으나 동일한 정보를 34바이트로 줄여서 부호화합니다. (필드 타입과 태그 숫자를 단일 바이트로 줄이고, 가변 길이 변수를 사용합니다.)</li></ul></li><li>프로토콜 버퍼는 스리프트의 컴팩트프로토콜과 비슷하며 같은 데이터를 33바이트로 만듭니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="필드-태그와-스키마-발전"></a>필드 태그와 스키마 발전<a class="hash-link" href="#필드-태그와-스키마-발전" title="Direct link to heading">#</a></h4><ul><li>스키마는 필연적으로 시간이 지남에 따라 변하는 것을 <strong>스키마 발전(schema evolution)</strong> 이라고 부릅니다.</li><li>스리프트와 프로토콜 버퍼는 하위 호환성과 상위 호환성을 유지하기 위해서는 다음의 기능을 제공하빈다.<ul><li>상위 호환성의 경우, 필드에 새로운 태그 번호를 줌으로서 예전 코드가 새로운 코드를 읽을 수 있습니다.</li><li>하위 호환성의 경우, 각 필드에 고유한 태그 번호가 있는 동안에는 같은 의미를 가지고 있기 때문에 예전 데이터를 항상 볼 수 있습니다.</li><li>삭제의 경우, 하위 호환성과 상위 호환성 문제를 해결하는 방식과 반대로 하면 됩니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터타입과-스키마-발전"></a>데이터타입과 스키마 발전<a class="hash-link" href="#데이터타입과-스키마-발전" title="Direct link to heading">#</a></h4><ul><li>필드의 데이터타입을 변경하는 경우는 값이 정확하지 않거나 잘릴 위험이 있습니다.</li><li>프로토콜 버퍼의 기능으로 필드에 repeated 표시자와 optional 필드가 있는데, optional 필드를 repeated 필드로 변경해도 상관이 없습니다.<ul><li>이전 데이터를 읽는 새로운 코드는 0이나 1개의 엘리먼트가 있는 목록으로 봅니다.</li><li>새로운 데이터를 읽는 예전 코드는 목록의 마지막 엘리먼트만 보게 됩니다.</li></ul></li><li>스리프트는 전용 목록 데이터타입이 있으며 목록 데이터타입은 목록 엘리먼트의 데이터타입을 매개변수로 받으며 중첩된 목록을 지원한다는 장점이 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="아브로"></a>아브로<a class="hash-link" href="#아브로" title="Direct link to heading">#</a></h3><ul><li><strong>아파치 아브로</strong>는 프로토콜 버퍼와 스리프트와는 다른 또 하나의 이진 부호화 형식입니다.</li><li>아브로의 예제 스키마는 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly json"><div tabindex="0" class="prism-code language-json codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">record Person </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string             userName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  union </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token null keyword" style="font-style:italic">null</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> long</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> favoriteNumber = </span><span class="token null keyword" style="font-style:italic">null</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  array&lt;string&gt;      interests;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>바이트열에 필드나 데이터타입을 식별하기 위한 정보가 없습니다.</li><li>아브로를 통해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터타입을 미리 파악해야합니다.<ul><li>정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스키마와-읽기-스키마"></a>쓰기 스키마와 읽기 스키마<a class="hash-link" href="#쓰기-스키마와-읽기-스키마" title="Direct link to heading">#</a></h4><ul><li>애플리케이션이 파일인 데이터베이스에 쓰거나 전송 등의 목적으로 어떤 데이터를 아브로로 부호화하길 원한다면 알고 있는 스키마 버전을 사용해 데이터를 부호화합니다. 이 스키마를 <strong>쓰기 스키마(writer&#x27;s schema)</strong> 라고 합니다.</li><li>애플리케이션이 파일이나 데이터베이스에서 또는 네트워크로부터 수신 등으로 읽은 어떤 데이터를 복호화하길 원한다면 데이터가 특정 스키마로 복호화하기를 기대합니다. 이 스키마를 <strong>읽기 스키마(reader&#x27;s schema)</strong> 라고 합니다.</li><li>아브리의 핵심 아이디어는 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 <strong>단지 호환가능하면 된다는 것</strong>입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스키마-발전-규칙"></a>스키마 발전 규칙<a class="hash-link" href="#스키마-발전-규칙" title="Direct link to heading">#</a></h4><ul><li>아브로에서 상위 호환성은 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음을 의미합니다.</li><li>호환성을 유지하기 위해서는 기본 값이 있는 필드만 추가하거나 삭제할 수 있습니다.</li><li>기본값이 없는 필드를 추가하면 새로운 읽기는 예전 쓰기가 기롭된 데이터를 읽을 수 없기 때문에 하위 호환성이 깨집니다.</li><li>아브로에서는 널을 허용하기 위해 <strong>유니온 타입(union type)</strong> 을 사용해야 합니다.</li><li>아브로는 프로토콜 버퍼, 스리프트와 동일한 방식의 optional과 required 표시자를 가지고 있지 않습니다.</li><li>아브로는 타입을 변환할 수 있으므로 필드의 데이터타입 변경이 가능합니다. 필드 이름 변경도 가능하지만 조금 까다롭습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="그러면-쓰기-스키마는-무엇인가"></a>그러면 쓰기 스키마는 무엇인가<a class="hash-link" href="#그러면-쓰기-스키마는-무엇인가" title="Direct link to heading">#</a></h4><ul><li>모든 레코드에 전체 스키마를 포함시킬 수는 없습니다. 왜냐하면 스키마는 부호화된 데이터보다 훨씬 클 가능성이 있습니다.</li><li>아브로를 사용하는 상황에 따라 다릅니다.<ul><li>(1) 많은 레코드가 있는 대용량 파일<ul><li>아브로의 일반적인 용도, 쓰기 시작 부분에 한번만 쓰기 스키마를 포함시키면 됩니다.</li></ul></li><li>(2) 개별적으로 기록된 레코드를 가진 데이터베이스<ul><li>레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에 스키마 버전 목록을 유지합니다.</li></ul></li><li>(3) 네트워크 연결을 통해 레코드 보내기<ul><li>두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전 합의를 할 수 있습니다.</li></ul></li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동적-생성-스키마"></a>동적 생성 스키마<a class="hash-link" href="#동적-생성-스키마" title="Direct link to heading">#</a></h4><ul><li>아브로는 스키마에 <strong>태그 번호가 포함되어 있지 않는 다는 장점</strong>을 가집니다.</li><li>이는 아브로가 동적 생성 스키마에 더 친숙하다는 장점을 가집니다. 이를 통해 상당히 쉽게 스키마를 생성할 수 있습니다.</li><li>데이터베이스 스키마가 변경될 때도 유연함을 가집니다. 스리프트나 프로토콜 버퍼는 필드 태그를 수동으로 할당해야합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="코드-생성과-동적-타입-언어"></a>코드 생성과 동적 타입 언어<a class="hash-link" href="#코드-생성과-동적-타입-언어" title="Direct link to heading">#</a></h4><ul><li>스리프트와 프로토콜 버퍼는 코드 생성에 의존합니다. 자바, C++, C# 같은 정적 타입언어에서 유용합니다.</li><li>자바 스크립트, 루비, 파이썬 같은 동적 타입 프로그래밍 언어에서는 타입 검사기가 없으므로 코드 생성은 데이터를 가져오는데 불필요합니다.</li><li>아브로는 정적 타입 프로그래밍 언어를 위해 코드 생성을 선택적으로 제공합니다.</li><li>객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 간단히 열어 JSON 파일을 보는 것과 같이 데이터를 볼 수 있으며 이를 <strong>자기 기술(self-describing)</strong> 이라고 합니다.</li><li>특성은 아파치 피그 같은 동적 타입 데이터 처리 언어와 함께 사용할 때 특히 유용합니다. 피그에서는 아브로 파일만 있으면 즉시 열어 분석을 시작할 수 있으며 스키마를 생각하지 않고도 아브로 형식으로 출력 파일에 파생 데이터를 기록할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스키마의-장점"></a>스키마의 장점<a class="hash-link" href="#스키마의-장점" title="Direct link to heading">#</a></h3><ul><li>위의 프로토콜 버퍼, 스리프트, 아브로는 스키마를 통해 이진 부호화 형식을 가지며 XML 스키마나 JSON 스키마보다 훨씬 간단하며 더 자세한 유효성 검사를 지원합니다.</li><li>많은 데이터 시스템이 이진 부호화를 독자적으로 구현하기도 합니다. (ex. ODBC, JDBC API)</li><li>이진 부호화에는 좋은 속성이 많이 있습니다.<ul><li>부호화된 데이터에서 필드 이름을 생략할 수 있기 때문에 다양한 &quot;이진 JSON&quot; 변형보다 크기가 더 작을 수 있습니다.</li><li>스키마는 유용한 문서화 형식이므로 복호화시 스키마가 최신 상태인지를 확인할 수 있습니다.</li><li>스키마 데이터베이스를 유지하며 스키마 변경이 적용되기 전에 상위 호환성과 하위 호환성을 확인할 수 있습니다.</li><li>정적 타입 프로그래밍 언어 사용자에게 스키마로부터 코드를 생성하는 기능은 유용합니다. 컴파일 시점에 타입 체크를 할 수 있습니다.</li></ul></li><li>즉, 스키마 발전은 schemaless 또는 읽기 스키마(schema-on-read) JSON 데이터베이스가 제공하는 것과 동일한 종류의 유연성을 제공하며 데이터나 도구 지원도 더 잘 보장합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터플로-모드"></a>데이터플로 모드<a class="hash-link" href="#데이터플로-모드" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터베이스를-통한-데이터-플로"></a>데이터베이스를 통한 데이터 플로<a class="hash-link" href="#데이터베이스를-통한-데이터-플로" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="서비스를-통한-데이터플로-rest와-rpc"></a>서비스를 통한 데이터플로: REST와 RPC<a class="hash-link" href="#서비스를-통한-데이터플로-rest와-rpc" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메시지-전달-데이터플로"></a>메시지 전달 데이터플로<a class="hash-link" href="#메시지-전달-데이터플로" title="Direct link to heading">#</a></h3></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/designing-data-intensive-applications/ch4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-10-18T12:46:38.000Z" class="lastUpdatedDate_1WI_">10/18/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/designing-data-intensive-applications/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 3. 저장소와 검색</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/object-orientation-and-design-patterns/ch1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">객체 지향 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#데이터-부호화-형식" class="table-of-contents__link">데이터 부호화 형식</a><ul><li><a href="#언어별-형식" class="table-of-contents__link">언어별 형식</a></li><li><a href="#json과-xml-이진-변형" class="table-of-contents__link">JSON과 XML, 이진 변형</a></li><li><a href="#스리프트와-프로토콜-버퍼" class="table-of-contents__link">스리프트와 프로토콜 버퍼</a></li><li><a href="#아브로" class="table-of-contents__link">아브로</a></li><li><a href="#스키마의-장점" class="table-of-contents__link">스키마의 장점</a></li></ul></li><li><a href="#데이터플로-모드" class="table-of-contents__link">데이터플로 모드</a><ul><li><a href="#데이터베이스를-통한-데이터-플로" class="table-of-contents__link">데이터베이스를 통한 데이터 플로</a></li><li><a href="#서비스를-통한-데이터플로-rest와-rpc" class="table-of-contents__link">서비스를 통한 데이터플로: REST와 RPC</a></li><li><a href="#메시지-전달-데이터플로" class="table-of-contents__link">메시지 전달 데이터플로</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.3b438ef9.js"></script>
<script src="/til/assets/js/main.8699dd05.js"></script>
</body>
</html>