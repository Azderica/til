---
sidebar_position: 11
---

# 11. 스트림 처리

- 10장에서는 일괄처리에 대해 설명했습니다.
  - 일괄처리란 입력으로 파일 집합을 읽어 출력으로 새로운 파일 집합을 생성하는 기술
  - 그러나, 입력을 사전에 알려진 유한한 크기로 한정한다는 중요한 가정이 있습니다.
- 현실에서는 많은 데이터가 시간에 따라 도착하기 때문에 한정적이지 않습니다.
- 일간 일괄 처리의 문제점은 입력의 변화가 하루가 지나야 반영됩니다.
  - 따라서 고정된 시간 조각이라는 개념을 완전히 버리고 단순히 이벤트가 발생할 때마다 처리해야 합니다. 이가 **스트림 처리**의 기본 개념입니다.

아래에서는 데이터 관리 메커니즘으로 **이벤트 스트림**을 설명합니다.

## 이벤트 스트림 전송

- 스트림 처리 문맥에서 레코드는 보통 이벤트라고 하지만 특정 시점에 일어난 사건에 대한 세부 사항을 포함하는, 작고 독립된 불변 객체라는 점에서 본질적으로 동일합니다.
- 일괄 처리에서 한 번 기록하면 여러 작업에서 읽을 수 있습니다. 스트리밍에서도 이와 비슷합니다.
  - **생산자(producer)**가 이벤트를 한 번 만들면 해당 이벤트를 복수의 소비자(consumer, 구독자(subscriber) 또는 수신자(recipient))가 처리할 수 있습니다.
  - 파일 시스템에서는 관련 레코드 집합을 파일 이름으로 식별하지만 스트림 시스템에서는 대개 **토픽(topic)** 이나 **스트림**으로 관련 이벤트를 묶습니다.
- 이론상으로는 파일이나 데이터베이스가 있으면 생산자와 소비자를 연결하기는 충분하며지만, 지연 시간이 낮으면서 지속해서 처리하는 방식을 지향할 때 데이터스토어를 이런 용도에 맞게 설계하지 않았다면 폴링 방식은 비용이 큽니다.
- 데이터베이스는 전통적으로 알림 메커니즘을 강력하게 지원하지 않습니다.
  - 관계형 데이터베이스에서는 보통 트리거(trigger) 기능이 있습니다.
  - 그러나 트리거는 기능이 제한적이고 데이터베이스를 설계한 이후에 도입된 개념이며, 이벤트 알림 전달 목적으로 개발된 도구는 따로 있습니다.

### 메시징 시스템

- 새로운 이벤트에 대해 소비자에게 알려주려고 쓰이는 일반적인 방법은 **메시징 시스템(messaging system)** 을 사용하는 것입니다.
  - 생산자는 이벤트를 포함한 메시지를 전송하고, 메시지는 소비자에게 전달됩니다.
- 메시징 시스템을 구축하는 가장 간단한 방법은 생산자와 소비자 사이에 유닉스 파이프나 TCP 연결과 같은 직접 통신 채널을 사용하는 방법입니다.
- **발행/구독(publish/subscribe)** 모델에서는 여러 시스템들이 다양한 접근법을 사용합니다. 아래 두 질문이 이 시스템을 구별하는데 상당히 도움이 됩니다.
  - 생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 메시지를 전송한다면 어떻게 될지?
    - 세가지 선택지인 메시지를 버리거나, 큐에 메시지를 버퍼링하거나, 생산자를 적용합니다.
  - 노드가 죽거나 일시적으로 오프라인이 된다면 어떻게 될까? 손실되는 메시지가 있을까?
    - 디스크에 기록하거나 복제본 생성을 하거나, 둘 모두를 해야합니다.
- 메시지의 유실을 허용할지 말지는 애플리케이션에 따라 상당히 다릅니다.

#### 생산자에서 소비자로 메시지를 직접 전달하기

- 많은 메시지 시스템은 중간 노드를 통하지 않고 생산자와 소비자를 네트워크로 직접 통신합니다.
  - UDP 멀티캐스트는 낮은 지연이 필수인 주식 시장과 같은 금융 산업에서 널리 사용됩니다.
  - ZeroMQ 같은 브로커가 필요없는 메시징 라이브러리는 TCP 또는 IP 멀티캐스팅 상에서 발행/구독 메시징을 구현합니다.
  - StatsD과 BruBeck은 네트워크 상의 모든 장비로부터 지표를 수집하고 모니터링하고 UDP 메시징을 사용합니다.
  - 소비자가 네트워크에 서비스를 노출하면 생산자는 HTTP나 RPC 요청을 직접 보낼 수 있습니다.
- 직접 메시징 시스템은 설계 상호아에서는 잘동작하지만 일반적으로 메시지가 유실될 수 있는 가능성을 고려해서 애플리케이션 코드를 작성해야 합니다.
  - 즉, 직접 메시징 시스템은 일반적으로 생산자와 소비자가 항상 온라인 상태라고 가정합니다.
- 소비자가 오프라인이라면 메시지를 전달하지 못하는 상태에 있는 동안 전송된 메시지는 잃어버릴 수 있습니다.
  - 일부 프로토콜은 실패한 메시지 전송을 생산자가 재시도하게끔 하지만 생산자 장비가 죽어버리면 재시도하려고 했던 메시지 버퍼를 잃어버릴 수 있기 때문에 문제가 있습니다.

#### 메시지 브로커

- 직접 메시징 시스템의 대안으로 널리 사용되는 방법은 **메시지 브로커(메시지 큐)** 를 통해 메시지를 보내는 것입니다.
  - 메시지 브로커는 근본적으로 메시지 스트림를 처리하는 데 최적화된 데이터베이스의 일종입니다.
- 브로커에 데이터가 모이기 때문에 이 시스템은 클라이언트의 상태 변경(접속, 접속 해제, 장애)에 쉽게 대처할 수 있습니다.
  - 지속성 문제가 생산자와 소비자에서 브로커로 옮겨갔기 때문입니다.
- 큐 대기를 하면 소비자는 일반적으로 **비동기**로 동작합니다.
  - 생산자가 메시지를 보낼 때 생산자는 브로커가 해당 메시지를 버퍼에 넣었는지만 확인하고 소비자가 메시지를 처리하기까지 기다리지 않습니다.
  - 메시지를 소비자로 배달하는 것은 정해지지 않은 미래 시점이지만 때로는 큐에 백로그가 있다면 상당히 늦을 수 있습니다.

#### 메시지 브로커와 데이터베이스의 비교

- 어떤 메시지 브로커는 XA 또는 JTA를 이용해 2단계 커밋을 수행하기도 합니다. 메시지 브로커와 데이터베이스에는 중요한 실용적 차이가 있지만 이 특징은 데이터베이스의 속성과 상당히 비슷합니다.
  - 데이터베이스는 명시적으로 데이터 삭제될 때까지 데이터를 보관합니다. 반면 메시지 브로커 대부분은 소비자에게 데이터 배달이 성공할 경우 자동으로 메시지를 삭제합니다.
  - 메시지 브로커는 대부분 메시지를 빨리 지우기 때문에 작업 집합이 상당히 작다고 가정합니다. 즉 큐 크기가 작습니다.
  - 데이터베이스는 보조 색인을 지원하고 데이터 검색을 위한 다양한 방법을 지원하는 반면 메시지 브로커는 특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식을 지원합니다.
  - 데이터베이스에 질의할 때 그 결과는 일반적으로 질의 시점의 데이터 스냅숏을 기준으로 합니다.

#### 복수 소비자

- 복수 소비자가 같은 토픽에서 메시지를 읽을 때 사용하는 주요 패턴은 두가지입니다.
  - **로드밸런싱**
    - 각 메시지는 소비자 중 하나로 전달됩니다. 따라서 소비자들은 해당 토픽의 메시지를 처리하는 작업을 공유합니다.
    - 브로커는 메시지를 전달할 소비자를 임의로 지정합니다.
  - **팬 아웃**
    - 각 메시지는 **모든** 소비자에게 전달됩니다.
- 이 두가지 패턴은 함께 사용 가능합니다.

#### 확인 응답과 재전송

- 소비자들은 언제라도 장애가 발생할 수 있습니다.
  - 메시지를 잃어버리지 않기 위해 메시지 브로커는 **확인 응답**을 사용합니다.
- 브로커가 확인 응답을 받기 전에 클라이언트로의 연결이 닫히거나 타임아웃되면 브로커는 메시지가 처리되지 않았다고 가정하고 다른 소비자에게 다시 전송합니다.
- 부하 균형 분산과 결합할 때 이런 재전송 행위는 메시지 순서에 영향을 미치게 됩니다.
- 메시지 브로커는 JMS와 AMQP 표준에서 요구하는 대로 메시지 순서를 유지하려 노력할지라도 부하 균형 분산과 메시지 재전송을 조합하면 필연적으로 메시지 순서가 변경됩니다.
  - 그러나, 부하 균형 분산 기능을 사용하지 않는다면 이 문제를 피할 수 있습니다.

### 파티셔닝된 로그

<br/>

## 데이터베이스와 스트림

### 시스템 동기화 유지하기

### 변경 데이터 캡처

### 이벤트 소싱

### 상태와 스트림 그리고 불변성

<br/>

## 스트림 처리

### 스트림 처리의 사용

### 시간에 관한 추론

### 스트림 조인

### 내결함성

<br/>

## 정리
