---
sidebar_position: 5
---

# 5. 복제

**복제**란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다.

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄입니다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 ㄱ사용성을 높입니다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘립니다.

5장에서는 데이터셋이 작다고 가정한 경우, 6장에는 그 데이터가 단일 장비에 넣기에는 너무 커서 파티셔닝(샤딩
)에 대해 이야기 합니다.

복제에서의 어려움은 복제된 데이터의 변경 처리에 있으며 대표적으로 유명한 알고리즘은 다음과 같습니다.

- **단일 리더(single-leader)** 복제
- **다중 리더(multi-leader)** 복제
- **리더 없는(leaderless)** 복제

모든 분산 데이터베이스는 세 가지 방법 중 하나를 사용하며 각각의 장단점이 있습니다.

## 리더와 팔로워

- 데이터베이스의 복사본을 전달하는 각 노드를 **복제 서버(replica)** 라고 합니다.
- 데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리되어야 합니다. 이를 위한 해결책은 다음과 같습니다.
  - **리더 기반 복제(leader-based replication)**
  - **능동(active)/수동(passive)**
  - **마스터(master) 슬레이브(slave) 복제**
- 복제 서버 중 하나를 **리더(leader, 마스터나 프라이머리(primary))** 로 지정합니다.
- 다른 복제 서버는 **팔로워(follower)(읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby))** 라고 합니다.
- 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 **복제 로그(replication log)**나 **변경 스트림(change stream)** 의 일부로 팔로워에게 전송합니다.
- 이러한 복제 모드는 많은 관계형 데이터베이스, 몽고DB와 같은 비관계형 DB, 카프카 등의 분산 메시지 브로커에도 사용됩니다.

### 동기식 대 비동기식 복제

- 복제 시스템의 중요한 세부 사항은 복제가 **동기식**으로 발생하는지 **비동기식**으로 발생하는지 여부합니다.

#### 동기식

![](https://user-images.githubusercontent.com/42582516/138686819-90d651f4-969c-4c3f-b305-48aa7607f50f.png)

- 다음의 예시는 동기식입니다. 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장합니다. (다만, 이 경우는 비현실적 입니다.)
- 현실적으로 동기식 복제를 사용하려면 팔로워 하나는 동기식, 그 밖에는 비동기식으로 하는 경우가 많습니다. 이러한 설정을 **반동기식(semi-synchronous)** 라고 합니다.

#### 비동기식

- 보통 리더 기반 복제는 완전히 비동기식으로 구성합니다.
- 리더가 잘못되었을 때 복구가 어렵고 쓰기에 지속성을 보장하지 않는다는 의미입니다.
- 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있습니다.
- 비동기식 복제는 내구성을 약화시키기 때문에 나쁜 트레이드오프로 보이나 팔로워가 많거나 분산 구조일 때는 많이 사용됩니다.

### 새로운 팔로워 설정

- 대부분의 신규 팔로워 설정은 중단시간 없이 수행할 수 있습니다.
  - (1) 가능하면 데이터를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져옵니다.
  - (2) 스냅숏을 새로운 팔로워 노드에 복사합니다.
  - (3) 스냅숏 이후 발생한 모든 데이터 변경을 요청합니다. (로그 데이터 이용)
  - (4) 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 이야기하며 리더에 발생하는 데이터 변화를 처리할 수 있습니다.

### 노드 중단 처리

시스템의 모든 노드는 장애나 유지보수로 인해 중단될 수 있습니다. 이는 큰 장점 중 하나이며 목표는 노드 중단의 영향을 최소화 하는 것이 목표입니다.

#### 팔로워 장애: 따라잡기 복구

- 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관하여 이후에 쉽게 복구합니다.

#### 리더 장애: 장애 복구

- 리더의 장애를 처리하는 일은 까다롭습니다. 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야합니다. 이를 **장애 복구** 라고 합니다.
- 자동 장애 복구는 다음과 같은 단계로 진행됩니다.
  - (1) 리더가 장애인지 판단
  - (2) 새로운 리더를 선택
  - (3) 새로운 리더 사용을 위해 시스템을 설정합니다.
- 장애 복구 과정에서 여러 문제가 발생할 수 있습니다.
  - 비동기식 복제인 경우, 이전 리더의 쓰기를 일부 수신하지 못할 수가 있습니다.
  - 쓰기를 폐기하는 방법이 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정되야 한다면 특히 위험합니다.
  - 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있습니다. (스플릿 브레인, split brain)
  - 타임아웃이 짧은 경우 불필요한 장애 복구가 있을 수 있습니다.
- 이러한 문제로 인해 수동 장애 복구를 하는 경우도 많습니다.

### 복제 로그 구현

#### 구문 기반 복제

- 가장 간단한 사례로 리더는 모든 쓰기 요청(구문, statement)을 기록하고 쓰기를 실행합니다. 즉, SQL 구문을 파싱하고 실행하는 경우 입니다.

#### 쓰기 전 로그 배송

- 일반적으로 모든 쓰기는 로그에 기록합니다.
  - 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분입니다. 로그 세그먼트는 작게 유지되고 백그아운드로 가비지 컬렉션을 합니다.
  - 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 **쓰기 전 로그(WAL)** 에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있습니다.
- 두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하느 추가 전용(append-only) 바이트 열입니다.
- PostgreSQL, Oracle 등에서 주로 사용됩니다.
- 큰 단점은 로그가 제일 저수준의 데이터를 기술합니다. (즉, 데이터베이스 버전이 다른 경우 실행할 수 없습니다.)
  - 다만, 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하게 설정하면 문제를 해결할 수도 ㅣㅇㅆ습니다.
  - 불일치가 허용되지 않는다면 업그레이드시마다 중단 시간이 필요합니다.

#### 논리적(로우 기반) 로그 복제

- 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이며 이를 **논리적 로그(logical log)** 라고 부릅니다.
  - 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함합니다.
  - 삭제된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함해야합니다.
  - 갱신된 로우의 로그는 로우를 고유하게 식별하는데 필요하는 정보와 모든 칼럼의 새로운 값을 포함합니다.
- 이러한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬우며 이 기술을 **변경 데이터 캡처(change data capture)** 라고 부릅니다.

#### 트리거 기반 복제

- 지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현됩니다.
- 조금 더 유연성이 필요한 상황에서는 복제의 기능을 애플리케이션 층으로 옮깁니다.
- 오라클의 골든 게이트 같은 도구는 트리거나 스토어드 프로시저를 사용합니다.
- 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 합니다. 이 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행됩니다.
- 일반적으로 트리거 기반 복제는 **다른 복제 방식보다 많은 오버헤드**가 있습니다. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생하며 그럼에도 **유연성에 장점**이 있어 유리합니다.

<br/>

## 복제 지연 문제

- 노드 내결함성을 갖추려는 단 한가지 이유는 복제가 필요하기 때문입니다.
- 리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능합니다.
- 이러한 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있습니다.
- 애플리케이션이 비동기 팔로워에서 덴이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있습니다. 이때는 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 따라잡게 되고 리더와 일치하게 되며 이런 효과를 **최종적 일관성**이라고 합니다.
- 애플리케이션에서 지연이 매우 크면 불일치는 이론적인 문제가 아닌 실제 문제가 됩니다.

아래는 복제 지연이 발생할 때 발생하는 세 가지 사례입니다.

### 자신이 쓴 내용 읽기

- 새로운 데이터가 제출되면 리더에게 전송해야 하지만 사용자가 데이터를 볼 때는 팔로워에서 읽을 수 있습니다. 특히 데이터를 자주 읽고 적게 쓸때 유리합니다.
- 비동기식 복제는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않았을 수 있습니다.
- 이런 경우, **쓰기 후 읽기 일관성**이 필요합니다. 다양한 기법이 존재합니다.
  - 수정 내용을 읽을 때는 리더에서 읽기
  - 일정 시간은 리더에서 모든 읽기, 복제 지연을 모니터링해 리더보다 일정시간 보다 이상 늦은 팔로워에 대해 질의를 금지합니다.
  - 클라이언트는 가장 최근 쓰기의 타임스탬프를 기록할 수 있으므로 갱신을 반영하기 전까지 질의를 대리합니다.
  - 복제 서버가 여러 데이터센터에 분산되어 있다면 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅돼야합니다.
- 동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생합니다. 이때는 **디바이스 간(cross-device)** 쓰기 후 읽기 일관성이 제공돼야 합니다.
  - 한 디바이스가 다른 디바이스의 갱신을 모르므로 메타데이터는 중앙집중식으로 관리합니다.
  - 복제 서버가 여러 데이터센터 간에 분산된 경우 동일 데이터센터로 라우팅된다는 보장이 없으므로 필요하다면 동일한 데이터센터로 라우팅합니다.

### 단조 읽기

비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 **시간이 거꾸로 흐르는 현상**을 볼 수 있습니다.

![시간 역행](https://user-images.githubusercontent.com/42582516/138970169-f23428ea-c004-4607-a032-26d23229702a.png)

단조 읽기(monotonic read)는 이런 종류의 이상 현상이 발생하지 않음을 보장합니다.

- 단조 읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 강한 보장입니다. 즉, 데이터를 읽을 때 이전 값을 볼 수는 있으나 시간 역행은 불가능합니다.
- 이를 구현하는 한 방법은 읽기가 항상 동일한 복세 서버에서 수행되게 하는 것입니다.

### 일관된 순서로 읽기

### 복제 지연을 위한 해결책

<br/>

## 다중 리더 복제

### 다중 리더 복제의 사용 사례

### 쓰기 충돌 다루기

### 다중 리더 복제 토폴로지

<br/>

## 리더 없는 복제

### 노드가 다운됐을 때 데이터베이스에 쓰기

### 정족수 일관성의 한계

### 느슨한 정족수와 암시된 핸드오프

### 동시 쓰기 감지
