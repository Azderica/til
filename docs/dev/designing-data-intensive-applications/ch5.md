---
sidebar_position: 5
---

# 5. 복제

**복제**란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다.

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄입니다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 ㄱ사용성을 높입니다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘립니다.

5장에서는 데이터셋이 작다고 가정한 경우, 6장에는 그 데이터가 단일 장비에 넣기에는 너무 커서 파티셔닝(샤딩
)에 대해 이야기 합니다.

복제에서의 어려움은 복제된 데이터의 변경 처리에 있으며 대표적으로 유명한 알고리즘은 다음과 같습니다.

- **단일 리더(single-leader)** 복제
- **다중 리더(multi-leader)** 복제
- **리더 없는(leaderless)** 복제

모든 분산 데이터베이스는 세 가지 방법 중 하나를 사용하며 각각의 장단점이 있습니다.

## 리더와 팔로워

- 데이터베이스의 복사본을 전달하는 각 노드를 **복제 서버(replica)** 라고 합니다.
- 데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리되어야 합니다. 이를 위한 해결책은 다음과 같습니다.
  - **리더 기반 복제(leader-based replication)**
  - **능동(active)/수동(passive)**
  - **마스터(master) 슬레이브(slave) 복제**
- 복제 서버 중 하나를 **리더(leader, 마스터나 프라이머리(primary))** 로 지정합니다.
- 다른 복제 서버는 **팔로워(follower)(읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby))** 라고 합니다.
- 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 **복제 로그(replication log)**나 **변경 스트림(change stream)** 의 일부로 팔로워에게 전송합니다.
- 이러한 복제 모드는 많은 관계형 데이터베이스, 몽고DB와 같은 비관계형 DB, 카프카 등의 분산 메시지 브로커에도 사용됩니다.

### 동기식 대 비동기식 복제

- 복제 시스템의 중요한 세부 사항은 복제가 **동기식**으로 발생하는지 **비동기식**으로 발생하는지 여부합니다.

#### 동기식

![](https://user-images.githubusercontent.com/42582516/138686819-90d651f4-969c-4c3f-b305-48aa7607f50f.png)

- 다음의 예시는 동기식입니다. 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장합니다. (다만, 이 경우는 비현실적 입니다.)
- 현실적으로 동기식 복제를 사용하려면 팔로워 하나는 동기식, 그 밖에는 비동기식으로 하는 경우가 많습니다. 이러한 설정을 **반동기식(semi-synchronous)** 라고 합니다.

#### 비동기식

- 보통 리더 기반 복제는 완전히 비동기식으로 구성합니다.
- 리더가 잘못되었을 때 복구가 어렵고 쓰기에 지속성을 보장하지 않는다는 의미입니다.
- 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있습니다.
- 비동기식 복제는 내구성을 약화시키기 때문에 나쁜 트레이드오프로 보이나 팔로워가 많거나 분산 구조일 때는 많이 사용됩니다.

### 새로운 팔로워 설정

### 노드 중단 처리

### 복제 로그 구현

<br/>

## 복제 지연 문제

### 자신이 쓴 내용 읽기

### 단조 읽기

### 일관된 순서로 읽기

### 복제 지연을 위한 해결책

<br/>

## 다중 리더 복제

### 다중 리더 복제의 사용 사례

### 쓰기 충돌 다루기

### 다중 리더 복제 토폴로지

<br/>

## 리더 없는 복제

### 노드가 다운됐을 때 데이터베이스에 쓰기

### 정족수 일관성의 한계

### 느슨한 정족수와 암시된 핸드오프

### 동시 쓰기 감지
