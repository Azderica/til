---
sidebar_position: 7
---

# 7. 트랜잭션

현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다.

- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있습니다.
- 애플리케이션은 언제라도 죽을 수 있습니다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있습니다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있습니다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있습니다.
- 클라이언트 사이의 경쟁 조건을 예측하지 못한 버그를 유발할 수 있습니다.

시스템이 **신뢰성**을 지니려면 이러한 결함을 처리해서 전체 시스템의 치명적인 장애로 이어지는 것을 막아야 합니다.

- 트랜잭션은 이런 문제를 **단순화**하는 메커니즘으로 채택되었습니다.
- 트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법입니다.
  - 개념적으로 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행됩니다.
  - 트랜잭션은 전체가 **성공(커밋)** 하거나 **실패(abort, 롤백)** 합니다
  - 트랜잭션을 사용하면 안전하게 재시도할 수 있기 때문에 오류 처리를 하기 훨씬 단순해집니다.
- 트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만들어졌습니다.
  - 트랜잭션을 통해 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있습니다. **(안전성 보장, safety guarantee)**
- 모든 애플리케이션에서 트랜잭션이 필요하지 않으며 때로는 트랜잭션적인 보장을 완화하건아 아예 쓰지않는 것이 이득입니다.

데이터베이스에서 문제가 생길 수 있는 여러 예를 조사하고 이를 사용하는 알고리즘을 살펴봅니다. 동시성 제어 분야를 깊게 다루며 발생할 수 있는 다양한 종류의 경쟁조건과 데이터베이스에서 **커밋 후 읽기(read committed), 스냅숏 격리(snapshot isolation), 직렬성(serializability)** 같은 격리 수준을 어떻게 같은 격리 수준을 구현하는지에 대해 설명합니다.

## 애매모호한 트랜잭션의 개념

### ACID의 의미

### 단일 객체 연산과 다중 객체 연산

<br/>

## 완화된 격리 수준

### 커밋 후 읽기

### 스냅숏 격리와 반복 읽기

### 갱신 손실 방지

### 쓰기 스큐와 팬텀

<br/>

## 직렬성

### 실제적인 직렬 실행

### 2단계 잠금(2PL)

### 직렬성 스냅숏 격리(SSI)

<br/>

## 정리
