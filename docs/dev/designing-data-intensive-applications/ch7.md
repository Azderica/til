---
sidebar_position: 7
---

# 7. 트랜잭션

현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다.

- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있습니다.
- 애플리케이션은 언제라도 죽을 수 있습니다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있습니다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있습니다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있습니다.
- 클라이언트 사이의 경쟁 조건을 예측하지 못한 버그를 유발할 수 있습니다.

시스템이 **신뢰성**을 지니려면 이러한 결함을 처리해서 전체 시스템의 치명적인 장애로 이어지는 것을 막아야 합니다.

- 트랜잭션은 이런 문제를 **단순화**하는 메커니즘으로 채택되었습니다.
- 트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법입니다.
  - 개념적으로 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행됩니다.
  - 트랜잭션은 전체가 **성공(커밋)** 하거나 **실패(abort, 롤백)** 합니다
  - 트랜잭션을 사용하면 안전하게 재시도할 수 있기 때문에 오류 처리를 하기 훨씬 단순해집니다.
- 트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만들어졌습니다.
  - 트랜잭션을 통해 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있습니다. **(안전성 보장, safety guarantee)**
- 모든 애플리케이션에서 트랜잭션이 필요하지 않으며 때로는 트랜잭션적인 보장을 완화하건아 아예 쓰지않는 것이 이득입니다.

데이터베이스에서 문제가 생길 수 있는 여러 예를 조사하고 이를 사용하는 알고리즘을 살펴봅니다. 동시성 제어 분야를 깊게 다루며 발생할 수 있는 다양한 종류의 경쟁조건과 데이터베이스에서 **커밋 후 읽기(read committed), 스냅숏 격리(snapshot isolation), 직렬성(serializability)** 같은 격리 수준을 어떻게 같은 격리 수준을 구현하는지에 대해 설명합니다.

## 애매모호한 트랜잭션의 개념

현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원합니다.

- 비관계형(NoSQL) 데이터베이스가 주류로 바뀌며 트랜잭션을 약한 보장을 의미하는 단어로 트랜잭션 의미가 재정의 되었습니다.
- 트랜잭션은 이점과 한계가 있습니다. 이에 따라 잘 조절해야합니다.

### ACID의 의미

트랜잭션이 제공하는 안전성 보장은 크게 아래로 나눠집니다.

- 원자성(**A**tomicity)
- 일관성(**C**onsistency)
- 격리성(**I**solation)
- 지속성(**D**urability)

그러나 현실에서는 데이터베이스마다 ACID 구현이 제각각이며 **격리성**은 의미 주변에 모호함이 많습니다. (ACID 표준을 따르지 않는 시스템은 때로 **BASE**라 불립니다. 가용성을 제공하고(Basically Available), 유연한 상태를 가지며(Soft state), 최종적 일관성(Eventual consistency) 의 의미를 가집니다.)

#### 원자성

- 일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 무엇을 가르킵니다.
- ACID의 원자성은 클라이언트가 쓰기 작업을 몇 개 실행할 때, **여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋)될 수 없으면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실횅한 쓰기를 무시하거나 취소**해야합니다.
- 오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력은 ACID의 원자성의 결정적인 특징입니다.

#### 일관성

- 일관성은 괴장히 여러 의미로 쓰입니다. (복제 일관성, 최종적 일관성, 일관성 해싱, CAP의 일관성 등등)
- ACID의 일관성은 데이터 베이스가 **좋은 상태(항상 진실이어야하는 데이터에 관한 어떤 선언, 불변식(invariant)가 있다는 것)** 에 있어야 한다는 애플리케이션에 특화된 개념입니다.
- 일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임입니다.
- 원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성입니다.

#### 격리성

- 대부분 동시에 여러 클라이언트에서 데이터베이스에 접근하고, 클라이언트 들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 됩니다.
- ACID의 격리성은 동시에 실행되는 트랜잭션은 서로 격리되는 것을 의미합니다.

#### 지속성

- 데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것입니다.
- 지속성(durability)는 트랜잭션이 **성공적으로 커밋**되었다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 **트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장**입니다.

> 복제와 지속성

- 고가ㅓ에는 지속성이 아카이브 테이프에 기록되는 것을 의미하였고, 그 이후는 디스크나 SSD에 기록하는 것, 현재는 복제를 의미합니다.
- 이중에서 왑녁한 것은 없으며, 여러 위험을 줄이는 기법일 뿐이며 같이 쓸 수 있으면 그렇게 해야합니다.

### 단일 객체 연산과 다중 객체 연산

요약하면 ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술합니다.

- 원자성 : 데이터베이스는 전부 반영되거나 아무것도 반영되지 않음을 보장합니다.
- 격리성 : 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 합니다.

**다중 객체 트랜잭션**은 흔히 데이터의 여러 조각이 동기화된 상태로 유지되어야 할 때 필요합니다.

- 다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 합니다.
- 비관계형 데이터베이스는 이런식으로 연산을 묶는 경우가 없어서, 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 의미하지는 않습니다.

#### 단일 객체 쓰기

- 원자성과 격리성은 단일 객체를 변경하는 경우에도 적용됩니다.
- 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)를 방지하므로 유용합니다.

#### 다중 객체 트랜잭션의 필요성

- 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했습니다.
  - 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기도 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오가 있습니다.
- 단일 객체, 갱신, 삭제만으로도 충분한 사용 사례가 있습니다. (굳이 다중 객체 트랜잭션이 필요 없는 경우)

#### 오류와 어보트 처리

- 트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있습니다.
- 다만 모든 시스템이 이러한 철학을 따르지 않으며, 리더 없는 복제를 사용하는 데이터 스토어는 "최선을 다하는(best effort)" 원칙을 기반으로 더 많은 일을 합니다.
  - 이 경우, 오류 복구는 애플리케이션에게 책임이 있습니다.
- 어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지않습니다.
  - 트랜잭션이 실제로 성공했으나 네트워크 이슈가 발생한 경우
  - 오류가 과부하 때문에 발생한 경우
  - 일시적인 오류만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 소용이 없습니다.
  - 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수 효과가 실행될 수 있습니다.
  - 클라이언트 프로세스가 재시도 중에 죽어버리면 ㅋ클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실이 됩니다.

<br/>

## 완화된 격리 수준

### 커밋 후 읽기

### 스냅숏 격리와 반복 읽기

### 갱신 손실 방지

### 쓰기 스큐와 팬텀

<br/>

## 직렬성

### 실제적인 직렬 실행

### 2단계 잠금(2PL)

### 직렬성 스냅숏 격리(SSI)

<br/>

## 정리
