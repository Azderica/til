<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">5. 복제 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="5. 복제 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="복제란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다."><meta data-react-helmet="true" property="og:description" content="복제란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.a1bc5052.js" as="script">
<link rel="preload" href="/til/assets/js/main.0f40afc0.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">5. 복제</h1></header><div class="markdown"><p><strong>복제</strong>란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다.</p><ul><li>지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄입니다.</li><li>시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 ㄱ사용성을 높입니다.</li><li>읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘립니다.</li></ul><p>5장에서는 데이터셋이 작다고 가정한 경우, 6장에는 그 데이터가 단일 장비에 넣기에는 너무 커서 파티셔닝(샤딩
)에 대해 이야기 합니다.</p><p>복제에서의 어려움은 복제된 데이터의 변경 처리에 있으며 대표적으로 유명한 알고리즘은 다음과 같습니다.</p><ul><li><strong>단일 리더(single-leader)</strong> 복제</li><li><strong>다중 리더(multi-leader)</strong> 복제</li><li><strong>리더 없는(leaderless)</strong> 복제</li></ul><p>모든 분산 데이터베이스는 세 가지 방법 중 하나를 사용하며 각각의 장단점이 있습니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리더와-팔로워"></a>리더와 팔로워<a class="hash-link" href="#리더와-팔로워" title="Direct link to heading">#</a></h2><ul><li>데이터베이스의 복사본을 전달하는 각 노드를 <strong>복제 서버(replica)</strong> 라고 합니다.</li><li>데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리되어야 합니다. 이를 위한 해결책은 다음과 같습니다.<ul><li><strong>리더 기반 복제(leader-based replication)</strong></li><li><strong>능동(active)/수동(passive)</strong></li><li><strong>마스터(master) 슬레이브(slave) 복제</strong></li></ul></li><li>복제 서버 중 하나를 <strong>리더(leader, 마스터나 프라이머리(primary))</strong> 로 지정합니다.</li><li>다른 복제 서버는 <strong>팔로워(follower)(읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby))</strong> 라고 합니다.</li><li>리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 <strong>복제 로그(replication log)</strong>나 <strong>변경 스트림(change stream)</strong> 의 일부로 팔로워에게 전송합니다.</li><li>이러한 복제 모드는 많은 관계형 데이터베이스, 몽고DB와 같은 비관계형 DB, 카프카 등의 분산 메시지 브로커에도 사용됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기식-대-비동기식-복제"></a>동기식 대 비동기식 복제<a class="hash-link" href="#동기식-대-비동기식-복제" title="Direct link to heading">#</a></h3><ul><li>복제 시스템의 중요한 세부 사항은 복제가 <strong>동기식</strong>으로 발생하는지 <strong>비동기식</strong>으로 발생하는지 여부합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기식"></a>동기식<a class="hash-link" href="#동기식" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/138686819-90d651f4-969c-4c3f-b305-48aa7607f50f.png"></p><ul><li>다음의 예시는 동기식입니다. 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장합니다. (다만, 이 경우는 비현실적 입니다.)</li><li>현실적으로 동기식 복제를 사용하려면 팔로워 하나는 동기식, 그 밖에는 비동기식으로 하는 경우가 많습니다. 이러한 설정을 <strong>반동기식(semi-synchronous)</strong> 라고 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="비동기식"></a>비동기식<a class="hash-link" href="#비동기식" title="Direct link to heading">#</a></h4><ul><li>보통 리더 기반 복제는 완전히 비동기식으로 구성합니다.</li><li>리더가 잘못되었을 때 복구가 어렵고 쓰기에 지속성을 보장하지 않는다는 의미입니다.</li><li>비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있습니다.</li><li>비동기식 복제는 내구성을 약화시키기 때문에 나쁜 트레이드오프로 보이나 팔로워가 많거나 분산 구조일 때는 많이 사용됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="새로운-팔로워-설정"></a>새로운 팔로워 설정<a class="hash-link" href="#새로운-팔로워-설정" title="Direct link to heading">#</a></h3><ul><li>대부분의 신규 팔로워 설정은 중단시간 없이 수행할 수 있습니다.<ul><li>(1) 가능하면 데이터를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져옵니다.</li><li>(2) 스냅숏을 새로운 팔로워 노드에 복사합니다.</li><li>(3) 스냅숏 이후 발생한 모든 데이터 변경을 요청합니다. (로그 데이터 이용)</li><li>(4) 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 이야기하며 리더에 발생하는 데이터 변화를 처리할 수 있습니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="노드-중단-처리"></a>노드 중단 처리<a class="hash-link" href="#노드-중단-처리" title="Direct link to heading">#</a></h3><p>시스템의 모든 노드는 장애나 유지보수로 인해 중단될 수 있습니다. 이는 큰 장점 중 하나이며 목표는 노드 중단의 영향을 최소화 하는 것이 목표입니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="팔로워-장애-따라잡기-복구"></a>팔로워 장애: 따라잡기 복구<a class="hash-link" href="#팔로워-장애-따라잡기-복구" title="Direct link to heading">#</a></h4><ul><li>각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관하여 이후에 쉽게 복구합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리더-장애-장애-복구"></a>리더 장애: 장애 복구<a class="hash-link" href="#리더-장애-장애-복구" title="Direct link to heading">#</a></h4><ul><li>리더의 장애를 처리하는 일은 까다롭습니다. 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야합니다. 이를 <strong>장애 복구</strong> 라고 합니다.</li><li>자동 장애 복구는 다음과 같은 단계로 진행됩니다.<ul><li>(1) 리더가 장애인지 판단</li><li>(2) 새로운 리더를 선택</li><li>(3) 새로운 리더 사용을 위해 시스템을 설정합니다.</li></ul></li><li>장애 복구 과정에서 여러 문제가 발생할 수 있습니다.<ul><li>비동기식 복제인 경우, 이전 리더의 쓰기를 일부 수신하지 못할 수가 있습니다.</li><li>쓰기를 폐기하는 방법이 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정되야 한다면 특히 위험합니다.</li><li>특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있습니다. (스플릿 브레인, split brain)</li><li>타임아웃이 짧은 경우 불필요한 장애 복구가 있을 수 있습니다.</li></ul></li><li>이러한 문제로 인해 수동 장애 복구를 하는 경우도 많습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="복제-로그-구현"></a>복제 로그 구현<a class="hash-link" href="#복제-로그-구현" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="구문-기반-복제"></a>구문 기반 복제<a class="hash-link" href="#구문-기반-복제" title="Direct link to heading">#</a></h4><ul><li>가장 간단한 사례로 리더는 모든 쓰기 요청(구문, statement)을 기록하고 쓰기를 실행합니다. 즉, SQL 구문을 파싱하고 실행하는 경우 입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-전-로그-배송"></a>쓰기 전 로그 배송<a class="hash-link" href="#쓰기-전-로그-배송" title="Direct link to heading">#</a></h4><ul><li>일반적으로 모든 쓰기는 로그에 기록합니다.<ul><li>로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분입니다. 로그 세그먼트는 작게 유지되고 백그아운드로 가비지 컬렉션을 합니다.</li><li>개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 <strong>쓰기 전 로그(WAL)</strong> 에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있습니다.</li></ul></li><li>두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하느 추가 전용(append-only) 바이트 열입니다.</li><li>PostgreSQL, Oracle 등에서 주로 사용됩니다.</li><li>큰 단점은 로그가 제일 저수준의 데이터를 기술합니다. (즉, 데이터베이스 버전이 다른 경우 실행할 수 없습니다.)<ul><li>다만, 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하게 설정하면 문제를 해결할 수도 ㅣㅇㅆ습니다.</li><li>불일치가 허용되지 않는다면 업그레이드시마다 중단 시간이 필요합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="논리적로우-기반-로그-복제"></a>논리적(로우 기반) 로그 복제<a class="hash-link" href="#논리적로우-기반-로그-복제" title="Direct link to heading">#</a></h4><ul><li>복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이며 이를 <strong>논리적 로그(logical log)</strong> 라고 부릅니다.<ul><li>삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함합니다.</li><li>삭제된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함해야합니다.</li><li>갱신된 로우의 로그는 로우를 고유하게 식별하는데 필요하는 정보와 모든 칼럼의 새로운 값을 포함합니다.</li></ul></li><li>이러한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬우며 이 기술을 <strong>변경 데이터 캡처(change data capture)</strong> 라고 부릅니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="트리거-기반-복제"></a>트리거 기반 복제<a class="hash-link" href="#트리거-기반-복제" title="Direct link to heading">#</a></h4><ul><li>지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현됩니다.</li><li>조금 더 유연성이 필요한 상황에서는 복제의 기능을 애플리케이션 층으로 옮깁니다.</li><li>오라클의 골든 게이트 같은 도구는 트리거나 스토어드 프로시저를 사용합니다.</li><li>트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 합니다. 이 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행됩니다.</li><li>일반적으로 트리거 기반 복제는 <strong>다른 복제 방식보다 많은 오버헤드</strong>가 있습니다. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생하며 그럼에도 <strong>유연성에 장점</strong>이 있어 유리합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="복제-지연-문제"></a>복제 지연 문제<a class="hash-link" href="#복제-지연-문제" title="Direct link to heading">#</a></h2><ul><li>노드 내결함성을 갖추려는 단 한가지 이유는 복제가 필요하기 때문입니다.</li><li>리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능합니다.</li><li>이러한 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있습니다.</li><li>애플리케이션이 비동기 팔로워에서 덴이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있습니다. 이때는 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 따라잡게 되고 리더와 일치하게 되며 이런 효과를 <strong>최종적 일관성</strong>이라고 합니다.</li><li>애플리케이션에서 지연이 매우 크면 불일치는 이론적인 문제가 아닌 실제 문제가 됩니다.</li></ul><p>아래는 복제 지연이 발생할 때 발생하는 세 가지 사례입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자신이-쓴-내용-읽기"></a>자신이 쓴 내용 읽기<a class="hash-link" href="#자신이-쓴-내용-읽기" title="Direct link to heading">#</a></h3><ul><li>새로운 데이터가 제출되면 리더에게 전송해야 하지만 사용자가 데이터를 볼 때는 팔로워에서 읽을 수 있습니다. 특히 데이터를 자주 읽고 적게 쓸때 유리합니다.</li><li>비동기식 복제는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않았을 수 있습니다.</li><li>이런 경우, <strong>쓰기 후 읽기 일관성</strong>이 필요합니다. 다양한 기법이 존재합니다.<ul><li>수정 내용을 읽을 때는 리더에서 읽기</li><li>일정 시간은 리더에서 모든 읽기, 복제 지연을 모니터링해 리더보다 일정시간 보다 이상 늦은 팔로워에 대해 질의를 금지합니다.</li><li>클라이언트는 가장 최근 쓰기의 타임스탬프를 기록할 수 있으므로 갱신을 반영하기 전까지 질의를 대리합니다.</li><li>복제 서버가 여러 데이터센터에 분산되어 있다면 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅돼야합니다.</li></ul></li><li>동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생합니다. 이때는 <strong>디바이스 간(cross-device)</strong> 쓰기 후 읽기 일관성이 제공돼야 합니다.<ul><li>한 디바이스가 다른 디바이스의 갱신을 모르므로 메타데이터는 중앙집중식으로 관리합니다.</li><li>복제 서버가 여러 데이터센터 간에 분산된 경우 동일 데이터센터로 라우팅된다는 보장이 없으므로 필요하다면 동일한 데이터센터로 라우팅합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단조-읽기"></a>단조 읽기<a class="hash-link" href="#단조-읽기" title="Direct link to heading">#</a></h3><p>비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 <strong>시간이 거꾸로 흐르는 현상</strong>을 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/138970169-f23428ea-c004-4607-a032-26d23229702a.png" alt="시간 역행"></p><p>단조 읽기(monotonic read)는 이런 종류의 이상 현상이 발생하지 않음을 보장합니다.</p><ul><li>단조 읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 강한 보장입니다. 즉, 데이터를 읽을 때 이전 값을 볼 수는 있으나 시간 역행은 불가능합니다.</li><li>이를 구현하는 한 방법은 읽기가 항상 동일한 복세 서버에서 수행되게 하는 것입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관된-순서로-읽기"></a>일관된 순서로 읽기<a class="hash-link" href="#일관된-순서로-읽기" title="Direct link to heading">#</a></h3><p>세번째 복제 지연 이상 현상은 인과성의 위반 우려입니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/138972166-a11975bc-8bd2-4e13-bebc-cdc92f9f2525.png" alt="인과성의 위반"></p><ul><li>이런 경우, 관찰자에게는 질문 전 대답으로 보입니다.</li></ul><p>이런 종류의 이상 현상을 방지하려면 <strong>일관된 순서로 읽기(Consistent Prefix Read)</strong> 같은 또 다른 유형의 보장이 필요합니다.</p><ul><li>일관된 순서는 읽기가 일련의 쓰기가 특정 순서로 발생한다면 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장합니다.</li><li>파티셔닝된 데이터베이스에서 발생하는 특징적인 문제 중 하나입니다.</li><li>한 가지 해결책은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법입니다. 다만 효율적이지 않는 경우가 존재합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="복제-지연을-위한-해결책"></a>복제 지연을 위한 해결책<a class="hash-link" href="#복제-지연을-위한-해결책" title="Direct link to heading">#</a></h3><ul><li>최종적 일관성시스템으로 작업할 때 복제 지연이 몇 분이나 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해 볼 가치가 있습니다.</li><li>애플리케이션이 기본 데이터베이스보다 강력한 보장을 제공하는 방법이 있습니다. (다만 이를 애플리케이션 코드에서 처리하기는 복잡해서 잘못되기 쉽습니다.)</li><li>애플리케이션 개발자가 이러한 복제 문제를 걱정하지 않고 &quot;올바른 작업 수행&quot;을 위해 항상 데이터베이스를 신뢰할 수 있다면 훨씬 좋습니다. 이가 <strong>트랜잭션</strong>이 있는 이유입니다.</li><li>오랫동안 단일 노드 트랜잭션은 존재했으나 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-리더-복제"></a>다중 리더 복제<a class="hash-link" href="#다중-리더-복제" title="Direct link to heading">#</a></h2><ul><li>앞에서는 단일 리더를 사용한 복제 아키텍처만 고려했으며 이는 일반적입니다.</li><li>그러나 가장 큰 단점은, 어떤 리더에 어떤 이유로 연결할 수 없다면 데이터베이스에 쓰기가 불가능합니다.</li><li>리더 기반 복제 모델은 쓰기를 허용하는 노드를 하나 이상 둠으로써 확장할 수 있습니다.</li><li>쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달하며 이런 방식을 <strong>다중 리더</strong> 설정(혹은 <strong>마스터 마스터, 액티브/액티브 복제</strong>)라고 합니다. 각 리더는 동시에 다른 리더의 팔로워 역할도 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-리더-복제의-사용-사례"></a>다중 리더 복제의 사용 사례<a class="hash-link" href="#다중-리더-복제의-사용-사례" title="Direct link to heading">#</a></h3><ul><li>단일 데이터센터 내에 다중 리더 설정을 사용하는 설정은 이로 인해 추가된 복잡도에 비해 이점이 크지 않기 때문에 적절하지 않습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-데이터센터-운영"></a>다중 데이터센터 운영<a class="hash-link" href="#다중-데이터센터-운영" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/139158145-28247e06-e107-4b68-8584-8aa3e7361a88.png" alt="다중 데이터센터"></p><ul><li>다중 리더 설정에서는 각 데이터센터마다 리더가 있을 수 있습니다.</li><li>각 데이터센터 내에서는 보통의 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터 센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제합니다.</li></ul><table><thead><tr><th>-</th><th>단일 리더 설정</th><th>다중 리더 설정</th></tr></thead><tbody><tr><td>성능</td><td>모든 쓰기는 리더가 있는 데이터센터로 이동해야함, 쓰기 지연 발생</td><td>모든 쓰기는 로컬 데이터센터에서 처리후 비동기 방식으로 다른 데이터센터 복제, 성능이 좋음</td></tr><tr><td>데이터센터 중단 내성</td><td>다른 데이터센터의 팔로워를 리더로 승진</td><td>각 데이터센터는 독립적이며, 온라인으로 돌아올 시 복제를 따라잡습니다</td></tr><tr><td>네트워크 문제 내성</td><td>데이터센터 내 연결의 쓰기는 동기식이므로 연결 문제에 민감</td><td>일시적인 네트워크 중단이라도 쓰기 처리가 진행됩니다.</td></tr></tbody></table><ul><li>일부 데이터 베이스는 기본적으로 다중 리더 설정을 제공합니다.</li><li>다중 리더 복제에는 분명 이점이 있으나 큰 단점으로 <strong>동일한 데이터를 다른 두 개의 데이터센터에서 동시에 변경할 수 있습니다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="오프라인-작업을-하는-클라이언트"></a>오프라인 작업을 하는 클라이언트<a class="hash-link" href="#오프라인-작업을-하는-클라이언트" title="Direct link to heading">#</a></h4><ul><li>대표적인 예시로 휴대폰의 캘린더앱이며 언제든 일정을 볼 수 있어야하고 (읽기 요청) 언제라도 새로운 일정을 생성할 수 있어합니다. (쓰기 요청) 이 후 정상이 되면 다른 디바이스와 동기화되어야합니다.</li><li>아키텍처 개념에서 이러한 설정은 데이터센터 간 다중 리더 복제와 동일합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="협업-편집"></a>협업 편집<a class="hash-link" href="#협업-편집" title="Direct link to heading">#</a></h4><ul><li>여러 사람이 문서를 편집할 수 있는 애플리케이션을 <strong>실시간 협업 편집</strong> 애플리케이션이라고 합니다. (ex. etherpad, google docs)</li><li>편집 충돌이 없음을 보장하려면 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻어야 합니다.</li><li>하지만 더 빠른 협업을 위해 여러 사용자가 동시에 편집할 수 있지만 충돌 해소가 필요한 경우를 포함해 다중 리더 복제에서 발생하는 모든 문제를 야기합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-충돌-다루기"></a>쓰기 충돌 다루기<a class="hash-link" href="#쓰기-충돌-다루기" title="Direct link to heading">#</a></h3><p><img src="https://user-images.githubusercontent.com/42582516/139159205-009beac8-90ac-440e-b5c6-7207355aaaec.png" alt="쓰기 충돌"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기-대-비동기-충돌-감지"></a>동기 대 비동기 충돌 감지<a class="hash-link" href="#동기-대-비동기-충돌-감지" title="Direct link to heading">#</a></h4><ul><li>단일 리더 데이터베이스에서 첫 번째 쓰기가 완료될 때까지 두번째 쓰기를 차단해서 기다리거나 트랜잭션을 종료해서 사용자가 쓰기를 재시도 하게 합니다.</li><li>다중 리더 설정에서 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지합니다. 이때 사용자에게 충돌을 해소하게 끔 요청하면 너무 늦을 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="충돌-회피"></a>충돌 회피<a class="hash-link" href="#충돌-회피" title="Direct link to heading">#</a></h4><ul><li>제일 간단한 전략은 충돌을 피하는 것입니다.</li><li><strong>특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않습니다.</strong> (자주 권장됩니다.)<ul><li>즉, 한 사용자의 관점에서는 단일 리더로 보이게 됩니다. (지역적인 라우팅 전략)</li></ul></li><li>때로는 한 데이터센터가 고장나서 트래픽을 다른 데이터센터로 다시 라우팅해야하거나 사용자가 다른 지역으로 이동해 현재는 다른 데이터센터가 가깝다면 레코드를 위해 지정된 리더가 변경을 원하는 상황에서는 충돌 회피가 실패합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관된-상태-수렴"></a>일관된 상태 수렴<a class="hash-link" href="#일관된-상태-수렴" title="Direct link to heading">#</a></h4><ul><li>단일 리더 데이터베이스는 순차적인 순서로 쓰기를 적용하나 다중 리더 설정에는 쓰기 순서가 정해지지 않아 최종값이 명확하지 않습니다.</li><li>따라서 데이터베이스는 <strong>수렴(convergent)</strong> 방식으로 충돌을 해소해야합니다.<ul><li>각 쓰기에 고유 ID를 주고 가장 높은 ID를 가진 쓰기를 선택합니다.</li><li>각 복제 서버에 고유 ID를 주고 우선순위를 줍니다.</li><li>어떻게든 값을 병합합니다. (Ex. B + C = B/C)</li><li>명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존하고, 사용자에게 충돌을 보여주어 해결하도록 합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="사용자-정의-충돌-해소-로직"></a>사용자 정의 충돌 해소 로직<a class="hash-link" href="#사용자-정의-충돌-해소-로직" title="Direct link to heading">#</a></h4><ul><li>충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다릅니다.<ul><li>쓰기 수행 중 : 복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출합니다.</li><li>읽기 수행 중 : 충돌을 감지하면 모든 충돌 쓰기를 저장합니다.</li></ul></li><li>충돌 해소는 보통 전체 트랜잭션이 아니라 개별 로우나 문서 수준에서 적용됩니다. 즉, 원자적으로 여러 다른 쓰기를 수행하는 트랜잭션이라면 각 쓰기는 충돌 해소를 위해 여전히 별도로 간주됩니다.</li></ul><blockquote><p>자동 충돌 해소</p></blockquote><ul><li>대표적인 예시로 아마존 장바구니 충돌 해소 로직은 얼마 동안 추가도니 상품을 보존하나 삭제한 상품은 보존하지 않습니다. (즉, 삭제해도 가끔 장바구니에서 다시 해당 상품이 보이는 경우가 있습니다.)<ul><li>충돌 없는 복제 데이터타입 : set, map, 정렬 목록</li><li>병합 가능한 영속 데이터 구조(mergeable persistent data structure)는 깃과 비슷하게 히스토리 추적후 삼중 병합 합수를 사용합니다.</li><li>운영 변환(operational transformation)은 이더패드나 구글 독스와 비슷합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="충돌은-무엇인가"></a>충돌은 무엇인가?<a class="hash-link" href="#충돌은-무엇인가" title="Direct link to heading">#</a></h4><ul><li>어떤 종류의 충돌은 감지하기 어렵습니다.<ul><li>대표적인 예시로 회의실 예약 시스템이 있습니다. (즉, 에학 허용하기전에 가능하더라도 두 예약이 다른 리더에서 이뤄지면 충돌이 가능합니다.)</li></ul></li><li>관련된 답은 없으나 가장 적합한 방식으로 진행합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-리더-복제-토폴로지"></a>다중 리더 복제 토폴로지<a class="hash-link" href="#다중-리더-복제-토폴로지" title="Direct link to heading">#</a></h3><ul><li>복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명합니다.</li><li>리더가 둘 이상이라면 다양한 토폴로지가 가능합니다. (원형, 별, 전체 연결)</li><li>가장 일반적인 토폴로지는 <strong>전체 연결(all-to-all)</strong> 입니다. (각자 쓰기를 다른 모든 리더에서 전송합니다.)</li><li>MySQL의 경우 기본적으로 <strong>원형 토폴로지(circular topology)</strong>만 제공합니다.</li><li>별 모양 토폴로지도 많이 쓰며, 트리로 일반화 할 수 있습니다.</li></ul><p>이에 따라 여러 장단점을 가집니다.</p><ul><li>원형과 별의 경우, 모든 복제 서버에 도달하기 전에 여러 노드를 거쳐야 함으로 각 노드에 고유 식별자가 있고 이미 처리한 경우에는 무시합니다. (메시지 흐름에 장애가 발생할 수 있다는 단점이 존재합니다.)</li><li>전체 연결 토폴로지의 경우, 일부 네트워크 연결이 다른 연결보다 빠르다면 일부 복제 메시지가 다른 메시지를 추월할 수 도 있습니다.</li></ul><p>이러한 문제를 해결하기 위해 <strong>버전 벡터(version vector)</strong> 라는 기법을 사용할 수 있으나 많은 다중 리더 복제 시스템에서는 제대로 구현되지 않았습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리더-없는-복제"></a>리더 없는 복제<a class="hash-link" href="#리더-없는-복제" title="Direct link to heading">#</a></h2><ul><li>일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용합니다.</li><li>이 개념은 관계형 데이터베이스가 우세한 시스템에는 대부분 잊혀졌으며 아마존이 내부 <strong>다이나모(Dynamo)</strong> 시스템에서 사용한 후 다시 데이터베이스용 아키텍처로 유행했습니다.</li></ul><blockquote><p><a href="https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html" target="_blank" rel="noopener noreferrer">Amazon DynamoDB Architecture</a></p></blockquote><ul><li>일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 코디네이터 노드(coordinator node)가 클라이언트를 대신해 이를 수행하기도 합니다.</li><li>그러나 리더 데이터베이스와 달리 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="노드가-다운됐을-때-데이터베이스에-쓰기"></a>노드가 다운됐을 때 데이터베이스에 쓰기<a class="hash-link" href="#노드가-다운됐을-때-데이터베이스에-쓰기" title="Direct link to heading">#</a></h3><ul><li>리더가 없는 설정에서는 장애 복구가 필요하지 않습니다.</li><li>죽은 노드의 경우, 데이터가 <strong>오래된(outdated)</strong> 값을 얻을 수 있습니다.</li><li>이 문제를 해결하기 위해 클라이언트가 데이터를 읽을 때 <strong>읽기 요청을 병렬로 여러 노드에 전송</strong>합니다. 그러면 클라이언트는 여러 노드에서 다른 응답을 받을 수 있고 이때는 최신과 버전 숫자를 통해 최신 값을 결정합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="읽기-복구와-안티-엔트로피"></a>읽기 복구와 안티 엔트로피<a class="hash-link" href="#읽기-복구와-안티-엔트로피" title="Direct link to heading">#</a></h4><ul><li>모든 데이터가 모든 복제 서버에 복사된 것을 보장해야합니다. 이를 위해 두가지 메커니즘을 주로 사용합니다.<ul><li>읽기 복구 : 클라이언트가 여러 노드에서 병렬로 읽기를 수행할 때 오래된 응답을 인식가능합니다. 따라서 해당 복제 서버에 새로운 값을 다시 기록합니다. (값을 자주 읽을 때 좋습니다.)</li><li>안티 엔트로피 처리 : 일부 데이터스토어는 백그라우드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락덴 데잍처를 하나의 복제 서버에서 다른 서버로 복사합니다.</li></ul></li><li>거의 읽지 않는 경우는 일부 복제본에서 누락되는 경우도 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="읽기와-쓰기를-위한-정족수"></a>읽기와 쓰기를 위한 정족수<a class="hash-link" href="#읽기와-쓰기를-위한-정족수" title="Direct link to heading">#</a></h4><ul><li>모든 성공한 쓰기가 세개의 복제 서버 중 두개의 복제 서버에 존재한다는 것을 보장한다면 하나의 서버가 오래됨을 의미합니다.</li><li>이를 일반화하면 n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정됩니다. 따라서 읽기는 최소한 r개의 노드에 질의를 해야합니다.</li><li>일반적으로 n개를 홀 수로 하고, <code>w = r = (n + 1) / 2</code> 등으로 설정합니다. 읽기가 많은 경우, <code>w = n, r = 1</code> 로 선택하는 것도 좋은 전략입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정족수-일관성의-한계"></a>정족수 일관성의 한계<a class="hash-link" href="#정족수-일관성의-한계" title="Direct link to heading">#</a></h3><blockquote><p>n : 복제 서버 수, w : 필요 성공 노드, r : 최소 질의 노드</p></blockquote><ul><li><code>w + r &gt; n</code> : 일반적으로 모든 읽기는 키의 최신 값을 반환할 것을 기대</li><li><code>r, w &gt; n/2</code> : 일반적인 경우, 다른 정족수 할당이 가능하기 때문에 분산 알고리즘 설계에서 유연합니다.</li><li><code>w + r &lt;= n</code> : 읽기와 쓰기를 계속 n개의 노드로 전송하지만 성공에 필요한 성공 응답 수가 더 적습니다.</li><li><code>w, r 이 적은 경우</code> : 오래된 값을 읽을 확률이 높습니다.</li></ul><p>위의 내용을 통해 확률을 조정할 수는 있으나 절대적으로 보장할 수 없습니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="최신성-모니터링"></a>최신성 모니터링<a class="hash-link" href="#최신성-모니터링" title="Direct link to heading">#</a></h4><ul><li>운영 관점에서는 데이터베이스가 최신 결과를 반환하는 것이 중요합니다. 따라서 이를 모니터링이 필요하지만 오래된 정보에 대한 제한이 없어서 모니터링이 어렵습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="느슨한-정족수와-암시된-핸드오프"></a>느슨한 정족수와 암시된 핸드오프<a class="hash-link" href="#느슨한-정족수와-암시된-핸드오프" title="Direct link to heading">#</a></h3><ul><li>적절히 설정된 정족수가 있느 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인합니다.</li><li>위의 설명대로는 정족수는 내결함성이 없습니다. 네트워크 중단으로 다수의 데이터베이스 노드와 클라이언트는 쉽게 연결이 끈헝질 수 있습니다.</li><li>노드가 n개 이상인 대규모 클러스터에서는 클라이언트는 네트워크 장애 상황에서 일부 데이터베이스 노드(특정 값을 위한 정족수 구성에 들어가지 않는 노드)에 연결될 가능성이 있습니다. 이 경우 데이터베이스 설계자는 트레이드 오프에 직면합니다.<ul><li>w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 게 맞을까?</li><li>혹은 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할지 <strong>(느슨한 정족수)</strong></li></ul></li><li>네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 홈 노드로 전송합니다. 이 방식을 암시도니 핸드오프라 부릅니다.</li><li>느슨한 정족수는 쓰기 가용성을 높이는 데 특히 유용합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-데이터센터-운영-1"></a>다중 데이터센터 운영<a class="hash-link" href="#다중-데이터센터-운영-1" title="Direct link to heading">#</a></h4><ul><li>리더 없는 복제도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기 때문에 다중 데이터센터 운영에 적합합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동시-쓰기-감지"></a>동시 쓰기 감지<a class="hash-link" href="#동시-쓰기-감지" title="Direct link to heading">#</a></h3><ul><li>다이나모 스타일은 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌이 발생합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/139359118-314919c2-b403-4d72-818a-a0cdda593295.png" alt="동시 쓰기"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="최종-쓰기-승리동시-쓰기-버리기"></a>최종 쓰기 승리(동시 쓰기 버리기)<a class="hash-link" href="#최종-쓰기-승리동시-쓰기-버리기" title="Direct link to heading">#</a></h4><ul><li>최종적으로 값을 수렴하기 위한 접근 방식 중 하나는 &quot;예전&quot; 값을 버리고 가장 &quot;최신&quot; 값을 덮는 방법입니다.</li><li>&quot;최신&quot;이란 먼저가 확신하지 않기 때문에 사실 상 동시라는 의미가 맞고, 타임스탬프를 통해 임의로 최신이라고 정정하는 것입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="이전-발생-관계와-동시성"></a>&quot;이전 발생&quot; 관계와 동시성<a class="hash-link" href="#이전-발생-관계와-동시성" title="Direct link to heading">#</a></h4><ul><li>두 가지 작업이 동시적에 수행했는 지 알수 있는 방법은 다음과 같습니다.</li><li>예를 들어, 작업 B가 A에 대해서 알거나 A에 의존성이 있으면 작업 A는 작업 B의 <strong>이전 발생(happens-before)</strong> 입니다.</li><li>서로 다른 작업인 경우에 단순히 <strong>동시 작업</strong>이라고 합니다.</li></ul><blockquote><p>동시성, 시각, 상대성</p></blockquote><p>동시성을 정의할 때 정확한 시간은 중요하지 않습니다. 두 작업이 발생한 시각보다 서로 알지못하면 단순히 두 작업이 동시에 수행되었다고 합니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="이전-발생-관계-파악하기"></a>이전 발생 관계 파악하기<a class="hash-link" href="#이전-발생-관계-파악하기" title="Direct link to heading">#</a></h4><ul><li>인과관계를 통해 인과성 도표를 설정합니다.</li><li>쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동시에-쓴-값-병합"></a>동시에 쓴 값 병합<a class="hash-link" href="#동시에-쓴-값-병합" title="Direct link to heading">#</a></h4><ul><li>클라이언트가 추가적으로 작업을 수행해야 합니다.</li><li>여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야합니다. (리악에서는 이러한 동시 값을 <strong>형제, sibling</strong>이라고 합니다.)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="버전-벡터"></a>버전 벡터<a class="hash-link" href="#버전-벡터" title="Direct link to heading">#</a></h4><ul><li>앞에서의 단일 버전 번호는 다중 복제본의 동시 쓰기를 받아들일 때는 충분하지 않습니다. 키당 버전 번호뿐만 아니라 <strong>복제본당 버전 번호</strong>를 사용해야 합니다.</li><li>모든 복제본의 버전 번호 모음을 <strong>버전 벡터(version vector)</strong> 라고 부릅니다.</li><li>버전 벡터 구조는 하나의 복제본을 읽은 다음 이어 다른 복제본에 다시 쓰는 작업이 안전함을 보장합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정리"></a>정리<a class="hash-link" href="#정리" title="Direct link to heading">#</a></h2><p>복제는 다양한 용도로 사용가능합니다.</p><ul><li>고가용성 : 한 장비가 다운될 때도 시스템이 계속 동작</li><li>연결이 끊긴 작업 : 네트워크 중단이 있을 때도 애플리케이션이 계속 동작할 수 있게 합니다.</li><li>지연 시간 : 지리적으로 사용자에게 가까이 데이터를 배치해 사용자가 더 빠르게 작업할 수 있게 합니다.</li><li>확장성 : 복제본에서 읽기를 수행해 단일 장비에서 다룰 수 있는 양보다 많은 양의 읽기 작업을 처리할 수 있습니다.</li></ul><p>복제에 대한 세 가지 주요 접근 방식은 아래와 같습니다.</p><ul><li>단일 리더 복제<ul><li>클라이언트는 모든 쓰기를 단일 노드(리더)로 전송하고 리더는 데이터 변경 이벤트 스트림을 다른 복제 서버로 전송합니다.</li><li>읽기는 모든 복제 서버가 수행할 수 있지만 팔로워의 읽기는 오래된 값일 수도 있습니다.</li><li>이해하기 쉽고 충돌 해소에 대한 우려가 없어서 널리 사용됩니다.</li></ul></li><li>다중 리더 복제<ul><li>클라이언트는 각 쓰기를 여러 리더 노드 중 쓰기를 받아들일 수 있는 노드로 전송합니다.</li><li>리더는 데이터 변경 이벤트 스트림을 다른 리더와 모든 팔로워 노드로 전송합니다.</li><li>결함 노드, 네트워크 중단, 지연 시간 급증이 있는 상황에서 더욱 견고합니다.</li></ul></li><li>리더 없는 복제<ul><li>클라이언트는 각 쓰기를 여러 노드로 전송합니다. 클라이언트는 오래된 데이터를 감지하고 이를 바로잡기 위해 병렬로 여러 노드에서 읽습니다.</li></ul></li></ul><p>복제는 동기와 비동기로 이뤄집니다. 복제 지연으로 인해 발생하는 여러 문제가 있고 이를 해결하기 위해 일부 일관성 모델이 있습니다.</p><ul><li>쓰기 후 읽기 일관성<ul><li>사용자는 자신이 제출한 데이터를 항상 볼 수 있어야합니다.</li></ul></li><li>단조 읽기<ul><li>사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터를 나중에 볼 수 없습니다.</li></ul></li><li>일돤된 순서로 읽기<ul><li>사용자는 인과성이 있는 상태의 데이터를 봐야합니다.</li></ul></li></ul><p>다중 리더 복제와 리더 없는 복제 접근 방식에 내재된 동시성 문제도 있습니다.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/designing-data-intensive-applications/ch5.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-10-29T02:20:48.000Z" class="lastUpdatedDate_1WI_">10/29/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/designing-data-intensive-applications/ch4"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 4. 부호화와 발전</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/designing-data-intensive-applications/ch6"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">6. 파티셔닝 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#리더와-팔로워" class="table-of-contents__link">리더와 팔로워</a><ul><li><a href="#동기식-대-비동기식-복제" class="table-of-contents__link">동기식 대 비동기식 복제</a></li><li><a href="#새로운-팔로워-설정" class="table-of-contents__link">새로운 팔로워 설정</a></li><li><a href="#노드-중단-처리" class="table-of-contents__link">노드 중단 처리</a></li><li><a href="#복제-로그-구현" class="table-of-contents__link">복제 로그 구현</a></li></ul></li><li><a href="#복제-지연-문제" class="table-of-contents__link">복제 지연 문제</a><ul><li><a href="#자신이-쓴-내용-읽기" class="table-of-contents__link">자신이 쓴 내용 읽기</a></li><li><a href="#단조-읽기" class="table-of-contents__link">단조 읽기</a></li><li><a href="#일관된-순서로-읽기" class="table-of-contents__link">일관된 순서로 읽기</a></li><li><a href="#복제-지연을-위한-해결책" class="table-of-contents__link">복제 지연을 위한 해결책</a></li></ul></li><li><a href="#다중-리더-복제" class="table-of-contents__link">다중 리더 복제</a><ul><li><a href="#다중-리더-복제의-사용-사례" class="table-of-contents__link">다중 리더 복제의 사용 사례</a></li><li><a href="#쓰기-충돌-다루기" class="table-of-contents__link">쓰기 충돌 다루기</a></li><li><a href="#다중-리더-복제-토폴로지" class="table-of-contents__link">다중 리더 복제 토폴로지</a></li></ul></li><li><a href="#리더-없는-복제" class="table-of-contents__link">리더 없는 복제</a><ul><li><a href="#노드가-다운됐을-때-데이터베이스에-쓰기" class="table-of-contents__link">노드가 다운됐을 때 데이터베이스에 쓰기</a></li><li><a href="#정족수-일관성의-한계" class="table-of-contents__link">정족수 일관성의 한계</a></li><li><a href="#느슨한-정족수와-암시된-핸드오프" class="table-of-contents__link">느슨한 정족수와 암시된 핸드오프</a></li><li><a href="#동시-쓰기-감지" class="table-of-contents__link">동시 쓰기 감지</a></li></ul></li><li><a href="#정리" class="table-of-contents__link">정리</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.a1bc5052.js"></script>
<script src="/til/assets/js/main.0f40afc0.js"></script>
</body>
</html>