<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">5. 복제 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="5. 복제 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="복제란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다."><meta data-react-helmet="true" property="og:description" content="복제란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch5" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.430e1dcc.js" as="script">
<link rel="preload" href="/til/assets/js/main.fccfc8d8.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch5">5. 복제</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">5. 복제</h1></header><div class="markdown"><p><strong>복제</strong>란, 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미입니다. 이가 필요한 이유는 다음과 같습니다.</p><ul><li>지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄입니다.</li><li>시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 ㄱ사용성을 높입니다.</li><li>읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘립니다.</li></ul><p>5장에서는 데이터셋이 작다고 가정한 경우, 6장에는 그 데이터가 단일 장비에 넣기에는 너무 커서 파티셔닝(샤딩
)에 대해 이야기 합니다.</p><p>복제에서의 어려움은 복제된 데이터의 변경 처리에 있으며 대표적으로 유명한 알고리즘은 다음과 같습니다.</p><ul><li><strong>단일 리더(single-leader)</strong> 복제</li><li><strong>다중 리더(multi-leader)</strong> 복제</li><li><strong>리더 없는(leaderless)</strong> 복제</li></ul><p>모든 분산 데이터베이스는 세 가지 방법 중 하나를 사용하며 각각의 장단점이 있습니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리더와-팔로워"></a>리더와 팔로워<a class="hash-link" href="#리더와-팔로워" title="Direct link to heading">#</a></h2><ul><li>데이터베이스의 복사본을 전달하는 각 노드를 <strong>복제 서버(replica)</strong> 라고 합니다.</li><li>데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리되어야 합니다. 이를 위한 해결책은 다음과 같습니다.<ul><li><strong>리더 기반 복제(leader-based replication)</strong></li><li><strong>능동(active)/수동(passive)</strong></li><li><strong>마스터(master) 슬레이브(slave) 복제</strong></li></ul></li><li>복제 서버 중 하나를 <strong>리더(leader, 마스터나 프라이머리(primary))</strong> 로 지정합니다.</li><li>다른 복제 서버는 <strong>팔로워(follower)(읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby))</strong> 라고 합니다.</li><li>리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 <strong>복제 로그(replication log)</strong>나 <strong>변경 스트림(change stream)</strong> 의 일부로 팔로워에게 전송합니다.</li><li>이러한 복제 모드는 많은 관계형 데이터베이스, 몽고DB와 같은 비관계형 DB, 카프카 등의 분산 메시지 브로커에도 사용됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기식-대-비동기식-복제"></a>동기식 대 비동기식 복제<a class="hash-link" href="#동기식-대-비동기식-복제" title="Direct link to heading">#</a></h3><ul><li>복제 시스템의 중요한 세부 사항은 복제가 <strong>동기식</strong>으로 발생하는지 <strong>비동기식</strong>으로 발생하는지 여부합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기식"></a>동기식<a class="hash-link" href="#동기식" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/138686819-90d651f4-969c-4c3f-b305-48aa7607f50f.png"></p><ul><li>다음의 예시는 동기식입니다. 동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장합니다. (다만, 이 경우는 비현실적 입니다.)</li><li>현실적으로 동기식 복제를 사용하려면 팔로워 하나는 동기식, 그 밖에는 비동기식으로 하는 경우가 많습니다. 이러한 설정을 <strong>반동기식(semi-synchronous)</strong> 라고 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="비동기식"></a>비동기식<a class="hash-link" href="#비동기식" title="Direct link to heading">#</a></h4><ul><li>보통 리더 기반 복제는 완전히 비동기식으로 구성합니다.</li><li>리더가 잘못되었을 때 복구가 어렵고 쓰기에 지속성을 보장하지 않는다는 의미입니다.</li><li>비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이 있습니다.</li><li>비동기식 복제는 내구성을 약화시키기 때문에 나쁜 트레이드오프로 보이나 팔로워가 많거나 분산 구조일 때는 많이 사용됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="새로운-팔로워-설정"></a>새로운 팔로워 설정<a class="hash-link" href="#새로운-팔로워-설정" title="Direct link to heading">#</a></h3><ul><li>대부분의 신규 팔로워 설정은 중단시간 없이 수행할 수 있습니다.<ul><li>(1) 가능하면 데이터를 잠그지 않고 리더의 데이터베이스 스냅숏을 일정 시점에 가져옵니다.</li><li>(2) 스냅숏을 새로운 팔로워 노드에 복사합니다.</li><li>(3) 스냅숏 이후 발생한 모든 데이터 변경을 요청합니다. (로그 데이터 이용)</li><li>(4) 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 이야기하며 리더에 발생하는 데이터 변화를 처리할 수 있습니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="노드-중단-처리"></a>노드 중단 처리<a class="hash-link" href="#노드-중단-처리" title="Direct link to heading">#</a></h3><p>시스템의 모든 노드는 장애나 유지보수로 인해 중단될 수 있습니다. 이는 큰 장점 중 하나이며 목표는 노드 중단의 영향을 최소화 하는 것이 목표입니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="팔로워-장애-따라잡기-복구"></a>팔로워 장애: 따라잡기 복구<a class="hash-link" href="#팔로워-장애-따라잡기-복구" title="Direct link to heading">#</a></h4><ul><li>각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관하여 이후에 쉽게 복구합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리더-장애-장애-복구"></a>리더 장애: 장애 복구<a class="hash-link" href="#리더-장애-장애-복구" title="Direct link to heading">#</a></h4><ul><li>리더의 장애를 처리하는 일은 까다롭습니다. 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야합니다. 이를 <strong>장애 복구</strong> 라고 합니다.</li><li>자동 장애 복구는 다음과 같은 단계로 진행됩니다.<ul><li>(1) 리더가 장애인지 판단</li><li>(2) 새로운 리더를 선택</li><li>(3) 새로운 리더 사용을 위해 시스템을 설정합니다.</li></ul></li><li>장애 복구 과정에서 여러 문제가 발생할 수 있습니다.<ul><li>비동기식 복제인 경우, 이전 리더의 쓰기를 일부 수신하지 못할 수가 있습니다.</li><li>쓰기를 폐기하는 방법이 데이터베이스 외부의 다른 저장소 시스템이 데이터베이스 내용에 맞춰 조정되야 한다면 특히 위험합니다.</li><li>특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있습니다. (스플릿 브레인, split brain)</li><li>타임아웃이 짧은 경우 불필요한 장애 복구가 있을 수 있습니다.</li></ul></li><li>이러한 문제로 인해 수동 장애 복구를 하는 경우도 많습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="복제-로그-구현"></a>복제 로그 구현<a class="hash-link" href="#복제-로그-구현" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="구문-기반-복제"></a>구문 기반 복제<a class="hash-link" href="#구문-기반-복제" title="Direct link to heading">#</a></h4><ul><li>가장 간단한 사례로 리더는 모든 쓰기 요청(구문, statement)을 기록하고 쓰기를 실행합니다. 즉, SQL 구문을 파싱하고 실행하는 경우 입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-전-로그-배송"></a>쓰기 전 로그 배송<a class="hash-link" href="#쓰기-전-로그-배송" title="Direct link to heading">#</a></h4><ul><li>일반적으로 모든 쓰기는 로그에 기록합니다.<ul><li>로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분입니다. 로그 세그먼트는 작게 유지되고 백그아운드로 가비지 컬렉션을 합니다.</li><li>개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 <strong>쓰기 전 로그(WAL)</strong> 에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있습니다.</li></ul></li><li>두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하느 추가 전용(append-only) 바이트 열입니다.</li><li>PostgreSQL, Oracle 등에서 주로 사용됩니다.</li><li>큰 단점은 로그가 제일 저수준의 데이터를 기술합니다. (즉, 데이터베이스 버전이 다른 경우 실행할 수 없습니다.)<ul><li>다만, 팔로워가 리더보다 새로운 소프트웨어 버전을 사용하게 설정하면 문제를 해결할 수도 ㅣㅇㅆ습니다.</li><li>불일치가 허용되지 않는다면 업그레이드시마다 중단 시간이 필요합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="논리적로우-기반-로그-복제"></a>논리적(로우 기반) 로그 복제<a class="hash-link" href="#논리적로우-기반-로그-복제" title="Direct link to heading">#</a></h4><ul><li>복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이며 이를 <strong>논리적 로그(logical log)</strong> 라고 부릅니다.<ul><li>삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함합니다.</li><li>삭제된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함해야합니다.</li><li>갱신된 로우의 로그는 로우를 고유하게 식별하는데 필요하는 정보와 모든 칼럼의 새로운 값을 포함합니다.</li></ul></li><li>이러한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬우며 이 기술을 <strong>변경 데이터 캡처(change data capture)</strong> 라고 부릅니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="트리거-기반-복제"></a>트리거 기반 복제<a class="hash-link" href="#트리거-기반-복제" title="Direct link to heading">#</a></h4><ul><li>지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현됩니다.</li><li>조금 더 유연성이 필요한 상황에서는 복제의 기능을 애플리케이션 층으로 옮깁니다.</li><li>오라클의 골든 게이트 같은 도구는 트리거나 스토어드 프로시저를 사용합니다.</li><li>트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 합니다. 이 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행됩니다.</li><li>일반적으로 트리거 기반 복제는 <strong>다른 복제 방식보다 많은 오버헤드</strong>가 있습니다. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생하며 그럼에도 <strong>유연성에 장점</strong>이 있어 유리합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="복제-지연-문제"></a>복제 지연 문제<a class="hash-link" href="#복제-지연-문제" title="Direct link to heading">#</a></h2><ul><li>노드 내결함성을 갖추려는 단 한가지 이유는 복제가 필요하기 때문입니다.</li><li>리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능합니다.</li><li>이러한 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있습니다.</li><li>애플리케이션이 비동기 팔로워에서 덴이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있습니다. 이때는 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 따라잡게 되고 리더와 일치하게 되며 이런 효과를 <strong>최종적 일관성</strong>이라고 합니다.</li><li>애플리케이션에서 지연이 매우 크면 불일치는 이론적인 문제가 아닌 실제 문제가 됩니다.</li></ul><p>아래는 복제 지연이 발생할 때 발생하는 세 가지 사례입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자신이-쓴-내용-읽기"></a>자신이 쓴 내용 읽기<a class="hash-link" href="#자신이-쓴-내용-읽기" title="Direct link to heading">#</a></h3><ul><li>새로운 데이터가 제출되면 리더에게 전송해야 하지만 사용자가 데이터를 볼 때는 팔로워에서 읽을 수 있습니다. 특히 데이터를 자주 읽고 적게 쓸때 유리합니다.</li><li>비동기식 복제는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않았을 수 있습니다.</li><li>이런 경우, <strong>쓰기 후 읽기 일관성</strong>이 필요합니다. 다양한 기법이 존재합니다.<ul><li>수정 내용을 읽을 때는 리더에서 읽기</li><li>일정 시간은 리더에서 모든 읽기, 복제 지연을 모니터링해 리더보다 일정시간 보다 이상 늦은 팔로워에 대해 질의를 금지합니다.</li><li>클라이언트는 가장 최근 쓰기의 타임스탬프를 기록할 수 있으므로 갱신을 반영하기 전까지 질의를 대리합니다.</li><li>복제 서버가 여러 데이터센터에 분산되어 있다면 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅돼야합니다.</li></ul></li><li>동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생합니다. 이때는 <strong>디바이스 간(cross-device)</strong> 쓰기 후 읽기 일관성이 제공돼야 합니다.<ul><li>한 디바이스가 다른 디바이스의 갱신을 모르므로 메타데이터는 중앙집중식으로 관리합니다.</li><li>복제 서버가 여러 데이터센터 간에 분산된 경우 동일 데이터센터로 라우팅된다는 보장이 없으므로 필요하다면 동일한 데이터센터로 라우팅합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단조-읽기"></a>단조 읽기<a class="hash-link" href="#단조-읽기" title="Direct link to heading">#</a></h3><p>비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 <strong>시간이 거꾸로 흐르는 현상</strong>을 볼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/138970169-f23428ea-c004-4607-a032-26d23229702a.png" alt="시간 역행"></p><p>단조 읽기(monotonic read)는 이런 종류의 이상 현상이 발생하지 않음을 보장합니다.</p><ul><li>단조 읽기는 강한 일관성보다는 덜한 보장이지만 최종적 일관성보다는 강한 보장입니다. 즉, 데이터를 읽을 때 이전 값을 볼 수는 있으나 시간 역행은 불가능합니다.</li><li>이를 구현하는 한 방법은 읽기가 항상 동일한 복세 서버에서 수행되게 하는 것입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관된-순서로-읽기"></a>일관된 순서로 읽기<a class="hash-link" href="#일관된-순서로-읽기" title="Direct link to heading">#</a></h3><p>세번째 복제 지연 이상 현상은 인과성의 위반 우려입니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/138972166-a11975bc-8bd2-4e13-bebc-cdc92f9f2525.png" alt="인과성의 위반"></p><ul><li>이런 경우, 관찰자에게는 질문 전 대답으로 보입니다.</li></ul><p>이런 종류의 이상 현상을 방지하려면 <strong>일관된 순서로 읽기(Consistent Prefix Read)</strong> 같은 또 다른 유형의 보장이 필요합니다.</p><ul><li>일관된 순서는 읽기가 일련의 쓰기가 특정 순서로 발생한다면 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장합니다.</li><li>파티셔닝된 데이터베이스에서 발생하는 특징적인 문제 중 하나입니다.</li><li>한 가지 해결책은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법입니다. 다만 효율적이지 않는 경우가 존재합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="복제-지연을-위한-해결책"></a>복제 지연을 위한 해결책<a class="hash-link" href="#복제-지연을-위한-해결책" title="Direct link to heading">#</a></h3><ul><li>최종적 일관성시스템으로 작업할 때 복제 지연이 몇 분이나 몇 시간으로 증가한다면 애플리케이션이 어떻게 동작할지 생각해 볼 가치가 있습니다.</li><li>애플리케이션이 기본 데이터베이스보다 강력한 보장을 제공하는 방법이 있습니다. (다만 이를 애플리케이션 코드에서 처리하기는 복잡해서 잘못되기 쉽습니다.)</li><li>애플리케이션 개발자가 이러한 복제 문제를 걱정하지 않고 &quot;올바른 작업 수행&quot;을 위해 항상 데이터베이스를 신뢰할 수 있다면 훨씬 좋습니다. 이가 <strong>트랜잭션</strong>이 있는 이유입니다.</li><li>오랫동안 단일 노드 트랜잭션은 존재했으나 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-리더-복제"></a>다중 리더 복제<a class="hash-link" href="#다중-리더-복제" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-리더-복제의-사용-사례"></a>다중 리더 복제의 사용 사례<a class="hash-link" href="#다중-리더-복제의-사용-사례" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-충돌-다루기"></a>쓰기 충돌 다루기<a class="hash-link" href="#쓰기-충돌-다루기" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-리더-복제-토폴로지"></a>다중 리더 복제 토폴로지<a class="hash-link" href="#다중-리더-복제-토폴로지" title="Direct link to heading">#</a></h3><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리더-없는-복제"></a>리더 없는 복제<a class="hash-link" href="#리더-없는-복제" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="노드가-다운됐을-때-데이터베이스에-쓰기"></a>노드가 다운됐을 때 데이터베이스에 쓰기<a class="hash-link" href="#노드가-다운됐을-때-데이터베이스에-쓰기" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정족수-일관성의-한계"></a>정족수 일관성의 한계<a class="hash-link" href="#정족수-일관성의-한계" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="느슨한-정족수와-암시된-핸드오프"></a>느슨한 정족수와 암시된 핸드오프<a class="hash-link" href="#느슨한-정족수와-암시된-핸드오프" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동시-쓰기-감지"></a>동시 쓰기 감지<a class="hash-link" href="#동시-쓰기-감지" title="Direct link to heading">#</a></h3></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/designing-data-intensive-applications/ch5.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-10-26T23:00:12.000Z" class="lastUpdatedDate_1WI_">10/27/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/designing-data-intensive-applications/ch4"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 4. 부호화와 발전</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/object-orientation-and-design-patterns/ch1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">객체 지향 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#리더와-팔로워" class="table-of-contents__link">리더와 팔로워</a><ul><li><a href="#동기식-대-비동기식-복제" class="table-of-contents__link">동기식 대 비동기식 복제</a></li><li><a href="#새로운-팔로워-설정" class="table-of-contents__link">새로운 팔로워 설정</a></li><li><a href="#노드-중단-처리" class="table-of-contents__link">노드 중단 처리</a></li><li><a href="#복제-로그-구현" class="table-of-contents__link">복제 로그 구현</a></li></ul></li><li><a href="#복제-지연-문제" class="table-of-contents__link">복제 지연 문제</a><ul><li><a href="#자신이-쓴-내용-읽기" class="table-of-contents__link">자신이 쓴 내용 읽기</a></li><li><a href="#단조-읽기" class="table-of-contents__link">단조 읽기</a></li><li><a href="#일관된-순서로-읽기" class="table-of-contents__link">일관된 순서로 읽기</a></li><li><a href="#복제-지연을-위한-해결책" class="table-of-contents__link">복제 지연을 위한 해결책</a></li></ul></li><li><a href="#다중-리더-복제" class="table-of-contents__link">다중 리더 복제</a><ul><li><a href="#다중-리더-복제의-사용-사례" class="table-of-contents__link">다중 리더 복제의 사용 사례</a></li><li><a href="#쓰기-충돌-다루기" class="table-of-contents__link">쓰기 충돌 다루기</a></li><li><a href="#다중-리더-복제-토폴로지" class="table-of-contents__link">다중 리더 복제 토폴로지</a></li></ul></li><li><a href="#리더-없는-복제" class="table-of-contents__link">리더 없는 복제</a><ul><li><a href="#노드가-다운됐을-때-데이터베이스에-쓰기" class="table-of-contents__link">노드가 다운됐을 때 데이터베이스에 쓰기</a></li><li><a href="#정족수-일관성의-한계" class="table-of-contents__link">정족수 일관성의 한계</a></li><li><a href="#느슨한-정족수와-암시된-핸드오프" class="table-of-contents__link">느슨한 정족수와 암시된 핸드오프</a></li><li><a href="#동시-쓰기-감지" class="table-of-contents__link">동시 쓰기 감지</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.430e1dcc.js"></script>
<script src="/til/assets/js/main.fccfc8d8.js"></script>
</body>
</html>