<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">7. 트랜잭션 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch7"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="7. 트랜잭션 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다."><meta data-react-helmet="true" property="og:description" content="현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch7"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch7" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/designing-data-intensive-applications/ch7" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.db340f1f.js" as="script">
<link rel="preload" href="/til/assets/js/main.589e35fc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">7. 트랜잭션</h1></header><div class="markdown"><p>현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다.</p><ul><li>데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있습니다.</li><li>애플리케이션은 언제라도 죽을 수 있습니다.</li><li>네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있습니다.</li><li>여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있습니다.</li><li>클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있습니다.</li><li>클라이언트 사이의 경쟁 조건을 예측하지 못한 버그를 유발할 수 있습니다.</li></ul><p>시스템이 <strong>신뢰성</strong>을 지니려면 이러한 결함을 처리해서 전체 시스템의 치명적인 장애로 이어지는 것을 막아야 합니다.</p><ul><li>트랜잭션은 이런 문제를 <strong>단순화</strong>하는 메커니즘으로 채택되었습니다.</li><li>트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법입니다.<ul><li>개념적으로 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행됩니다.</li><li>트랜잭션은 전체가 <strong>성공(커밋)</strong> 하거나 <strong>실패(abort, 롤백)</strong> 합니다</li><li>트랜잭션을 사용하면 안전하게 재시도할 수 있기 때문에 오류 처리를 하기 훨씬 단순해집니다.</li></ul></li><li>트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만들어졌습니다.<ul><li>트랜잭션을 통해 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있습니다. <strong>(안전성 보장, safety guarantee)</strong></li></ul></li><li>모든 애플리케이션에서 트랜잭션이 필요하지 않으며 때로는 트랜잭션적인 보장을 완화하건아 아예 쓰지않는 것이 이득입니다.</li></ul><p>데이터베이스에서 문제가 생길 수 있는 여러 예를 조사하고 이를 사용하는 알고리즘을 살펴봅니다. 동시성 제어 분야를 깊게 다루며 발생할 수 있는 다양한 종류의 경쟁조건과 데이터베이스에서 <strong>커밋 후 읽기(read committed), 스냅숏 격리(snapshot isolation), 직렬성(serializability)</strong> 같은 격리 수준을 어떻게 같은 격리 수준을 구현하는지에 대해 설명합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="애매모호한-트랜잭션의-개념"></a>애매모호한 트랜잭션의 개념<a class="hash-link" href="#애매모호한-트랜잭션의-개념" title="Direct link to heading">#</a></h2><p>현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원합니다.</p><ul><li>비관계형(NoSQL) 데이터베이스가 주류로 바뀌며 트랜잭션을 약한 보장을 의미하는 단어로 트랜잭션 의미가 재정의 되었습니다.</li><li>트랜잭션은 이점과 한계가 있습니다. 이에 따라 잘 조절해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="acid의-의미"></a>ACID의 의미<a class="hash-link" href="#acid의-의미" title="Direct link to heading">#</a></h3><p>트랜잭션이 제공하는 안전성 보장은 크게 아래로 나눠집니다.</p><ul><li>원자성(<strong>A</strong>tomicity)</li><li>일관성(<strong>C</strong>onsistency)</li><li>격리성(<strong>I</strong>solation)</li><li>지속성(<strong>D</strong>urability)</li></ul><p>그러나 현실에서는 데이터베이스마다 ACID 구현이 제각각이며 <strong>격리성</strong>은 의미 주변에 모호함이 많습니다. (ACID 표준을 따르지 않는 시스템은 때로 <strong>BASE</strong>라 불립니다. 가용성을 제공하고(Basically Available), 유연한 상태를 가지며(Soft state), 최종적 일관성(Eventual consistency) 의 의미를 가집니다.)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="원자성"></a>원자성<a class="hash-link" href="#원자성" title="Direct link to heading">#</a></h4><ul><li>일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 무엇을 가르킵니다.</li><li>ACID의 원자성은 클라이언트가 쓰기 작업을 몇 개 실행할 때, <strong>여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋)될 수 없으면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실횅한 쓰기를 무시하거나 취소</strong>해야합니다.</li><li>오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력은 ACID의 원자성의 결정적인 특징입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관성"></a>일관성<a class="hash-link" href="#일관성" title="Direct link to heading">#</a></h4><ul><li>일관성은 괴장히 여러 의미로 쓰입니다. (복제 일관성, 최종적 일관성, 일관성 해싱, CAP의 일관성 등등)</li><li>ACID의 일관성은 데이터 베이스가 <strong>좋은 상태(항상 진실이어야하는 데이터에 관한 어떤 선언, 불변식(invariant)가 있다는 것)</strong> 에 있어야 한다는 애플리케이션에 특화된 개념입니다.</li><li>일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임입니다.</li><li>원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="격리성"></a>격리성<a class="hash-link" href="#격리성" title="Direct link to heading">#</a></h4><ul><li>대부분 동시에 여러 클라이언트에서 데이터베이스에 접근하고, 클라이언트 들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 됩니다.</li><li>ACID의 격리성은 동시에 실행되는 트랜잭션은 서로 격리되는 것을 의미합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="지속성"></a>지속성<a class="hash-link" href="#지속성" title="Direct link to heading">#</a></h4><ul><li>데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것입니다.</li><li>지속성(durability)는 트랜잭션이 <strong>성공적으로 커밋</strong>되었다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 <strong>트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장</strong>입니다.</li></ul><blockquote><p>복제와 지속성</p></blockquote><ul><li>고가ㅓ에는 지속성이 아카이브 테이프에 기록되는 것을 의미하였고, 그 이후는 디스크나 SSD에 기록하는 것, 현재는 복제를 의미합니다.</li><li>이중에서 왑녁한 것은 없으며, 여러 위험을 줄이는 기법일 뿐이며 같이 쓸 수 있으면 그렇게 해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단일-객체-연산과-다중-객체-연산"></a>단일 객체 연산과 다중 객체 연산<a class="hash-link" href="#단일-객체-연산과-다중-객체-연산" title="Direct link to heading">#</a></h3><p>요약하면 ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술합니다.</p><ul><li>원자성 : 데이터베이스는 전부 반영되거나 아무것도 반영되지 않음을 보장합니다.</li><li>격리성 : 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 합니다.</li></ul><p><strong>다중 객체 트랜잭션</strong>은 흔히 데이터의 여러 조각이 동기화된 상태로 유지되어야 할 때 필요합니다.</p><ul><li>다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 합니다.</li><li>비관계형 데이터베이스는 이런식으로 연산을 묶는 경우가 없어서, 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 의미하지는 않습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단일-객체-쓰기"></a>단일 객체 쓰기<a class="hash-link" href="#단일-객체-쓰기" title="Direct link to heading">#</a></h4><ul><li>원자성과 격리성은 단일 객체를 변경하는 경우에도 적용됩니다.</li><li>단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)를 방지하므로 유용합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-객체-트랜잭션의-필요성"></a>다중 객체 트랜잭션의 필요성<a class="hash-link" href="#다중-객체-트랜잭션의-필요성" title="Direct link to heading">#</a></h4><ul><li>많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했습니다.<ul><li>다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기도 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오가 있습니다.</li></ul></li><li>단일 객체, 갱신, 삭제만으로도 충분한 사용 사례가 있습니다. (굳이 다중 객체 트랜잭션이 필요 없는 경우)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="오류와-어보트-처리"></a>오류와 어보트 처리<a class="hash-link" href="#오류와-어보트-처리" title="Direct link to heading">#</a></h4><ul><li>트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있습니다.</li><li>다만 모든 시스템이 이러한 철학을 따르지 않으며, 리더 없는 복제를 사용하는 데이터 스토어는 &quot;최선을 다하는(best effort)&quot; 원칙을 기반으로 더 많은 일을 합니다.<ul><li>이 경우, 오류 복구는 애플리케이션에게 책임이 있습니다.</li></ul></li><li>어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지않습니다.<ul><li>트랜잭션이 실제로 성공했으나 네트워크 이슈가 발생한 경우</li><li>오류가 과부하 때문에 발생한 경우</li><li>일시적인 오류만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 소용이 없습니다.</li><li>트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수 효과가 실행될 수 있습니다.</li><li>클라이언트 프로세스가 재시도 중에 죽어버리면 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실이 됩니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="완화된-격리-수준"></a>완화된 격리 수준<a class="hash-link" href="#완화된-격리-수준" title="Direct link to heading">#</a></h2><ul><li>두 트랜잭션이 동일한 데이터에 접근하지 않으면 안전하게 병렬 실행할 수 있습니다.</li><li>동시성 버그는 타이밍에 운이 안좋을때만 발생하기 때문에 테스트로 발견하기 어렵습니다.</li><li>이러한 이유로 데이터베이스는 오랫동안 데이터 격리를 제공했습니다.<ul><li>다만 비용이 매우 큰 문제가 있습니다</li></ul></li><li>많은 데이터베이스는 완화된 트랜잭션 격리를 제공합니다.<ul><li>이는 미묘한 버그를 만드는 문제가 있습니다.</li></ul></li><li>일반적으로 도구를 의존하기 보다 동시성 문제를 잘 이해하고 방지하는 방법을 배울 필요가 있습니다.</li></ul><blockquote><p>Q. 우리 회사에서는 뭐쓰지</p></blockquote><blockquote><p>Q. 옛날에 관련해서 본 4단계 계층 구조가 있는데 확인해보기</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커밋-후-읽기"></a>커밋 후 읽기<a class="hash-link" href="#커밋-후-읽기" title="Direct link to heading">#</a></h3><p>가장 기본적인 수준의 트랜잭션은 <strong>커밋 후 읽기(read committed)</strong> 입니다. 이 수준에서는 두 개를 보장해줍니다.</p><ul><li>데이터베이스에서 읽을 때, 커밋된 데이터만 읽게 됩니다. (더티 읽기가 없음)</li><li>데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 됩니다. (더티 쓰기가 없음)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="더티-읽기-방지"></a>더티 읽기 방지<a class="hash-link" href="#더티-읽기-방지" title="Direct link to heading">#</a></h4><ul><li><strong>더티 읽기(dirty read)</strong> : 트랜재션이 데이터베이스에 데이터를 썼지만 아직 커밋되지 않았거나 어보트 되지 않은 데이터</li><li>이를 막으면 다음의 장점을 가집니다<ul><li>부분적 갱신 데이터는 사용자에게 혼란스러움을 제공할 수 있습니다.</li><li>트랜잭션이 어보트시 롤백을 해야하는데 혼란을 줄 수 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="더티-쓰기-방지"></a>더티 쓰기 방지<a class="hash-link" href="#더티-쓰기-방지" title="Direct link to heading">#</a></h4><ul><li><strong>더티 쓰기(dirty write)</strong> : 먼저 쓴 내용이 아직 커밋에서 쓴 것이고, 나중에 실행된 쓰기 작업이 커밋되지않은 값을 덮어 쓴 경우</li><li>이를 막으면 다음의 장점을 가집니다<ul><li>트렌잭션이 여러 객체를 갱신하면 나쁜 결과를 유발하는 문제가 있습니다.</li><li>경쟁 조건을 막을 수 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커밋-후-읽기-구현"></a>커밋 후 읽기 구현<a class="hash-link" href="#커밋-후-읽기-구현" title="Direct link to heading">#</a></h4><ul><li>현재 자주 쓰이는 격리 수준</li><li>오라클 11g, PostgreSQL, SQL Server 2012 등에서 기본 설정입니다</li><li>흔한 방법으로 데이터베이스는 로우에 대한 락을 가짐으로 더티 쓰기를 방지합니다.</li><li>읽기 쓰기 잠금은 현실에서 잘 동작하지 않습니다.<ul><li>따라서 과거와 새로운 값을 모두 기억하고 커밋 전까지는 다른 트랜잭션들이 과거의 값을 가집니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스냅숏-격리와-반복-읽기"></a>스냅숏 격리와 반복 읽기<a class="hash-link" href="#스냅숏-격리와-반복-읽기" title="Direct link to heading">#</a></h3><ul><li>커밋 후 읽기 격리를 피상적으로 보면 트랜잭션이 해야하는 모든 일을 해주는 것으로 생각하는 것도 무리가 아닙니다</li><li>위의 격리 수준을 사용해도 깨지는 경우가 존재합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/140755927-fb83ddc7-a6dd-4491-b050-5be8ea7626d5.png" alt="읽기 쓰큐, 깨진 데이터를 본 경우"></p><ul><li>위의 이상 현상을 <strong>비반복 읽기(nonrepeatedable read)</strong> 나 <strong>읽기 스큐(read skew)</strong> 라고 합니다.</li><li>이러한 일시적인 문제를 감내할 수 없는 경우가 있습니다.<ul><li>백업 : 데이터베이스 전체의 복사본을 만들어야하는 경우에 비 일관성이 발생하면 이를 영속적으로 저장하게 굅니다.</li><li>분석 질의와 무결성 확인 : 데이터베이스의 큰 부분을 질의하는 경우</li></ul></li><li><strong>스냅숏 격리</strong>는 이런 문제의 흔한 해결책입니다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽습니다.</li><li><strong>스냅숏 격리</strong>는 백업이나 분석처럼 실행하는게 오래 걸리며 읽기만 실행하는 질의에 요긴합니다.</li><li>스냅숏 격리는 PostgreSQL, InnoDB 저장소 엔진, 마이SQL, 오라클, SQL Server 등에서 지원됩니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스냅숏-격리-구현"></a>스냅숏 격리 구현<a class="hash-link" href="#스냅숏-격리-구현" title="Direct link to heading">#</a></h4><ul><li>스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용합니다.</li><li>성능 관점에서 스냅숏 격리의 핵심 원리는 <strong>읽는 쪽에서 쓰는 쪽을 절대 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것</strong>입니다.</li><li>진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야하기 때문에 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 합니다. 이 기법을 다중 버전 동시성 제어(multi-version concurrency control, MVCC)라고 합니다.</li><li>데이터베이스가 스냅숏 격리가 아니라 커밋 후 읽기 격리만 제공할 필요가 있다면 객체마다 버전 두개씩 쥬히면 충분합니다.</li></ul><p>[이미지]</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관된-스냅숏을-보는-가시성-규칙"></a>일관된 스냅숏을 보는 가시성 규칙<a class="hash-link" href="#일관된-스냅숏을-보는-가시성-규칙" title="Direct link to heading">#</a></h4><ul><li>트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정합니다.</li><li>두 조건이 참이면 객체를 볼 수 있습니다.<ul><li>읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다</li><li>읽기 대상 객체가 삭제된 것으로 표시되지 않았다 또는 삭제된 것으로 표시되었지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.</li></ul></li><li>데이터 베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅숏을 제공할 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="색인과-스냅숏-격리"></a>색인과 스냅숏 격리<a class="hash-link" href="#색인과-스냅숏-격리" title="Direct link to heading">#</a></h4><p>다중 버전 데이터베이스에서 색인은 아래처럼 동작합니다.</p><ul><li>간단한 방법으로 단순하게 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것</li><li>현실에서는 여러 구현 세부 사항에 따라 성능이 결정되므로 PostgreSQL은 동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 합니다.</li><li>CouchDB, LMDB 에서는 B 트리 변종(<strong>쓸때 복사되는, append-only/copy-on-write</strong>)을 사용합니다.</li><li>추가 전용 B 트리도 컴팩션과 가비지 컬렉션을 실행하는 백그라운드 프로세스가 필요합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="반복-읽기와-혼란스러운-이름"></a>반복 읽기와 혼란스러운 이름<a class="hash-link" href="#반복-읽기와-혼란스러운-이름" title="Direct link to heading">#</a></h4><ul><li>스냅숏 격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에 유용합니다.<ul><li>오라클에서는 <strong>직렬성</strong>, PostgreSQL과 MySQL에서는 <strong>반복 읽기(repeatable read)</strong> 라고 합니다.</li><li>이름이 혼란스러운 이유는 SQL 표준에 스냅숏 격리 개념이 없어서 그렇습니다.</li></ul></li><li>SQL 표준의 격리 수준 정의에는 결함이 있습니다. 모호하고 부정확하며 표준이 그래야하는 것만큼 구현이 독립적이지 않습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="갱신-손실-방지"></a>갱신 손실 방지<a class="hash-link" href="#갱신-손실-방지" title="Direct link to heading">#</a></h3><ul><li><strong>갱신 손실(lost update) 문제</strong>는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때, 발생할 수 있습니다.</li><li>두 트랜잭션이 이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있습니다. (나중에 쓴게 먼저 쓴거를 덮어씁니다.)</li><li>아래의 경우에서 발생할 수 있습니다.<ul><li>카운터를 증가시키거나 계좌 잔고를 갱신하는 경우</li><li>복잡한 값을 지역적으로 변경합니다.</li><li>위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="원자적-쓰기-연산"></a>원자적 쓰기 연산<a class="hash-link" href="#원자적-쓰기-연산" title="Direct link to heading">#</a></h4><ul><li>여러 데이터베이스에서 원자적 갱신 연산을 제공합니다.</li><li>원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해서 구현합니다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 합니다. <strong>(커서 안전성, cursor stability)</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="명시적인-잠금"></a>명시적인 잠금<a class="hash-link" href="#명시적인-잠금" title="Direct link to heading">#</a></h4><ul><li>데이터베이스에서 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 방법은 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것입니다.</li><li>올바르게 동작하려면 애플리케이션 로직에 대해 신중하게 생각해야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TRANSACTION</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> figures</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> name </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;robot&#x27;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> game_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">222</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">FOR</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- 이동이 유효한지 확인후, 반환된 것의 위치 갱신</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token plain"> figures </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> position </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;c4&#x27;</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">COMMIT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="갱신-손실-자동-감지"></a>갱신 손실 자동 감지<a class="hash-link" href="#갱신-손실-자동-감지" title="Direct link to heading">#</a></h4><ul><li>원자적 연산과 잠금은 <code>read-modify-write</code> 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법입니다.</li><li>이 방법의 <strong>이점</strong>은 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행활 수 있다는 것입니다.</li><li>갱신 손실 감지는 애플리케이션 코드에서 어떤 특별한 데이터베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="compare-and-set"></a>Compare-and-set<a class="hash-link" href="#compare-and-set" title="Direct link to heading">#</a></h4><ul><li>연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것입니다.</li><li>현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도 해야합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- 데이터베이스 구현에 따라 안전할 수도 안전하지 않을 수도 있습니다.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token plain"> wiki_pages </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> content </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;new content&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> content </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;old content&#x27;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="충돌-해소와-복제"></a>충돌 해소와 복제<a class="hash-link" href="#충돌-해소와-복제" title="Direct link to heading">#</a></h4><ul><li>잠금과 <code>compare-and-set</code> 연산은 데이터의 최신 복사본이 하나만 있다고 가정합니다. 그러나 다중 리더나 리더 없는 복제는 데이터의 최신 복사본이 하나만 있다고 보장할 수 없습니다.</li><li>복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 <strong>충돌된 버전(형제, sibling)</strong> 을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것입니다.</li><li>원자적 연산은 복제 상황에서도 잘 동작합니다.</li><li><strong>최종 쓰기 승리(last write wins, LWW)</strong> 충돌 해소 방법은 갱신 손실이 발생하기 쉽습니다. 많은 복제 데이터베이스는 LWW가 기본 설정입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스큐와-팬텀"></a>쓰기 스큐와 팬텀<a class="hash-link" href="#쓰기-스큐와-팬텀" title="Direct link to heading">#</a></h3><ul><li>앞에서는 다른 트랜잭션들이 동시에 같은 객체에 쓰려고 할 때 발생할 수 있는 두 가지 경쟁 조건인 <strong>더티 쓰기</strong>와 <strong>갱신 손실</strong>을 보았습니다.</li><li>예를 위하 두 사람이 호출 대기를 하는데 동시에 호출 대기를 끄는 경우, 둘다 빠지는 문제가 발생합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스큐를-특징짓기"></a>쓰기 스큐를 특징짓기<a class="hash-link" href="#쓰기-스큐를-특징짓기" title="Direct link to heading">#</a></h4><ul><li>위의 이상 현상을 <strong>쓰기 스큐(write skew)</strong> 라고 합니다.</li><li>두 트랜잭션이 두 개의 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아닙니다.</li><li>쓰기 스큐를 갱신 손실 문제가 일반화된 것으로 생각할 수도 있고 쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 나타낼 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- 이를 잠구는 방법은 다음과 같습니다.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TRANSACTION</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> doctors</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> on_call </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">true</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> shift_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FOR</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token plain"> doctors</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> on_call </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">false</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> name </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;Alice&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> shift_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">COMMIT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="추가적인-쓰기-스큐의-예"></a>추가적인 쓰기 스큐의 예<a class="hash-link" href="#추가적인-쓰기-스큐의-예" title="Direct link to heading">#</a></h4><ul><li>회의실 예약 시스템</li><li>다중플레이어 게임</li><li>사용자명 획득</li><li>이중 사용(double-spending) 방지</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스큐를-유발하는-팬텀"></a>쓰기 스큐를 유발하는 팬텀<a class="hash-link" href="#쓰기-스큐를-유발하는-팬텀" title="Direct link to heading">#</a></h4><ul><li>아래의 비슷한 패턴을 따릅니다.<ul><li>SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인합니다.</li><li>첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정합니다.</li><li>애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋합니다.</li></ul></li><li>어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 <strong>팬텀(phantom)</strong> 이라고 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="충돌-구체화"></a>충돌 구체화<a class="hash-link" href="#충돌-구체화" title="Direct link to heading">#</a></h4><ul><li>팬텀의 문제가 잠글 수 있는 객체가 없다는 것이라면 인위적으로 데이터베이스에 잠금 객체를 추가합니다.</li><li>위의 예시에서 예약하는 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 로우를 잠금한 후 그후에 예약이 있는지 확인하고 새 예약을 삽입합니다.</li><li>이러한 방법을 <strong>충돌 구체화(materializing conflict)</strong> 라고 합니다. 팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하기 때문입니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬성"></a>직렬성<a class="hash-link" href="#직렬성" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="실제적인-직렬-실행"></a>실제적인 직렬 실행<a class="hash-link" href="#실제적인-직렬-실행" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2단계-잠금2pl"></a>2단계 잠금(2PL)<a class="hash-link" href="#2단계-잠금2pl" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬성-스냅숏-격리ssi"></a>직렬성 스냅숏 격리(SSI)<a class="hash-link" href="#직렬성-스냅숏-격리ssi" title="Direct link to heading">#</a></h3><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정리"></a>정리<a class="hash-link" href="#정리" title="Direct link to heading">#</a></h2></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/designing-data-intensive-applications/ch7.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-11-09T14:57:09.000Z" class="lastUpdatedDate_1WI_">11/9/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/designing-data-intensive-applications/ch6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 6. 파티셔닝</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/object-orientation-and-design-patterns/ch1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">객체 지향 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#애매모호한-트랜잭션의-개념" class="table-of-contents__link">애매모호한 트랜잭션의 개념</a><ul><li><a href="#acid의-의미" class="table-of-contents__link">ACID의 의미</a></li><li><a href="#단일-객체-연산과-다중-객체-연산" class="table-of-contents__link">단일 객체 연산과 다중 객체 연산</a></li></ul></li><li><a href="#완화된-격리-수준" class="table-of-contents__link">완화된 격리 수준</a><ul><li><a href="#커밋-후-읽기" class="table-of-contents__link">커밋 후 읽기</a></li><li><a href="#스냅숏-격리와-반복-읽기" class="table-of-contents__link">스냅숏 격리와 반복 읽기</a></li><li><a href="#갱신-손실-방지" class="table-of-contents__link">갱신 손실 방지</a></li><li><a href="#쓰기-스큐와-팬텀" class="table-of-contents__link">쓰기 스큐와 팬텀</a></li></ul></li><li><a href="#직렬성" class="table-of-contents__link">직렬성</a><ul><li><a href="#실제적인-직렬-실행" class="table-of-contents__link">실제적인 직렬 실행</a></li><li><a href="#2단계-잠금2pl" class="table-of-contents__link">2단계 잠금(2PL)</a></li><li><a href="#직렬성-스냅숏-격리ssi" class="table-of-contents__link">직렬성 스냅숏 격리(SSI)</a></li></ul></li><li><a href="#정리" class="table-of-contents__link">정리</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.db340f1f.js"></script>
<script src="/til/assets/js/main.589e35fc.js"></script>
</body>
</html>