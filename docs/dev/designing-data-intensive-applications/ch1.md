---
sidebar_position: 1
---

# 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 오늘날 많은 애플리케이션은 **계산 중심(compute-intensive)** 와 다르게 **데이터 중심(data-intensive)** 적입니다.
- 이러한 애플리케이션은 CPU 성능보다는 데이터 양, 데이터 복잡도, 데이터의 변화속도에 더 민감합니다.
- 많은 애플리케이션은 다음을 필요로 합니다.
  - 데이터베이스, 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장
  - 캐시, 읽기 속도 향상을 위해 갑비싼 수행 결과를 기억
  - 검색색인, 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공
  - 스트림 처리, 비동기 처리를 위해 다른 프로세스로 메시지 보내기
  - 일괄 처리, 주기적으로 대량의 누적된 데이터를 분석
- 아래의 책에서는 데이터 시스템의 원칙(principle)과 실용성(practicality), 애플리케이션 개발 방법에 대해 소개합니다.

## 데이터 시스템에 대한 생각

데이터벤이스, 큐, 캐시 등을 **데이터 시스템**이라는 포괄적 단어로 묶는 이유는 다음과 같습니다.

- 최근들에 경계가 더 모호해 지고 있습니다.
  - 메시지 큐이자 데이터스토어인 레디스
  - 지속성을 보장하는 메시지큐인 카프카도 존재
- 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항이 있습니다.
  - 작업은 단일 도구에서 효율적으로 **수행할 수 있는** 테스트로 나누고 다양한 도구들은 애플리케이션 코드를 이용해 서로 연결합니다.

![데이터 시스템 아키텍처 예시](https://user-images.githubusercontent.com/42582516/134787508-06cb0ad3-2b00-4b0f-bd99-1e675836d865.png)

데이터 시스템이나 서비스를 설계할 때 여러 문제가 발생하며 좋은 설게를 하기 위해서는 아래의 관심사에 중점을 줍니다.

- 신뢰성(Reliability)
  - 하드웨어 소프트웨어 결함, 인적 오류에 직면해도 올바르게 동작해야합니다.
- 확장성(Scalability)
  - 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 적절한 방법이 있어야합니다.
- 유지보수성(Maintainability)
  - 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야합니다.

<br/>

## 신뢰성

소프트웨어에 바라는 기대는 다음과 같습니다.

- 애플리케이션은 사용자가 기대한 기능을 수행한다,.
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨엉 사용법을 허용할 수 있습니다.
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족합니다.
- 시스템은 허가되지 않은 접근과 오남용을 방지합니다.

> 결함(fault) : 잘못될 수 있는 일, 0%확률은 어려움

> 장애 : 사용자에게 필요한 서비스를 제공하지 못하고 서비스 전체가 멈춘 경우

> 내결함성(fault-tolerant), 탄력성(resilient) : 결함을 예측하고 대처할 수 있는 시스템

대표적인 예시로 넷플릭스의 카오스 몽키가 있습니다.

### 하드웨어 결함

- 하드웨어 장애는 늘상 발생할 수 있는 문제입니다. (정전, 실수 등등)
- 이러한 시스템 장애율을 줄이기 위해서는 **하드웨어 구성 요소에 중복을 추가하는 방법이 일반적입니다.**

### 소프트웨어 오류

- 시스템 내 **체계적 오류(systematic error)** 가 발생할 수 있습니다.
- 소프트웨어 체계적 오류 문제는 신속한 해결책이 없습니다. (아래의 해결책은 도움이 되는 방법입니다.)
  - 시스템의 가정
  - 상호작용에 대한 주의 깊은 생각
  - 빈틈 없는 테스트
  - 프로세스 격리
  - 죽은 프로세스의 재시작 허용
  - 프로덕션 환경에서의 동작 측정, 모니터링, 분석하기

### 인적 오류

사람은 소프트웨어 시스템을 설계하고 구축합니다. 다음은 신뢰성이 있게 만드는 접근 방식입니다.

- 오류의 가능성을 최소화하는 방법으로 시스템을 설계합니다.
- 사람이 많이 실수하는 부분에서 실수로 장애가 발생하는 부분을 분리합니다. (즉, 샌드박스(sandbox)를 제공합니다.)
- 단위 테스트부터 통합 테스트, 수동 테스트까지 모든 수준에서 철저히 테스트합니다.
- 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있도록 합니다.
- 성능 지표와 오류율같은 상세하고 명확한 모니터링 대책을 마련합니다.
- 조직 교육과 실습을 시행합니다.

### 신뢰성의 중요성

- 중요하지 않은 애플리케이션도 사용자에 대한 책임(responsibility)가 있습니다.

<br/>

## 확장성

**확장성**은 증가한 부하에 대처하는 시스템 능력을 설명하는데 사용하는 용어입니다.

### 부하 기술하기

- 시스템의 현재 부하를 간결하게 기술해야지, 성장에 관련된 질문을 할 수 있습니다.
- 부하는 부하 매개변수(load parameter) 라 부르는 몇 개의 숫자로 나타낼 수 있습니다.

ex) 트위터

- 트윗 작성 : 사용자는 팔로워에게 새로운 메시지 게시 가능, 초당 4.6k + 피크시 12k 요청 이상
- 홈 타임라인 : 사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있음, 초당 300k
- 트위터의 확장성 문제는 팬 아웃에 관련되어 있습니다.
- **팬 아웃(fan-out)** : 하나의 수신 요청 수를 설명하기 위해 팬 아웃을 사용합니다.

```sql
# 방법 1.
--사용자가 홈 타임 라인을 요청하면 팔로우하는 모든 사람들 찾고, 시간순으로 정렬해서 합칩니다.
SELECT tweets.*, users.* FROM tweets
  JOIN users ON tweets.sender_id = users.id
  JOIN follows ON follows.followee_id = users.id
  WHERE follows.follower_id = current_user
```

```sql
# 방법 2.
--사용자가 사용자에게 보낼 캐시를 만들어서, 데이터를 넣을 시 미리 계산해서 수신자용 캐시에 넣습니다.
```

방법 1과 방법 2의 단점이 있어서 현재는 두 개를 혼합형으로 바꾸고 있습니다. (방법 1은 대용량 처리에서 불리하고 방법 2는 팔로워가 많은 경우에게 요청이 복잡해집니다.)

### 성능 기술하기

다음 두가지 방법으로 살펴볼 수 있습니다.

- 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 자원을 늘려야할까

두 질문 모두 성능 수치가 필요합니다.

- **처리량(throughput)** : 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합, 하둡에서 필요로 함
- **응답 시간(response time)** : 클라이언트가 요청을 보내고 응답을 받는 사이의 시간, 온라인 서비스에서 중요, 클라이언트 측면이며 `실제 시간 + 네트워크 지연 + 큐 지연` 입니다.
- **지연 시간(latency)** : 요청이 처리되길 기다리는 시간

클라이언트는 몇 번이고 반복해서 동일 요청을 하더라도 매번 응답시간이 다릅니다. 따라서 응답 시간은 단일 숫자가 아닌 측정 가능한 값의 **분포**로 생각해야합니다.

- 대부분 요청은 빠르지만 가끔 오래 걸리는 **특이 값(outlier)** 가 있습니다.
- 보고된 서비스 **평균** 응답 시간을 살피는 것은 일반적이며 평균은 **산술 평균**입니다.
- 일반적으로 평균보다는 백분위(percentile)을 사용하는 편이 좋습니다.
- **중앙 값**을 통해서 사용자가 보통 얼마나 기다리는 지 아는데 좋습니다.
- 특이 값이 얼마나 안좋은지 보는 것은 상위 백분위를 살펴보는 것이 좋습니다. (95분위, 99분위, 99.9분위)
- **꼬리 지연 시간(tail latency)**, 상위 백분위 응답 시간 : 서비스의 사용자 경험에 직접 영향을 줍니다
- 다만 99.99분위 등의 최적화는 작업 비용이 비싸기 때문에 포기하는 경우가 많습니다.
- 백분위는 **서비스 수준 목표(service level objective, SLO)** 와 **서비스 수준 협약서(service level agreement, SLA)** 에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에 자주 등장합니다.
- 큐 대기 지연(queueing delay)는 높은 백분위에서 응답 시간의 상당 부분을 차지합니다. (서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소스의 느린 요청을 처리가 후속 요청 처리가 지체됩니다.) 이를 **선두 차단(head-of-line blocking)** 이라 합니다.

> 실전 백분위

- **꼬리 지연 증폭(tail latency amplification)** : 작은 비율의 백엔드 호출이 느린 경우 -> 요청이 여러번 백엔드 호출하면 느린 호출 가능성의 증가 -> 최종 사용자 요청 중 많은 비율의 응답 시간이 느려집니다.

### 부하 대응 접근 방식

- **용량 확장(scaling up), 수직 확장(vertical scaling)** : 좀 더 강력한 장비로 이동
- **규모 확장(scaling out), 수평 확장(horizontal scaling)** : 다수의 낮은 사용 장비에 부하를 분산
- **비공유(shared-nothing)** 아키텍처 : 다수의 장비에 부하를 분산하는 아키텍처
- 일부 시스템은 **탄력적(elastic)** 으로 돌아갑니다. 부하 증가시 컴퓨팅 자원을 자동으로 추가합니다.

<br/>

## 유지보수성

<br/>

## 정리
