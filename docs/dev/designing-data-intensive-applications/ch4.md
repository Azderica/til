---
sidebar_position: 4
---

# 4. 부호화와 발전

> 만물은 변한다. 그대로 있는 것은 아무것도 없다.

- 애플리케이션은 필연적으로 시간이 지남에 따라 변합니다. 새로운 제품이 출시하거나 요구사항을 잘 이해 혹은 환경이 변함에 따라 기능이 추가되거나 변경됩니다.
- 이러한 경우, 애플리케이션 기능을 변경하려면 저장하는 데이터도 변경해야합니다. 다만 스키마가 변경될 수도 있기 때문에 이전 데이터 타입과 새로운 데이터 타입이 섞여 포함될 수 있습니다.
- 대규모 애플리케이션에서 코드 변경은 즉시 반영이 힘듭니다.
  - 서버측에서는 rolling upgrade, 혹은 staged rollout 이라고 불리는 순회식 업그레이드를 진행합니다.
  - 클라이언트 측은 애플리케이션에 의해 전적으로 좌우되며 업데이트를 설치하지 않을 수도 있습니다.
- 즉, 예전 버전의 코드와 새로운 버전의 코드가 공존할 수 있다는 이야기입니다.
  - **하위 호환성** : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 합니다.
  - **상위 호환성** : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 합니다.
  - 하위 호환성은 일반적으로 어렵지 않으나 상위 호환성은 어렵습니다.
- 아래의 챔터에서는 JSON, XML, Protocol Buffers등의 데이터 부호화를 위한 다양한 형식을 살펴봅니다.

## 데이터 부호화 형식

- 프로그램은 보통 두가지 형태로 표현된 데이터를 사용해 동작합니다.
  - object, struct, list, array, hash, tree 등의 데이터 구조, **인메모리**
  - 일련의 **바이트**열(ex, JSON 문서)
  - 인메모리 표현에서 바이트열로의 전환을 **부호화(직렬화나 마샬링)**이라고 하며 반대를 **복호화(파싱, 역직렬화, 언마샬링)**이라고 합니다.

> 직렬화는 트랜잭션에서도 사용되기 때문에 이 책에서는 부호화라고 합니다.

### 언어별 형식

- 많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 제공합니다.
  - ex) 자바의 `java.io.Serializable`, 루비의 `Marshal`, 파이썬의 `pickle` 등
- 프로그래밍 언어에 내장된 부호화 라이브러리는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있기 때문에 매우 편리하나 심각한 문제점 또한 많습니다.
  - 부호화는 보통 특정 프로그래밍 언어와 묶여 있는 경우가 많습니다.
  - 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 합니다. 이는 보안에서의 문제가 될 수도 있습니다.
  - 데이터 버전 관리는 보통 부호화 라이브러리에서는 나중에 생각하게 됩니다. 위에 언급된 상위, 하위 호환성의 불편만 문제가 등한시 됩니다.
  - 효율성도 종종 나중에 생각하게 됩니다. (자바가 그런 경우의 대표라고 합니다.)
- 매우 일시적인 목적 외에는 언어에 내장된 부호화를 사용하는 방식은 일반적으로 좋지 않습니다.

### JSON과 XML, 이진 변형

- 많은 프로그래밍에서 읽고 쓸 수 있는 표준화 부호화로 JSON과 XML이 있습니다. 그외에도 CSV가 있습니다.
- JSON, XML, CSV는 텍스트 형식이라 어느 정도 사람이 읽을 수 있습니다. 그러나 몇 가지 문제점이 있습니다.
  - XML과 CSV에서는 수와 digit를 구분할 수 없습니다.
  - 큰 수를 다룰 때, 부동소수점 수를 사용하는 js 언어에서 파싱할 때 부정확해질 수 있습니다.
  - JSON과 XML은 유니코드 문자열을 잘 지원하나 이진 문자열을 지원하지 않습니다.
- JSON, XNL, CSV는 다양한 용도에서 장점을 가지며 특히 데이터 교환 형식에서 매우 좋습니다.
- 특히 이러한 상황에서는 다른 조직의 동의를 얻는 작업이 어렵습니다.

#### 이진 부호화

- 조직 내에서 사용하는 경우, 최소공통분모 부호화 형식을 사용해야 하는 부담감이 덜합니다. 즉, 더 간편하고 파싱이 빠른 형식을 쓸 수 있습니다.
- 데이터 셋의 크기는 용량이 커질 수록 이득이 커집니다.
- JSON과 XML은 이진 형식에 비교하면 둘 다 훨씬 많은 공간을 사용합니다.
- 메시지팩이 대표적인 예시며 JSON용 이진 부호화 형식입니다.

![json-messagepack](https://user-images.githubusercontent.com/42582516/137404707-6841c1b9-2f6e-4235-adf1-4b48eaa41548.png)

### 스리프트와 프로토콜 버퍼

- 아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers)는 같은 원리를 기반으로 한 이진ㄷ 부호화 라이브러리입니다.
- 스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요합니다.

스리프트 예제

```json
struct Person {
  1: required string    userName,
  2: optional i64       favoriteNumber;
  3: optional list<string> interests
}
```

프로토콜 예제

```json
message Person {
  required string user_name      = 1;
  optional int64 favorite_number = 2;
  repeated string interests      = 3;
}
```

- 스리프트와 프로토콜 버퍼는 각각 여기서 본 것처럼 스키마 정의를 사용해 코드를 생성하는 도구가 있습니다.
  - 이 도구를 통해서 다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성합니다.
  - 애플리케이션 코드는 생성된 코드를 호출해 스키마의 레코드를 부호화하고 복호화합니다.
- 스리프트는 **바이너리프로토콜(BinaryProtocol)** 과 **컴팩트프로토콜(CompactProtocol)** 이라는 두 가지 이진 부호화 형식이 있습니다.
  - 바이너리프로토콜은 필드 이름 대신 **필드 태그(field tag)** 를 포함합니다.
  - 컴팩트프로토콜은 의미는 같으나 동일한 정보를 34바이트로 줄여서 부호화합니다. (필드 타입과 태그 숫자를 단일 바이트로 줄이고, 가변 길이 변수를 사용합니다.)
- 프로토콜 버퍼는 스리프트의 컴팩트프로토콜과 비슷하며 같은 데이터를 33바이트로 만듭니다.

#### 필드 태그와 스키마 발전

- 스키마는 필연적으로 시간이 지남에 따라 변하는 것을 **스키마 발전(schema evolution)** 이라고 부릅니다.
- 스리프트와 프로토콜 버퍼는 하위 호환성과 상위 호환성을 유지하기 위해서는 다음의 기능을 제공하빈다.
  - 상위 호환성의 경우, 필드에 새로운 태그 번호를 줌으로서 예전 코드가 새로운 코드를 읽을 수 있습니다.
  - 하위 호환성의 경우, 각 필드에 고유한 태그 번호가 있는 동안에는 같은 의미를 가지고 있기 때문에 예전 데이터를 항상 볼 수 있습니다.
  - 삭제의 경우, 하위 호환성과 상위 호환성 문제를 해결하는 방식과 반대로 하면 됩니다.

#### 데이터타입과 스키마 발전

- 필드의 데이터타입을 변경하는 경우는 값이 정확하지 않거나 잘릴 위험이 있습니다.
- 프로토콜 버퍼의 기능으로 필드에 repeated 표시자와 optional 필드가 있는데, optional 필드를 repeated 필드로 변경해도 상관이 없습니다.
  - 이전 데이터를 읽는 새로운 코드는 0이나 1개의 엘리먼트가 있는 목록으로 봅니다.
  - 새로운 데이터를 읽는 예전 코드는 목록의 마지막 엘리먼트만 보게 됩니다.
- 스리프트는 전용 목록 데이터타입이 있으며 목록 데이터타입은 목록 엘리먼트의 데이터타입을 매개변수로 받으며 중첩된 목록을 지원한다는 장점이 있습니다.

### 아브로

### 스키마의 장점

<br/>

## 데이터플로 모드

### 데이터베이스를 통한 데이터 플로

### 서비스를 통한 데이터플로: REST와 RPC

### 메시지 전달 데이터플로
