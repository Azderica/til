---
sidebar_position: 9
---

# 9. 일관성과 합의

- 8장에서 봤듯이 분산 시스템에서는 많은 것들이 잘못될 수 있습니다. 쉬운 해결책으로 전체 서비스가 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것이빈다.
- 이러한 해결책이 어렵다면 결함을 **견더낼(tolerating)** , 방법을 찾아야합니다.
- 아래에서는 내결함설을 지닌 분산 시스템을 구축하는 데 쓰이는 알고리즘과 프로토콜의 몇 가지 예를 이야기합니다.

## 일관성 보장

- 복제 데이터 베이스는 대부분 최소한 **최종적 일관성**을 제공합니다.
  - 데이터베이스에 쓰기를 멈추고 볼 특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻이빈다.
  - 모든 복제본이 결국 같은 값으로 **수렴**되기를 기대함으로 최종적 일관성보다 수렴이 더 나은 이름일 수도 있습니다.
- 다만 위는 매우 약한 보장이며, 언제 복제본이 수렴될지에 대해서는 이야기가 없습니다.
- 약한 보장만 제공하는 데이터베이스를 다룰 때는 그 제한을 알아야하고 뜻하지 않게 너무 많은 것을 가정하면 안됩니다.

아래에서는 데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 살펴봅니다.

- 공통적으로 사용되는 가장 강한 일관성 모델 중 하나인 선현성(linearizability)을 살펴보고 장점과 단점을 검토합니다.
- 분산 시스템에서 이벤트 순서화 문제, 특히 인과성과 전체 순서화와 관련된 문제를 검토합니다.
- 분산 트랜잭션을 원자적으로 커밋하는 방법을 살펴봅니다.

<br/>

## 선형성

- 최종적 일관성을 지닌 데이터베이스에서 두 개의 다른 복제본의 같은 질문을 동시에 하면 두 가지 다른 응답을 받을 수도 있습니다.
- 위 문제에서 데이터베이스가 복제본이 하나만 있다면 더 단순해지지 않을까라는 생각을 할 수 있으며, 이는 **선형성**을 뒷받침해주는 아이디어입니다.
- 선형성은 **원자적 일관성(atomic consistency), 강한 일관성(strong consistency), 즉각 일관성(immediate consistency), 외부 일관성(external consistency)** 라고 합니다.
  - 기본적인 아이디어는 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것입니다.
- 선형성 시스템에서는 클라이언트가 쓰기를 성공적으로 완료하자마자 그 데이터베이스를 읽는 모든 클라이언트는 방금 쓰여진 값을 볼 수 있어야 합니다.
  - 즉, 선형성은 **최신성 보장(recency guarantee)** 를 의미합니다.

![비선형적 구조](https://user-images.githubusercontent.com/42582516/142873723-3f488219-86aa-4f9c-b26f-6a1f89c5a1b1.png)

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 선형성을 받침하는 기본 아이디어는 시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만드는 것입니다.
- 선현성 데이터베이스에서 동시에 같은 키 x를 읽고 쓰는 세 클라이언트는 분산 시스템에 분야에서는 x를 **레지스터(register)** 라고 부릅니다.

![읽기 요청이 쓰기 요청과 동시에 실행되면 과거의 값을 반환하거나 새로운 값을 반환할 수 있음](https://user-images.githubusercontent.com/42582516/142876264-46c3df5b-698c-4970-995e-fdfc742c1467.png)

- 이 예제에서는 레지스터는 두 가지 종류의 연산이 있습니다.
  - `read(x) => v` 는 클라이언트가 레지스터 읽기를 요청하고 데이터베이스가 값 v를 반환했다는 것을 의미합니다.
  - `write(x, v) => r` 은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답 r을 반환했다는 것을 의미합니다.
- 읽기 연산이 처리되는 시점에 쓰기의 영향이 발생했는지 알 수 없으므로, 쓰기와 읽기 연산은 동시에 실행됩니다.

![제약 조건을 추가한 경우](https://user-images.githubusercontent.com/42582516/142876570-5328f574-85be-41c6-b8c7-ecf04b6f877e.png)

- 이를 해결하기 위해서는 다른 제약 조건을 추가해야합니다.
- 이를 좀 더 개선한 경우는 다음과 같습니다. (읽기와 쓰기 외에 세 번째 종류의 연산을 추가합니다.)

![읽기와 쓰기를 시각화한 경우](https://user-images.githubusercontent.com/42582516/142947638-a4372b39-cf89-404f-b948-ea85eeddaf8f.png)

- `Client B`의 마지막 읽기는 선형적이지 않습니다.
- 이러한 방법을 통해서 모든 요청과 응답 시점을 유효한 순차 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트할 수 있습니다.

> 선형성 대 직렬성

- **직렬성**
  - 직렬성은 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 **트랜잭션들**의 격리 속성입니다.
  - 직렬성은 트랜잭션들이 **어떤** 순서에 따라 실행되는 것처럼 동작하도록 보장합니다.
- **선형성**
  - 레지스터(**개별 객체**)에 실행되는 읽기와 스기에 대한 최신성 보장입니다.선형성은
  - 선형성은 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못합니다.

데이터베이스는 직렬성과 선형성을 모두 제공할 수 있으므로 이러한 조합은 **엄격한 직렬성(strict serializability)** 혹은 **강한 단일 복사 직렬성(strong one-copy serializability)** 라고 합니다.

그러나 직렬성 스냅숏 격리는 선형적이지 않습니다. 설계상 직렬성 스냅숏 격리는 읽는 쪽과 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽습니다. 일관된 스냅숏의 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고 따라서 스냅숏 읽기는 선형적이지 않습니다.

### 선형성에 기대기

선형성이 중요한 요구사항이 되는 경우가 때때로 있습니다.

#### 잠금과 리더 선출

- 단일 리더 복제를 사용하는 시스템은 리더가 여러개(스플릿 브레인)가 아니라 진짜 하나만 보장하도록 해야합니다.
- 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼(Apache ZooKeepr)나 etcd 같은 코디네이션 서비스가 종종 사용됩니다.
  - 이들은 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있느 방식으로 구현합니다.
- 분산 잠금은 오라클 리얼 애플리케이션 클러스터 같은 분산 데이터베이스에서 훨씬 세분화된 수준으로 사용되기도 합니다.

#### 제약 조건과 유일성 보장

- 유일성 제약 조건은 데이터베이스에서 흔합니다. (Ex. 사용자 명이나 이메일 주소)
  - 이러한 조건을 강제하고 싶다면 선형성이 필요합니다.
  - 마찬가지로, 은행 계좌 잔고가 음수가 되지 않거나 예약의 경우 모든 노드가 동의하는 하나의 최신 값이 있기를 요구합니다.
- 실제 애플리케이션에서는 종종 이런 제약 조건을 느슨하게 다르기도 하지만, 관계형 데이터베이스에서 전형적으로 볼 수 있는 엄격한 유일성 제약 조건은 선현성이 필요합니다.

#### 채널 간 타이밍 의존성

- 파일 저장 서비스가 선형적이면 잘 돌아가지만, 아니라면 경쟁 조건의 위험이 언제나 있습니다.
- **선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기에 가장 단순**합니다.

### 선형성 시스템 구현하기

이전의 내용에서 선형적이 될 가능성을 확인해보면 아래와 같습니다.

- 단일 리더 복제 : 선형적 가능성 존재
  - 읽기에 리더를 사용하기 위해서는 누가 리더인지를 정확하게 안다고 가정해야 합니다.
- 합의 알고리즘 : 선형적
  - 주키퍼 등의 코디네이트를 통해서 가능합니다.
- 다중 리더 복제 : 비선형적
  - 여러 노드에서 동시 쓰기를 처리하고 쓰여진 내용을 비동기적으로 처리하기 때문에 선형적이지 않습니다.
- 리더 없는 복제 : 아마도 비선형적
  - 정족수 및 엄격한 일관성에 따라 결정됩니다.

#### 선형성과 정족수

- 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보입니다. 그러나 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있습니다.
- 정족수 조건이 만족됨에도 실행은 선형적이지 않을 수 있습니다.
- 성능이 떨어지는 비용을 지불하고 다이타모 스타일 정족수를 선형적으로 만드는 것도 가능합니다.
  - 다만 이경우는 선형성 읽기와 쓰기 연산만 수행할 수 있습니다.
- 즉, 다이나모 스타일 복제를 하는 **리더 없는 시스템은 선형성을 제공하지 않는다**고 보는 게 안전합니다.

### 선형성의 비용

- 두 데이터센터 사이에 네트워크가 끊기면 다중 리더 데이터베이스는 사용이 가능하지만 단일 리더 복제의 경우는 리더가 데이터센터 중 하나에 있어야만 돌아갑니다.
  - 즉, 팔로워 데이터센터로 접속한 클라이언트는 리더를 연결할 수 없으므로 데이터베이스 쓸 수 없고 선형성 읽기도 전혀 할 수 없습니다.

#### CAP 정리

- 위 문제는 다른 경우에도 발생할 수 있습니다.
  - 애플리케이션에서 **선형성을 요구**하고 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리할 수 없습니다. 네트워크 문제가 고쳐질 때까지 기다리거나 오류를 반환해야 합니다. (즉, **가용성**이 없습니다.)
  - 애플리케이션에서 **선형성을 요구하지 않는다**면 각 복제 서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있습니다. 이 경우 애플리케이션은 네트워크 문제에 직면해도 가용한 상태를 유지하지만 그 동작은 선형적이지 않습니다.
- 선형성이 필요 없는 애플리케이션은 네트워크 문제에 더 강인합니다.
  - 이는 CAP 정리로 알려졌습니다.
- **CAP**는 데이터베이스에서 **트레이드오프에 대한 논의를 시작하려는 목적으로 정확한 정의 없이 경험 법칙으로 제안**되었습니다.
- 공식적으로 정의된 CAP 정리는 매우 범위가 좁으며, 오직 하나의 일관성 모델과 한 종류의 결함만 고려합니다.
  - 더 이상은 실용적인 가치는 없습니다.

> 도움이 안되는 CAP 정리

- CAP는 때때로 **일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance)** 이라는 세 개 중 두 개를 고르라는 것으로 표현됩니다.
- CAP는 **네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 보는 것**이 좋습니다.
- 또한 가용성이란 단언느 몇 가지 모순된 정의가 있습니다.

[CAP 이론과 PACELC 이론](https://azderica.github.io/00-db-cap/)

#### 선형성과 네트워크 지연

- 선형성은 유용한 보장이지만 현실에서는 실제로 선형적인 시스템은 놀랄만큼 드뭅니다.
- **성능을 위해 선형성이 손실**되는 트레이드 오프가 발생하는 경우가 자주 발생합니다.
- 분산 데이터베이스도 마찬가지의 이유 입니다.
- 즉, **선형성을 원하면 읽기와 쓰기 요청의 응답 시간이 적어도 네트워크 지연의 불확싱성에 비례**합니다.
- 지연시간에 민감한 시스템에서는 이러한 트레이드 오프가 중요합니다.

아래에서는 정확성을 희생하지 않고 선형성을 회피하는 방법입니다.

<br/>

## 순서화 보장

### 순서화와 인과성

### 일련번호 순서화

### 전체 순서 브로드캐스트

<br/>

## 분산 트랜잭션과 합의

### 원자적 커밋과 2단계 커밋(2PC)

### 현실의 분산 트랜잭션

### 내결함성을 지닌 합의

### 멤버십과 코디네이션 서비스

<br/>

## 정리
