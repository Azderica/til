<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">3. 설계 원칙 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/clean-architecture/ch3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="3. 설계 원칙 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="7장. SRP: 단일 책임 원칙"><meta data-react-helmet="true" property="og:description" content="7장. SRP: 단일 책임 원칙"><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/clean-architecture/ch3"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/clean-architecture/ch3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/clean-architecture/ch3" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.6e22481b.js" as="script">
<link rel="preload" href="/til/assets/js/main.d4fbf680.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch11">11. 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch12">12. 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch13">13. 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch14">14. 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch15">15. 디자인 패턴과 프레임 워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch16">부록 A. 계약에 의한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch17">부록 B. 타입 계층의 구현</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch18">부록 C. 동적인 협력, 정적인 코드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">3. 설계 원칙</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="7장-srp-단일-책임-원칙"></a>7장. SRP: 단일 책임 원칙<a class="hash-link" href="#7장-srp-단일-책임-원칙" title="Direct link to heading">#</a></h2><ul><li>SRP는 헷갈리기 쉽습니다.</li><li><strong>단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 합니다.</strong></li><li>이를 다르게 말하면 <strong>하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 합니다.</strong></li><li>SRP의 최종적으로 정리는 다음과 같습니다.<ul><li><strong>하나의 모듈은 하나의 오직 하나의 액터에 대해서만 책임져야 합니다.</strong></li></ul></li><li>&#x27;모듈&#x27;은 간단하게 이야기 하면 대부분은 소스 파일이고, 단순히 함수와 데이터 구조로 구성된 응집된 결합입니다.</li><li>SRP를 잘 이해하는 방법 중 하나는 원칙을 위반하는 징후를 확인하는 것입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="징후-1-우발적-중복"></a>징후 1: 우발적 중복<a class="hash-link" href="#징후-1-우발적-중복" title="Direct link to heading">#</a></h3><p><img src="https://user-images.githubusercontent.com/42582516/143684221-bbf791af-3ed5-49fe-b3f1-05dfc08e9997.png" alt="우발적 중복"></p><ul><li>SRP를 위반하며, 세가지 메서드가 세명의 액터를 책임지는 문제가 있습니다.</li><li>이후 작업을 했을 때, 이러한 변경사항이 다른 문제를 만들게 됩니다.<ul><li>즉, CFO를 위해 수정을 했으나 변경을 희망하지 않는 COO가 변경될 수 있습니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="징후-2-병합"></a>징후 2: 병합<a class="hash-link" href="#징후-2-병합" title="Direct link to heading">#</a></h3><ul><li>소스 파일에 다양하고 많은 메서드를 포함하면 병함이 자주 발생하리라고 짐작하기는 어려운 일은 아닙니다.<ul><li>특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높습니다.</li></ul></li><li>병합은 항상 위험이 뒤따르게 됩니다.</li><li>이를 해결하는 방법은 <strong>서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것</strong>입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="해결책"></a>해결책<a class="hash-link" href="#해결책" title="Direct link to heading">#</a></h3><ul><li>이 문제의 해결책은 여러 방법이 있습니다.</li><li>가장 확실한 해결책은 데이터와 메서드를 분리하는 방식입니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/143684752-05825fd9-f0cb-49f3-8e22-3e746c8dee8e.png" alt="세 클래스는 서로의 존재를 알지 못합니다."></p><ul><li>다만 위 해결책은 세가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점입니다.</li><li>이를 해결하기 위한 방법으로 <strong>퍼사드(Facade)</strong> 패턴이 있습니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/143684916-15359a25-5151-4ae3-a559-b57f538a4c14.png" alt="퍼사드 패턴"></p><ul><li>가장 중요한 메서드를 기존 Employee에 넣고 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있습니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/143685025-b39911a6-f713-49cf-8986-a67110828f8b.png" alt="덜 중요한 메서드를 퍼사드 패턴"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론"></a>결론<a class="hash-link" href="#결론" title="Direct link to heading">#</a></h3><ul><li>단일 책임 원칙은 메서드와 클래스 수준의 원칙입니다.</li><li>컴포넌트 수준에서는 <strong>공통 폐쇄 원칙(Common Closure Principle)</strong> 이 됩니다.</li><li>아키텍처 수준에서는 <strong>아키텍처 경계(Architectural Boundary)</strong> 의 생성을 책임지는 변경의 축이 됩니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="8장-ocp--개방-폐쇄-원칙"></a>8장. OCP : 개방-폐쇄 원칙<a class="hash-link" href="#8장-ocp--개방-폐쇄-원칙" title="Direct link to heading">#</a></h2><ul><li>OCP의 뜻은 <strong>소프트웨어 개체(artifact)는 확장에는 열려 있어야하고, 변경에는 닫혀 있어야합니다.</strong></li><li>소프트웨어 아키텍처를 공부하는 가장 근본적인 이유이며, 확장성이 없다면 엄청난 수정이 필요합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="사고-실험"></a>사고 실험<a class="hash-link" href="#사고-실험" title="Direct link to heading">#</a></h3><ul><li>어떤 변경이 들어왔을 때 소프트웨어 아키텍처가 훌륭하다면 변경되는 코드의 양이 가능한 한 최소화가 될 것입니다.</li><li>서로 다른 목적으로 변경되는 요소를 적절하게 분리(단일 책임 원칙, SRP)하고 이들 요소 사이의 의존성을 체계화함으로써(의존성 역전 원칙, DIP) 변경량을 최소화할 수 있습니다.</li></ul><p>먼저 단일 책임 원칙을 적용하면 데이터 흐름을 그림으로 나타낼 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/143726735-27be2075-c248-474d-b249-0d594076920f.png" alt="SRP 적용"></p><ul><li>위처럼 책임을 분리한 다음에는 클래스 단위로 분할하고, 컴포넌트 단위로 구분해야 합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/143729628-dc034673-ee40-428a-9fd5-920f586e823c.png" alt="클래스, 컴포넌트 단위로 구분"></p><blockquote><blockquote><p><code>&lt;I&gt;</code> : 인터페이스, <code>&lt;DS&gt;</code> : 데이터 구조</p></blockquote></blockquote><ul><li>이를 한 후는 컴포넌트 관계를 그립니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/143729699-dc54efc7-2700-4b31-84e4-a4be4a25bd36.png" alt="컴포넌트 관계"></p><ul><li>컴포넌트 관계는 단방향으로 이루어집니다.</li><li>위의 예시에서 볼 수 있듯이 추가 설명을 하면 다음과 같습니다.<ul><li><code>Presenter</code>에서 발견한 변경으로부터 <code>Controller</code>를 보호하고자 합니다.</li><li><code>View</code>에서 발생한 변경으로부터 <code>Presenter</code>를 보호하고자합니다.</li><li><code>Interactor</code>은 다른 <code>모든 것에서 발생한 변경</code>으로 보호하고자 합니다.</li><li><code>Interactor</code>은 업무 규칙을 포함하기 때문에 가낭 높은 수준의 정책을 포함하는 특별한 규칙을 가지고 있습니다.</li><li>위의 예시처럼 계층구조가 &#x27;수준(level)&#x27;이라는 개념을 바탕으로 어떻게 생성되는지 확인하는 것이 중요합니다.</li></ul></li></ul><p>위는 아키텍처 수준에서 OCP가 동작하는 방식입니다. 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화합니다. 컴포넌트 계층구조를 이와 같이 조직화 하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="방향성-제어"></a>방향성 제어<a class="hash-link" href="#방향성-제어" title="Direct link to heading">#</a></h3><ul><li>위의 예시에서 <code>FinancialDataGateway</code> 인터페이스는 <code>Generator</code>과 <code>DataMapper</code> 사이에 존재하는데 이는 <strong>의존성을 역전</strong>시키기 위해서 입니다.<ul><li>이러한 인터페이스가 없었다면 의존성이 <code>Interactor</code> 컴포넌트에서 Database 컴포넌트로 바로 향하게 됩니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정보-은닉"></a>정보 은닉<a class="hash-link" href="#정보-은닉" title="Direct link to heading">#</a></h3><ul><li><code>FinancialReportRequester</code> 인터페이스는 방향성 제어와는 다른 목적을 가집니다. 즉, <code>Interactor</code> 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재합니다.<ul><li>인터페이스가 없는 경우, <code>Controller</code>는 <code>FinancialEntities</code>에 대해 추이 종속성(transitive dependency)을 가지게 됩니다.</li></ul></li><li>추아 종속성을 가지게 되면, 소프트웨어 엔티티는 &#x27;자신이 직접 사용하지 않는 요소에는절대로 의존해서는 안 된다&#x27;는 소프트웨어 원칙을 위반하게 됩니다.</li><li>이 원칙은 인터페이스 분리 원칙(ISP)와 공통 재사용 원칙(CRP)을 설명할 때 다시 한번 설명합니다.</li><li>즉, <code>Controller</code>에서 발생한 변경으로부터 <code>Interactor</code>를 보호하는 일의 우선순위가 가장 높지만, 반대로 <code>Interactor</code>에서 발생한 변경으로부터 <code>Controller</code>도 보호되기를 원합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-1"></a>결론<a class="hash-link" href="#결론-1" title="Direct link to heading">#</a></h3><ul><li>OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나입니다.</li><li>OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있습니다.</li><li>이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="9장-lsp--리스코프-치환-원칙"></a>9장. LSP : 리스코프 치환 원칙<a class="hash-link" href="#9장-lsp--리스코프-치환-원칙" title="Direct link to heading">#</a></h2><ul><li>리스코프에서는 치환(substitution) 법칙에 대해 이야기 합니다.</li><li>S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상속을-사용하도록-가이드하기"></a>상속을 사용하도록 가이드하기<a class="hash-link" href="#상속을-사용하도록-가이드하기" title="Direct link to heading">#</a></h3><p><img src="https://user-images.githubusercontent.com/42582516/144737098-2f92f885-e83e-43d0-a363-58e1a5ab3c68.png" alt="LSP 예시"></p><ul><li>위는 LSP를 준수한 예시입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정사각형직사각옇-문제"></a>정사각형/직사각옇 문제<a class="hash-link" href="#정사각형직사각옇-문제" title="Direct link to heading">#</a></h3><ul><li>LSP를 위반하는 전형적인 문제로 정사각형/직사각형 문제가 있습니다.</li><li>Square는 Rectangle의 하위 타입으로 적합하지 않으며, Rectangle의 높이와 너비는 반드시 함께 변경되나 Square의 경우 높이와 너비가 반드시 함께 변경되기 때문입니다.</li><li>LSP 위반을 막기 위한 유일한 방법은 if로 찾는 것이지만 이는 행위가 사용하는 타입에 의존성을 가지기 때문에 타입을 치환할 수 없게 됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="lsp와-아키텍처"></a>LSP와 아키텍처<a class="hash-link" href="#lsp와-아키텍처" title="Direct link to heading">#</a></h3><ul><li>객체 지향은 초칭기 상속을 사용하다록 가이드하는 방법으로 간주되었으나, 현재는 좀 더 광범위한 소프트웨어 설계원칙으로 변모해 왔습니다.</li><li>인터페이스는 다양한 형태로 나타납니다.<ul><li>자바라면 인터페이스와 이를 구현하는 여러개의 클래스</li><li>루비라면 동일한 메서드 시그니처를 공유하는 여러 개의 클래스로 구성</li></ul></li><li>모든 상황은 물론 더 많은 경우에 LSP를 적용할 수 있습니다.</li><li>아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-2"></a>결론<a class="hash-link" href="#결론-2" title="Direct link to heading">#</a></h3><ul><li>LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 합니다.</li><li>치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문입니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="10장-isp--인터페이스-분리-원칙"></a>10장. ISP : 인터페이스 분리 원칙<a class="hash-link" href="#10장-isp--인터페이스-분리-원칙" title="Direct link to heading">#</a></h2><ul><li>인터페이스 분리 원칙(ISP)는 다음의 다이어그램에서 이름이 유래했습니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/144766675-00ce5ec5-6e37-4bda-b787-637225fabb65.png" alt="인터페이스 분리 원칙"></p><ul><li>위의 예시에서 OPS가 정적 타입 언어로 작성된 클래스 인 경우, User1이 op2와 op3를 전혀 사용하지 않으나 User1의 소스 코드는 이 두 메서드에 의존하게 됩니다.</li><li>이러한 문제는 오프레이션을 인터페이스 단위로 분리하여 해결할 수 있습니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/144766807-1a11e9a5-eede-4afa-93ed-d86cea8fe159.png" alt="분리된 오퍼레이션"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="isp와-언어"></a>ISP와 언어<a class="hash-link" href="#isp와-언어" title="Direct link to heading">#</a></h3><ul><li>위의 사례는 언어 타입에 의존합니다.</li><li>정적 타입 언어는 사용자가 <code>import</code>, <code>use</code> 또는 <code>include</code>와 같은 타입 선언문을 사용하도록 강제합니다.<ul><li>이 구조에서는 <code>포함된(included)</code> 선언문으로 인해 소스 코드 의존성이 발생하므로, 재 컴파일 또는 재배포가 강제되는 상황이 무조건 초래됩니다.</li></ul></li><li>루비나 파이썬과 같은 동적 타입 언어에서는 소스 코드에 이러한 선언문이 존재하지 않습니다. 다만 런타임에 추론이 발생합니다.<ul><li>즉, 소스 코드 의존성이 아예 없으며, 재컴파일과 재배포가 필요없습니다.</li></ul></li><li>동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유입니다.</li><li>즉, ISP는 언어와 관련된 문제로 볼 수도 있습니다.</li></ul><blockquote><p>자바의 경우.</p></blockquote><ul><li>자바는 정적 타입 언어이지만, 재 컴파일만 하면 되는 것은 자바의 독특한 바인딩 방식이 있어서 그렇습니다.</li><li>자바는 비-final, 비-private 인스턴스 변쉥 대해서는 호출할 정확한 메서드를 런타임에 결정하는 늦은 바인딩
(late binding)을 수행합니다.</li><li>컴파일타임에는 호환되는 시그니처의 메서드가 타입 계층구조 어딘가에 존재하는지까지만 확인합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="isp와-아키텍처"></a>ISP와 아키텍처<a class="hash-link" href="#isp와-아키텍처" title="Direct link to heading">#</a></h3><ul><li>ISP를 사용하는 근본적인 동기는, 우려사항입니다.</li><li>필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 위험한 일입니다.</li><li>소스 코드 의존성의 경우, 분명한 사실이나 불필요한 재컴파일과 재배포를 강제하기 때문입니다.<ul><li>고수준 아키텍처 수준에서도 상황이 발생하게 됩니다.</li></ul></li></ul><p><img src="https://user-images.githubusercontent.com/42582516/144767043-b40ac905-4abb-42d1-ae3a-139f8ecd1414.png" alt="문제가 있는 아키텍처"></p><ul><li>F 프레임 워크가 D 데이터베이스를 반드시 사용하게 만들었고, S 시스템은 F를 사용할려고 합니다.</li><li>F에서 불필요한 기능, 따라서 S와 전혀 관계없는 기능이 D에 포함된다고 가정할 때 그 기능 때문에 D 내부가 변경되면 F를 재배포해야 할 수도 잇고, S까지도 재배포해야 할지도 모릅니다.</li><li>더 심각한 문제는 D 내부의 기능 중 F와 S에서 불필요한 그 기능에 문제가 발생해도 F와 S에 영향을 준다는 사실입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-3"></a>결론<a class="hash-link" href="#결론-3" title="Direct link to heading">#</a></h3><p>불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다는 사실입니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="11장-dip--의존성-역전-원칙"></a>11장 DIP : 의존성 역전 원칙<a class="hash-link" href="#11장-dip--의존성-역전-원칙" title="Direct link to heading">#</a></h2><ul><li>의존성 역전 원칙(DIP)에서 말하는 &#x27;유연성이 극대화된 시스템&#x27;이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템입니다.</li><li>자바와 같은 정적 타입 언어에서 이 말은 use, import, include 구문은 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다는 뜻입니다.</li><li>루비나 파이썬과 같은 동적 타입 언어에도 동일한 규칙이 적용됩니다.<ul><li>소스 코드 의존 관계에서 구체 모듈은 참조하면 안됩니다. (그러나 구체 모듈을 정의하기가 어렵습니다.)</li></ul></li><li>이러한 아이디어를 규칙으로 보기는 비현실적입니다. 왜냐하면 소프트웨어 시스템은 구체적인 많은 장치에 반드시 의존하기 때문입니다.</li><li>이러한 이유로 DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편입니다. 이러한 환경에 대한 의존성은 용납하는데, 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고 있기 때문입니다.</li><li><strong>의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰(volatile) 구체적인 요소입니다.</strong></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="안정된-추상화"></a>안정된 추상화<a class="hash-link" href="#안정된-추상화" title="Direct link to heading">#</a></h3><ul><li>추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라 수정해야합니다.<ul><li>반대로 구체적인 구현체에 변경이 생기더라도 구현체가 구현한 인터페이스는 대다수의 경우 변경될 필요가 없습니다.</li></ul></li><li>소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 낮추기 위해 애씁니다. (소프트웨어 설계의 기본)</li><li><strong>안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻</strong>입니다.</li><li>이를 실천법으로 정리하면 다음과 같습니다.<ul><li>변동성이 큰 구체 클래스를 참조하지마라. 대신 추상 인터페이스를 참조하라.<ul><li>일반적으로 추상 팩토리(Abstract Factory)를 사용하도록 강제합니다.</li></ul></li><li>변동성이 큰 구체 클래스로부터 파생하지 말라.<ul><li>상속은 아주 신중하게 사용해야 합니다.</li></ul></li><li>구체 함수를 오버라이드 하지 말라.</li><li>구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="팩토리"></a>팩토리<a class="hash-link" href="#팩토리" title="Direct link to heading">#</a></h3><ul><li>위 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 합니다.</li><li>자바 등 대다수의 객체 지향 언어에서는 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/144774501-d29df9d3-867d-4ff6-a479-7499fe78d32d.png" alt="추상 팩토리 예시"></p><ul><li>위 직선은 아키텍처 경계를 의미하며 구체적인 것과 추상적인 것들을 분리합니다.<ul><li>추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함하며, 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함합니다.</li></ul></li><li>제어흐름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목합니다.<ul><li>이 원칙을 <strong>의존성 역전(Dependency Inversion)</strong> 이라고 부릅니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="구체-컴포넌트"></a>구체 컴포넌트<a class="hash-link" href="#구체-컴포넌트" title="Direct link to heading">#</a></h3><ul><li>구체 컴포넌트에는 구체적인 의존성이 하나 있고, 이는 DIP에 위반됩니다.</li><li>DIP 위배를 모두 없앨 수는 있지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고 이를 통해 시스템의 나머지 부분과 분리할 수 있습니다.</li><li>대부분의 시스템은 이러한 구체 컴포넌트를 최소한 하나를 포함할 것이며, 일반적으로 이 컴포넌트를 메인(Main)이라고 부릅니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-4"></a>결론<a class="hash-link" href="#결론-4" title="Direct link to heading">#</a></h3><ul><li>고수준 아키텍처 원칙을 다루게 되면서 DIP는 몇번이고 등장합니다.</li><li>DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 됩니다.</li><li>의존성은 더 추상적인 엔티티가 있는 쪽으로만 향합니다. 이 규칙을 <strong>의존성 규칙(Dependency Rule)</strong>이라 부릅니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/clean-architecture/ch3.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-10-23T12:03:49.000Z" class="lastUpdatedDate_1WI_">10/23/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/clean-architecture/ch2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 2부. 벽돌부터 시작하기: 프로그래밍 패러다임</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/clean-architecture/ch4"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">4. 컴포넌트 원칙 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#7장-srp-단일-책임-원칙" class="table-of-contents__link">7장. SRP: 단일 책임 원칙</a><ul><li><a href="#징후-1-우발적-중복" class="table-of-contents__link">징후 1: 우발적 중복</a></li><li><a href="#징후-2-병합" class="table-of-contents__link">징후 2: 병합</a></li><li><a href="#해결책" class="table-of-contents__link">해결책</a></li><li><a href="#결론" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#8장-ocp--개방-폐쇄-원칙" class="table-of-contents__link">8장. OCP : 개방-폐쇄 원칙</a><ul><li><a href="#사고-실험" class="table-of-contents__link">사고 실험</a></li><li><a href="#방향성-제어" class="table-of-contents__link">방향성 제어</a></li><li><a href="#정보-은닉" class="table-of-contents__link">정보 은닉</a></li><li><a href="#결론-1" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#9장-lsp--리스코프-치환-원칙" class="table-of-contents__link">9장. LSP : 리스코프 치환 원칙</a><ul><li><a href="#상속을-사용하도록-가이드하기" class="table-of-contents__link">상속을 사용하도록 가이드하기</a></li><li><a href="#정사각형직사각옇-문제" class="table-of-contents__link">정사각형/직사각옇 문제</a></li><li><a href="#lsp와-아키텍처" class="table-of-contents__link">LSP와 아키텍처</a></li><li><a href="#결론-2" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#10장-isp--인터페이스-분리-원칙" class="table-of-contents__link">10장. ISP : 인터페이스 분리 원칙</a><ul><li><a href="#isp와-언어" class="table-of-contents__link">ISP와 언어</a></li><li><a href="#isp와-아키텍처" class="table-of-contents__link">ISP와 아키텍처</a></li><li><a href="#결론-3" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#11장-dip--의존성-역전-원칙" class="table-of-contents__link">11장 DIP : 의존성 역전 원칙</a><ul><li><a href="#안정된-추상화" class="table-of-contents__link">안정된 추상화</a></li><li><a href="#팩토리" class="table-of-contents__link">팩토리</a></li><li><a href="#구체-컴포넌트" class="table-of-contents__link">구체 컴포넌트</a></li><li><a href="#결론-4" class="table-of-contents__link">결론</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.6e22481b.js"></script>
<script src="/til/assets/js/main.d4fbf680.js"></script>
</body>
</html>