<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">4. 컴포넌트 원칙 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/clean-architecture/ch4"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="4. 컴포넌트 원칙 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 아려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 알려줍니다."><meta data-react-helmet="true" property="og:description" content="SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 아려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 알려줍니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/clean-architecture/ch4"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/clean-architecture/ch4" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/clean-architecture/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.e80812b4.js" as="script">
<link rel="preload" href="/til/assets/js/main.cea52fe2.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">4. 컴포넌트 원칙</h1></header><div class="markdown"><p>SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 아려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 알려줍니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="12장-컴포넌트"></a>12장. 컴포넌트<a class="hash-link" href="#12장-컴포넌트" title="Direct link to heading">#</a></h2><ul><li>컴포넌트는 배포 단위며, 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위입니다.<ul><li>자바의 경우 jar 파일, 루비는 gem 파일, 닷넷은 DLL입니다.</li><li>컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체입니다.</li><li>인터프리터형 언어의 경우는 소스 파일의 결합체입니다.</li></ul></li><li>여러 머포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있습니다.<ul><li>여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로 만들 수 잇습니다.</li><li>컴포넌트 각각을 .jar 이나 .dll 같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어서 독립적으로 배포할 수 있습니다.</li><li><strong>컴포넌트</strong>가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 <strong>독립적으로 배포 가능</strong>한, <strong>독립적으로 개발 가능한 능력을 갖춰야 합니다.</strong></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컴포넌트의-간략한-역사"></a>컴포넌트의 간략한 역사<a class="hash-link" href="#컴포넌트의-간략한-역사" title="Direct link to heading">#</a></h3><ul><li>소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했습니다.<ul><li>프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정할 사항 중 하나 였습니다.</li><li>장치가 느리고 메모리가 바싸서 자원이 한정적이였습니다.</li></ul></li><li>오늘날은 프로그램을 메모리의 어느 위치에 로드할지 고민할 필요가 거의 없습니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145665076-ad012b0c-509e-45ef-8a2d-566a94b3cc87.png" alt="초기의 메모리 배치"></p><ul><li>프로그램과 라이브러리가 사용하는 메모리가 늘수록 위의 단편화가 게속되므로 문제가 있었습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="재배치성"></a>재배치성<a class="hash-link" href="#재배치성" title="Direct link to heading">#</a></h3><ul><li>해결책은 <strong>재배치가 가능한 바이너리(relocatable binary)</strong> 였습니다.<ul><li>지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것입니다.</li></ul></li><li>프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었습니다.<ul><li>프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었습니다.</li></ul></li><li>컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었스빈다.<ul><li>만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 <strong>외부 참조(external reference)</strong> 로 생성했습니다.</li><li>라이브러리 함수를 정의하는 프로그램이라면 이름을 <strong>외부 정의(external definition</strong>) 로 생성했습니다.</li><li>이렇게 함으로 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 되는 <strong>링킹 로더(linking loader)</strong> 가 탄생했습니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="링커"></a>링커<a class="hash-link" href="#링커" title="Direct link to heading">#</a></h3><ul><li>링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었습니다.</li><li>그러나 프로그램이 커지게되며 링킹 로더가 너무 느려지는 문제가 발생했습니다.</li><li>이를 해결하기 위해 <strong>로드</strong>와 <strong>링크</strong>로 분리되었습니다.<ul><li>느린 링크 과정을 해결하기 위해 <strong>링커(linker)</strong> 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었습니다.</li><li>링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌습니다.</li></ul></li><li>1980년대가 되며 C와 같은 고수준 언어를 사용하게 되며 프로그램이 더 커졌습니다.</li><li>소스 모듈은 .c파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어졌습니다.<ul><li>각 모듈은 컴파일하는 과정은 상대적으로 빨랐지만, <strong>전체</strong> 모듈을 컴파일 하는 일은 꽤 시간이 걸렸습니다.</li><li>로드 시간은 빨랐지만 컴파일-링크 시간이 병목 구간이 있었습니다.</li></ul></li><li>그 이후 디스크가 적어지고, 컴퓨터 메모리 또한 저렴해졌으며, 컴퓨터 클록 속도 또한 증가했습니다.<ul><li>1990년대 후반이 되자 프로그래머가 프로그램 성장시키는 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌습니다.</li></ul></li><li>이후에는 .jar 파일도 등장했으며 컴퓨터와 장치가 빨려져서 로드와 링크를 동시에 할 수 있게 되었고 다수의 .jar 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었습니다.<ul><li>이렇게 컴포넌트 플러그인 아키텍처(component plugin architecture)가 탄생했습니다.</li></ul></li><li>오늘날은 .jar 파일, DLL, 공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것이 일상적인 일이 되었습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론"></a>결론<a class="hash-link" href="#결론" title="Direct link to heading">#</a></h3><p>런타임에 플러그인 형태로 결합할 수 잇는 동적 링크 파일이 이 책에서 이야기하는 소프트웨어 컴포넌트에 해당합니다. 이 과정이 50년입니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="13장-컴포넌트-응집도"></a>13장. 컴포넌트 응집도<a class="hash-link" href="#13장-컴포넌트-응집도" title="Direct link to heading">#</a></h2><p>컴포넌트 응집도에 관련된 세 가지 원칙이 있습니다.</p><ul><li>REP: 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)</li><li>CCP: 공통 폐쇄 원칙(Common Closure Principle)</li><li>CRP: 공통 재사용 원칙(Common Reuse Principle)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="rep-재사용릴리스-등가-원칙"></a>REP: 재사용/릴리스 등가 원칙<a class="hash-link" href="#rep-재사용릴리스-등가-원칙" title="Direct link to heading">#</a></h3><blockquote><p>재사용 단위는 릴리스 단위와 같습니다.</p></blockquote><ul><li>소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용할 수 없습니다.</li><li>릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는 지 보증할 방법이 전혀 없습니다.</li><li>소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 의미합니다.<ul><li>컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 합니다.</li></ul></li><li>하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 <strong>릴리스할 수 있어야 합니다.</strong></li><li>이 조건으로만 클래스와 모듈을 묶는 방법을 설명하기 힘들기에 조건이 약합니다.<ul><li>즉, 이 원칙을 어기면 &#x27;이치에 맞지&#x27; 않게 됩니다.</li></ul></li><li>이 원칙의 <strong>약점</strong>은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있습니다.<ul><li>CCP와 CRP는 REP를 엄격하게, 제약을 가하는 측면에서 정의합니다</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ccp-공통-폐쇄-원칙"></a>CCP: 공통 폐쇄 원칙<a class="hash-link" href="#ccp-공통-폐쇄-원칙" title="Direct link to heading">#</a></h3><blockquote><p>동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶습니다. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리합니다.</p></blockquote><ul><li>이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴것입니다.<ul><li>SRP에서 단일 <strong>클래스(class)</strong> 는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, <strong>공통 폐쇄 원칙(CCP)</strong> 에서도 마찬가지로 단일 <strong>컴포넌트(component)</strong> 는 변경의 이유가 여러 개 있어서는 안 된다고 말합니다.</li></ul></li><li>대다수의 애플리케이션에서 <strong>유지보수성(maintainability)</strong> 은 재사용성보다 훨씬 중요합니다.<ul><li>애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫습니다.</li><li>변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 됩니다.</li></ul></li><li>CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권합니다.<ul><li>물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야합니다.</li><li>이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있습니다.</li></ul></li><li>발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계합니다.</li><li>CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로서, 변경이 필요한 요구사항이 발상할 때 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아집니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="srp와의-유사성"></a>SRP와의 유사성<a class="hash-link" href="#srp와의-유사성" title="Direct link to heading">#</a></h4><ul><li>CCP는 컴포넌트 수준의 SRP입니다.</li></ul><blockquote><p>동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리합니다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="crp-공통-재사용-원칙"></a>CRP: 공통 재사용 원칙<a class="hash-link" href="#crp-공통-재사용-원칙" title="Direct link to heading">#</a></h3><blockquote><p>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 않습니다.</p></blockquote><ul><li>공통 재사용 원칙(CRP)도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙입니다.<ul><li>CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말합니다.</li></ul></li><li>개별 클래스가 단독으로 재사용되는 경우는 거의 없습니다.<ul><li>일반적으로는 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 사용작용하는 경우가 많습니다.</li><li>컴포넌트 내부에서는 클래스들 사이에 수많은 의존성이 있으리라고 예상할 수 있습니다.</li></ul></li><li>간단한 예시로 컨테이너(container) 클래스와 해당 클래스의 이터레이터(iterator) 클래스를 들 수 있으며 강결합되어 있기에 함께 재사용됩니다. 즉, 이 클래스들은 반드시 동일한 컴포넌트에 위치해야 합니다.</li><li>CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 알려줍니다.<ul><li>컴포넌트가 다른 컴포넌트를 사용하면 두 컴포넌트 사이는 의존성이 생깁니다.</li><li>이러한 의존성이 있는 경우, 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트를 변경하거나 재컴파일, 재검증, 재배포 가능성이 남아있습니다.</li></ul></li><li>의존하는 컴포넌트가 있다면 핻아 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야합니다.</li><li>CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 묶어서 안되는지에 대해서 훨씬 더 많은 것을 이야기합니다.<ul><li>CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 이야기합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="isp와의-관계"></a>ISP와의 관계<a class="hash-link" href="#isp와의-관계" title="Direct link to heading">#</a></h4><p>CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전입니다.</p><ul><li>ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언하며, CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언합니다.</li></ul><blockquote><p>필요하지 않은 것에 의존하지 않습니다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컴포넌트-응집도에-대한-균형-다이어그램"></a>컴포넌트 응집도에 대한 균형 다이어그램<a class="hash-link" href="#컴포넌트-응집도에-대한-균형-다이어그램" title="Direct link to heading">#</a></h3><ul><li>응집도에 관한 세 원칙은 상충됩니다.</li><li>REP와 CCP는 <strong>포함(inclusive)</strong> 원칙이며, 컴포넌트를 더욱 크게 만듭니다.</li><li>CRP는 <strong>배제(exclusive)</strong> 원칙이며, 컴포넌트를 더욱 작게 만듭니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145679950-6d46552b-e2f1-40ca-a0a8-9e0a7b87270e.png" alt="결합도 원칙들의 균형 다이어그램"></p><ul><li>REP와 CRP에만 중점을 두면 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미치며 반대로 CCP나 REP에만 과도하게 집중되면 불필요한 릴리스가 너무 빈번해집니다.</li><li>뛰어난 아키텍트라면 이 균형 삼각형에서 개발팀이 <strong>현재</strong> 관심을 기울이는 부분을 <strong>충족</strong>시키는 위치를 찾아야하며, 시간이 흐르면서 우선순위가 바뀌는 부분도 인지해야합니다.<ul><li>초기에는 CCP가 REP보다 훨씬 중요합니다. (개발가능성이 재사용성보다 중요하므로)</li></ul></li><li>일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 오직 재사용성만 희생하면 됩니다.<ul><li>프로젝트가 성숙해지고 파생된 또 다른 프로젝트가 시작되면서 프로젝트는 삼각형에서 점차 왼쪽으로 이동합니다.</li><li>프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-1"></a>결론<a class="hash-link" href="#결론-1" title="Direct link to heading">#</a></h3><ul><li>클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 합니다.</li><li>이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요합니다.</li></ul><p>시간에 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="14장-컴포넌트-결합"></a>14장. 컴포넌트 결합<a class="hash-link" href="#14장-컴포넌트-결합" title="Direct link to heading">#</a></h2><p>아래의 세가지 원칙은 컴포넌트 사이의 관계를 설명합니다. 개발 가능성과 논리적 설계 사이의 균형을 다룹니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="adp-의존성-비순환-원칙"></a>ADP: 의존성 비순환 원칙<a class="hash-link" href="#adp-의존성-비순환-원칙" title="Direct link to heading">#</a></h3><blockquote><p>컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안됩니다.</p></blockquote><ul><li>누군가가 마지막으로 수정한 코드 때문에 다른 사람들의 작업이 안되는 경우가 큰 프로젝트에서는 비일비재합니다.</li><li>이 문제의 큰 해결책은 <strong>&#x27;주 단위 빌드(weekly build)&#x27;</strong> 와 <strong>&#x27;의존성 비순환 원칙(Acyclic Dependencies Principle, ADP)&#x27;</strong> 입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="주-단위-빌드weekly-build"></a>주 단위 빌드(Weekly Build)<a class="hash-link" href="#주-단위-빌드weekly-build" title="Direct link to heading">#</a></h4><ul><li>주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용됩니다.<ul><li>첫 4일 동안은 작업을 하고 금요일이 되면 변경된</li></ul></li><li>5일 중 4일 동안 개발자를 고립된 세계에서 살 수 있게 보장해 주는 장점을 가집니다.</li><li>프로젝트가 커지면 프로젝트 통합은 하루만에 하기 어려워집니다.</li><li>개발보다 통합에 드는 시간이 늘어나게 되면 팀의 효율성도 나빠지게 됩니다.<ul><li>즉, 효율성을 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 통합과 테스트를 수행하기 어려워지고 팀은 빠른 피드백을 못하게 됩니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="순환-의존성-제거하기"></a>순환 의존성 제거하기<a class="hash-link" href="#순환-의존성-제거하기" title="Direct link to heading">#</a></h4><ul><li>문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것입니다.<ul><li>이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 됩니다.</li><li>개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만듭니다.</li><li>개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정하고, 나머지 개발자는 릴리스된 버전을 사용합니다.</li></ul></li><li>컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정합니다.<ul><li>적용하지 않기로 했다면 그냥 과거 버전의 릴리스를 계속 사용하고, 준비가 됬다면 새 릴리스를 사용합니다.</li></ul></li><li>작업 절차는 단순하며 합리적이라 널리 사용되는 방식입니다. 다만 의존성 구조에 <strong>순환이 있어서는 안됩니다.</strong></li><li>컴포넌트 다이어그램에서는 컴포넌트를 조립하여 애플리케이션을 만드는 다소 전형적인 구조를 볼 수 있습니다.<ul><li>중요한 점은 컴포넌트 간의 의존성 구조입니다. 이 구조는 <strong>방향 그래프(directed graph)</strong> 입니다.</li><li>컴포넌트는 정점(vertex)에 해당하고, 의존성 관계는 <strong>방향이 있는 간선(Directed Acyclic Graph, DAG)</strong> 에 해당합니다.</li></ul></li><li>더 주목할 점은 어느 컴포넌트에서 시작하더라도, 의존성 관계를 까라가면서 최초의 컴포넌트로 되돌아갈 수 없습니다. 즉, 이 구조를 <strong>비순형 방향 그래프(Directed Acyclic Graph, DAG)</strong> 라고 합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145698724-63f98b36-1486-4286-9a0c-c18fbfc2021c.png" alt="전형적인 컴포넌트 다이어그램"></p><ul><li>위 예시에서 <code>Main</code>은 새로 릴리스되더라도 시스템에서 이로 인해 영향받는 컴포넌트가 전혀 없습니다.<ul><li><code>Presenters</code>를 테스트할때는 <code>Interactors</code> 와 <code>Entites</code> 를 이용해서 <code>Presenters</code> 자체 버전을 빌드하면 됩니다.</li></ul></li><li>시스템 전체를 릴리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="순환이-컴포넌트-의존성-그래프에-미치는-영향"></a>순환이 컴포넌트 의존성 그래프에 미치는 영향<a class="hash-link" href="#순환이-컴포넌트-의존성-그래프에-미치는-영향" title="Direct link to heading">#</a></h4><ul><li>순환 참조가 있는 경우, 해당 컴포넌트의 개발자들은 모두 서로에게 얽매이기 때문에 모두 항상 정확하게 동일한 릴리스를 사용해야 하는 문제가 생깁니다.</li><li>순환이 생기면 컴포넌트를 분리하기도 어려워집니다.<ul><li>릴리스시 에러가 상당히 많아지며, 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가합니다.</li></ul></li><li>의존성 그래프에 순환이 생기면 컴포넌트를 어던 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어집니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="순환-끊기"></a>순환 끊기<a class="hash-link" href="#순환-끊기" title="Direct link to heading">#</a></h4><p>컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능합니다. 주요 메터니즘은 두가지 입니다.</p><ol><li>의존성 역전 원칙(DIP)를 적용합니다.</li><li>모두 의존하는 새로운 컴포넌트를 만듭니다.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="흐트러짐jitters"></a>흐트러짐(Jitters)<a class="hash-link" href="#흐트러짐jitters" title="Direct link to heading">#</a></h4><ul><li>두번째 해결책을 보면 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실입니자.<ul><li>즉, 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 성장합니다.</li><li>따라서 의존성 구조에 순환이 발생하는지 항상 관찰해야합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="하향식top-down-설계"></a>하향식(top-down) 설계<a class="hash-link" href="#하향식top-down-설계" title="Direct link to heading">#</a></h3><ul><li>위 내용의 결론은 컴포넌트 구조는 하향식으로 설계될 수 없습니다.<ul><li>컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화합니다.</li></ul></li><li>컴포넌트 의존성 다이어그램은 애플리케이션의 <strong>빌드 가능성(buildability)</strong> 와 <strong>유지보수성(maintainability)</strong> 을 보여주는 <strong>지도(map)</strong> 와 같습니다.<ul><li>이러한 이유는 컴포넌트 구조는 초기에 설계할 수 없습니다.</li><li>빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한지도 또한 필요없습니다.</li></ul></li><li>프로젝트가 커지면서 단일 책임 원칙(SRP)와 공통 폐쇄 원칙(CCP)에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 만듭니다.</li><li>의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일입니다.<ul><li>컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 됩니다.</li></ul></li><li>클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 실패할 가능성이 높습니다.<ul><li>재사용 가능성 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실한 순환 의존성이 발생할 것입니다.</li><li>따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="sdp-안정된-의존성-원칙"></a>SDP: 안정된 의존성 원칙<a class="hash-link" href="#sdp-안정된-의존성-원칙" title="Direct link to heading">#</a></h3><blockquote><p>안정된 방향으로 의존하라.</p></blockquote><ul><li>설계는 정적일 수 없으며, 설계를 유지하다 보면 변경은 불가피합니다.<ul><li>공통 폐쇄 원칙을 준수함으로써, 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서 특정 유형의 변경에만 민감하게 만들 수 있습니다.</li><li>컴포넌트 중 일부는 변동성을 지니도록 설계되며, 언젠간 변경됨을 예상합니다.</li></ul></li><li>변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안됩니다.<ul><li>한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워집니다.</li></ul></li><li>안전된 의존성 원칙(Stable Dependencies Principle, SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="안전성"></a>안전성<a class="hash-link" href="#안전성" title="Direct link to heading">#</a></h4><ul><li>소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것입니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145706527-e2d50b64-a7aa-47a1-bd5c-08c64dbf284d.png" alt="X는 안정된 컴포넌트"></p><ul><li>세 컴포넌트가 X에 의존합니다. X는 세 컴포넌트를 <strong>책임진다(responsible)</strong> 이라고 말합니다. 반대로 X는 어디에도 의존하지 않으므로 이 경우 X는 <strong>독립적이다(independent)</strong> 라고 말합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145706560-a31eb085-79cb-4b55-a1bf-ca018b37a064.png" alt="Y는 상당히 불안정한 컴포넌트"></p><ul><li>위 경우에는 Y는 책임성이 없고, 의존적이라고 말할 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="안정성-지표"></a>안정성 지표<a class="hash-link" href="#안정성-지표" title="Direct link to heading">#</a></h4><ul><li>컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법이 있을 수 있습니다. 이 숫자를 통해 컴포넌트가 위치상의 개수를 세어 보는 방법이 있을 수 있습니다.<ul><li><code>Fan-in</code> : 안으로 들어오는 의존성,, 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수</li><li><code>Fan-out</code> : 밖으로 나가는 의존성, 의부 클래스에 의존하는 컴포넌트 내부의 클래스 개수</li><li><code>I(불안전성)</code> : <code>I = Fan-out % (Fan-in + Fan-out)</code>, 0과 1사이의 값을 가집니다.<ul><li>0인 경우 최고의 안정된 컴포넌트, 1인 경우 최고로 불안정한 컴포넌트라는 의미입니다.</li></ul></li></ul></li><li><code>Fan-in</code>과 <code>Fan-out</code> 지표는 특정 컴포넌트 내부의 클래스에 의존하는, 컴포넌트 외부에 위치한 클래스의 개수를 세어서 계산할 수 있습니다.</li><li>컴포넌트의 <code>I</code> 지표는 그 컴포넌트가 의존하는 다른 컴포넌트의 I보다 커야합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="모든-컴포넌트가-안정적이어야-하는-것은-아니다"></a>모든 컴포넌트가 안정적이어야 하는 것은 아니다<a class="hash-link" href="#모든-컴포넌트가-안정적이어야-하는-것은-아니다" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/145708795-96db1cad-7852-43f2-80c8-597061c7bced.png" alt="SDP 위배"></p><ul><li><code>Flexible</code>은 변경하기 쉽도록 설계했지만, 의존성이 걸리므로 변경이 어려워집니다.</li></ul><blockquote><p>추상 컴포넌트</p></blockquote><ul><li>추상 컴포넌트는 상당히 안정적이며, 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상입니다.</li><li>루비나 파이썬 같은 동적 타입 언어를 사용할 때는 이러한 추상 컴포넌트가 전혀 존재하지 않을 뿐만 아니라, 추상 컴포넌트로 향하는 의존성은 없습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="sap-안정된-추상화-원칙"></a>SAP: 안정된 추상화 원칙<a class="hash-link" href="#sap-안정된-추상화-원칙" title="Direct link to heading">#</a></h3><blockquote><p>컴포넌트는 안정된 정도만큼만 추상화되어야 합니다.</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="고수준-정책을-어디에-위치시켜야-하는가"></a>고수준 정책을 어디에 위치시켜야 하는가?<a class="hash-link" href="#고수준-정책을-어디에-위치시켜야-하는가" title="Direct link to heading">#</a></h4><ul><li>시스템에는 자주 변경해서는 절대 안되는 소프트웨어도 존재합니다.<ul><li>ex) 고수준 아키텍처나 정책 결정과 관련된 소프트웨어</li><li>불안정한 컴포넌트(I=1)는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 합니다.</li></ul></li><li>고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기가 어려워집니다.<ul><li>이로 인해 시스템 전체 아키텍처가 유연성을 잀습니다.</li></ul></li><li>컴포넌트가 최고로 안정된 상태이면서도(I=0) 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있는 방법이 필요합니다.<ul><li>이를 <strong>개방 폐쇄 원칙(OCP)</strong> 에서 찾을 수 있습니다.</li><li>추상 클래스가 이러한 원칙을 준수합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="안정된-추상화-원칙"></a>안정된 추상화 원칙<a class="hash-link" href="#안정된-추상화-원칙" title="Direct link to heading">#</a></h4><ul><li>안정된 추상화 원칙(Stable Abstraction Principle, SAP)는 안정성(Stability)와 추상화 정도(abstractness) 사이의 관계를 정의합니다.</li><li>안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 합니다.<ul><li>안정한 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 됩니다.</li></ul></li><li>SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 됩니다.<ul><li>의존성은 추상화의 방향으로 향하게 됩니다.</li></ul></li><li>DIP는 클래스에 대한 원칙이며, 클래스는 추상적이거나 아니거나입니다.<ul><li>SDP와 SAP의 조합은 컴포넌트에 대한 원칙이며, 컴포넌트는 어떤 부분은 추상적이면서 다른 부분은 안정적일 수도 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="추상화-정도-측정하기"></a>추상화 정도 측정하기<a class="hash-link" href="#추상화-정도-측정하기" title="Direct link to heading">#</a></h4><ul><li>A 지표는 컴포넌트의 추상화 정도를 측정한 값입니다. 이 값은 컴포넌트의 클래스 총 수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값입니다.<ul><li>Nc: 컴포넌트의 클래스 개수</li><li>Na: 컴포넌트의 추상 클래스와 인터페이스의 개수</li><li>A: 추상화 정도, A = Na % Nc</li></ul></li><li>A 지표는 0과 1 사이의 값을 가지며 0이면 컴포넌트에 추상 클래스가 없다는 뜻이고 A가 1이면 오로지 추상 클래스만을 포함합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="주계열"></a>주계열<a class="hash-link" href="#주계열" title="Direct link to heading">#</a></h4><ul><li>안정성(I)와 추상화 정도(A) 사이의 관계를 정의해야 합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145711739-5d4eb539-757c-4116-ab03-cb88b9e58338.png" alt="배제 구역, Zone of Exclusion"></p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="고통의-구역"></a>고통의 구역<a class="hash-link" href="#고통의-구역" title="Direct link to heading">#</a></h5><ul><li>제대로 설계된 컴포넌트라면 근체에는 위치하지 않을 거라고 보는 게 일반적입니다.</li><li>(0, 0) 구역은 배제해야할 구역이며, 고통의 구역이라고 부릅니다.</li><li>종종 소프트웨어 엔티티는 고통의 구역에 위치합니다. 특히 데이터베이스 스키마는 변동성이 높기로 유명하며 구체적이며, 많은 컴포넌트가 여기에 의존하였습니다.</li><li>변동성이 없는 컴포넌트는 (0, 0) 구역에 위치했더라도 해롭지 않습니다.</li></ul><p>즉, 고통의 구역에서 문제가 되는 경우는 변동성이 있는 소프트웨어 컴포넌트입니다.</p><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓸모없는-구역"></a>쓸모없는 구역<a class="hash-link" href="#쓸모없는-구역" title="Direct link to heading">#</a></h5><ul><li>(1, 1) 구역은 추상적이지만, 누구도 그 컴포넌트에 의존하지 않기 때문입니다. 따라서 이 영역은 쓸모없는 구역이라고 부릅니다.</li><li>이 코드는 누구도 구현하지 않은채 남겨진 추상 클래스인 경우가 많습니다.</li><li>쓸대없는 구역 내부 깊숙이 자리 잡은 컴포넌트은 이러한 엔티티의 상당부분을 포함할 가능성이 높습니다.</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="배제-구역-벗어나기"></a>배제 구역 벗어나기<a class="hash-link" href="#배제-구역-벗어나기" title="Direct link to heading">#</a></h5><ul><li>변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 멀리 떨어트려야 합니다.</li><li>주 계역에 위치하는 컴포넌트는 자신의 안전성에 비해 너무 추상적이지 않고, 추상화 정도에 비해 너무 불안정하지도 않습니다.</li><li>컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계역의 두 종점입니다.<ul><li>뛰어난 아키텍트라면 대다수의 컴포넌트가 두 종점에 위치하도록 만듭니다.</li></ul></li><li>컴포넌트는 주계열 바로 위 또는 가갑게 위치할 때 가장 이상적입니다.</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="주계열과의-거리"></a>주계열과의 거리<a class="hash-link" href="#주계열과의-거리" title="Direct link to heading">#</a></h5><ul><li>위에서 세 번째 지표가 도출됩니다.<ul><li>D: 거리, D = |A + I - 1|</li><li>D가 0이면 컴포넌트가 주계역 바로 위에 위치한다는 뜻이며, 1이면 주계열로부터 가장 멀리 위치한다는 뜻입니다.</li></ul></li><li>D에 가깝지 않는 컴포넌트가 있다면 해당 컴포넌트는 재검토한 후 재 구성할 수 있습니다.</li><li>극히 예외적인 컴포넌트를 식별할 수 있습니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/145713484-59dd57b1-7ed6-462b-92bd-ed83a4760b48.png" alt="컴포넌트 산점도"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-2"></a>결론<a class="hash-link" href="#결론-2" title="Direct link to heading">#</a></h3><ul><li><strong>의존성 관리 지표</strong>는 설게의 의존성과 추상화 정도가 &#x27;훌륭한&#x27; 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정합니다.</li><li>좋은 의존성도 있으며 나쁜 의존성도 있습니다.</li><li>지표는 일정의 평가 지표이며 이또한 불완전한 정보입니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/clean-architecture/ch4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-05-08T05:57:51.000Z" class="lastUpdatedDate_1WI_">5/8/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/clean-architecture/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 3. 설계 원칙</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/clean-architecture/ch5"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">5. 아키텍처 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#12장-컴포넌트" class="table-of-contents__link">12장. 컴포넌트</a><ul><li><a href="#컴포넌트의-간략한-역사" class="table-of-contents__link">컴포넌트의 간략한 역사</a></li><li><a href="#재배치성" class="table-of-contents__link">재배치성</a></li><li><a href="#링커" class="table-of-contents__link">링커</a></li><li><a href="#결론" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#13장-컴포넌트-응집도" class="table-of-contents__link">13장. 컴포넌트 응집도</a><ul><li><a href="#rep-재사용릴리스-등가-원칙" class="table-of-contents__link">REP: 재사용/릴리스 등가 원칙</a></li><li><a href="#ccp-공통-폐쇄-원칙" class="table-of-contents__link">CCP: 공통 폐쇄 원칙</a></li><li><a href="#crp-공통-재사용-원칙" class="table-of-contents__link">CRP: 공통 재사용 원칙</a></li><li><a href="#컴포넌트-응집도에-대한-균형-다이어그램" class="table-of-contents__link">컴포넌트 응집도에 대한 균형 다이어그램</a></li><li><a href="#결론-1" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#14장-컴포넌트-결합" class="table-of-contents__link">14장. 컴포넌트 결합</a><ul><li><a href="#adp-의존성-비순환-원칙" class="table-of-contents__link">ADP: 의존성 비순환 원칙</a></li><li><a href="#하향식top-down-설계" class="table-of-contents__link">하향식(top-down) 설계</a></li><li><a href="#sdp-안정된-의존성-원칙" class="table-of-contents__link">SDP: 안정된 의존성 원칙</a></li><li><a href="#sap-안정된-추상화-원칙" class="table-of-contents__link">SAP: 안정된 추상화 원칙</a></li><li><a href="#결론-2" class="table-of-contents__link">결론</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.e80812b4.js"></script>
<script src="/til/assets/js/main.cea52fe2.js"></script>
</body>
</html>