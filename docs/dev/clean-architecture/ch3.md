---
sidebar_position: 3
---

# 3. 설계 원칙

## 7장. SRP: 단일 책임 원칙

- SRP는 헷갈리기 쉽습니다.
- **단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 합니다.**
- 이를 다르게 말하면 **하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 합니다.**
- SRP의 최종적으로 정리는 다음과 같습니다.
  - **하나의 모듈은 하나의 오직 하나의 액터에 대해서만 책임져야 합니다.**
- '모듈'은 간단하게 이야기 하면 대부분은 소스 파일이고, 단순히 함수와 데이터 구조로 구성된 응집된 결합입니다.
- SRP를 잘 이해하는 방법 중 하나는 원칙을 위반하는 징후를 확인하는 것입니다.

### 징후 1: 우발적 중복

![우발적 중복](https://user-images.githubusercontent.com/42582516/143684221-bbf791af-3ed5-49fe-b3f1-05dfc08e9997.png)

- SRP를 위반하며, 세가지 메서드가 세명의 액터를 책임지는 문제가 있습니다.
- 이후 작업을 했을 때, 이러한 변경사항이 다른 문제를 만들게 됩니다.
  - 즉, CFO를 위해 수정을 했으나 변경을 희망하지 않는 COO가 변경될 수 있습니다.

### 징후 2: 병합

- 소스 파일에 다양하고 많은 메서드를 포함하면 병함이 자주 발생하리라고 짐작하기는 어려운 일은 아닙니다.
  - 특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 확실히 더 높습니다.
- 병합은 항상 위험이 뒤따르게 됩니다.
- 이를 해결하는 방법은 **서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것**입니다.

### 해결책

- 이 문제의 해결책은 여러 방법이 있습니다.
- 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식입니다.

![세 클래스는 서로의 존재를 알지 못합니다.](https://user-images.githubusercontent.com/42582516/143684752-05825fd9-f0cb-49f3-8e22-3e746c8dee8e.png)

- 다만 위 해결책은 세가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점입니다.
- 이를 해결하기 위한 방법으로 **퍼사드(Facade)** 패턴이 있습니다.

![퍼사드 패턴](https://user-images.githubusercontent.com/42582516/143684916-15359a25-5151-4ae3-a559-b57f538a4c14.png)

- 가장 중요한 메서드를 기존 Employee에 넣고 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있습니다.

![덜 중요한 메서드를 퍼사드 패턴](https://user-images.githubusercontent.com/42582516/143685025-b39911a6-f713-49cf-8986-a67110828f8b.png)

### 결론

- 단일 책임 원칙은 메서드와 클래스 수준의 원칙입니다.
- 컴포넌트 수준에서는 **공통 폐쇄 원칙(Common Closure Principle)** 이 됩니다.
- 아키텍처 수준에서는 **아키텍처 경계(Architectural Boundary)** 의 생성을 책임지는 변경의 축이 됩니다.

<br/>

## 8장. OCP : 개방-폐쇄 원칙

<br/>

## 9장. LSP : 리스코프 치환 원칙

<br/>

## 10장. ISP : 인터페이스 분리 원칙

<br/>

## 11장 DIP : 의존성 역전 원칙
