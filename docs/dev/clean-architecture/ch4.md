---
sidebar_position: 4
---

# 4. 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 아려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 알려줍니다.

## 12장. 컴포넌트

- 컴포넌트는 배포 단위며, 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위입니다.
  - 자바의 경우 jar 파일, 루비는 gem 파일, 닷넷은 DLL입니다.
  - 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체입니다.
  - 인터프리터형 언어의 경우는 소스 파일의 결합체입니다.
- 여러 머포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있습니다.
  - 여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로 만들 수 잇습니다.
  - 컴포넌트 각각을 .jar 이나 .dll 같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어서 독립적으로 배포할 수 있습니다.
  - **컴포넌트**가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 **독립적으로 배포 가능**한, **독립적으로 개발 가능한 능력을 갖춰야 합니다.**

### 컴포넌트의 간략한 역사

- 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했습니다.
  - 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정할 사항 중 하나 였습니다.
  - 장치가 느리고 메모리가 바싸서 자원이 한정적이였습니다.
- 오늘날은 프로그램을 메모리의 어느 위치에 로드할지 고민할 필요가 거의 없습니다.

![초기의 메모리 배치](https://user-images.githubusercontent.com/42582516/145665076-ad012b0c-509e-45ef-8a2d-566a94b3cc87.png)

- 프로그램과 라이브러리가 사용하는 메모리가 늘수록 위의 단편화가 게속되므로 문제가 있었습니다.

### 재배치성

- 해결책은 **재배치가 가능한 바이너리(relocatable binary)** 였습니다.
  - 지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것입니다.
- 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었습니다.
  - 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었습니다.
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었스빈다.
  - 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 **외부 참조(external reference)** 로 생성했습니다.
  - 라이브러리 함수를 정의하는 프로그램이라면 이름을 **외부 정의(external definition**) 로 생성했습니다.
  - 이렇게 함으로 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 되는 **링킹 로더(linking loader)** 가 탄생했습니다.

### 링커

- 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었습니다.
- 그러나 프로그램이 커지게되며 링킹 로더가 너무 느려지는 문제가 발생했습니다.
- 이를 해결하기 위해 **로드**와 **링크**로 분리되었습니다.
  - 느린 링크 과정을 해결하기 위해 **링커(linker)** 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었습니다.
  - 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌습니다.
- 1980년대가 되며 C와 같은 고수준 언어를 사용하게 되며 프로그램이 더 커졌습니다.
- 소스 모듈은 .c파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어졌습니다.
  - 각 모듈은 컴파일하는 과정은 상대적으로 빨랐지만, **전체** 모듈을 컴파일 하는 일은 꽤 시간이 걸렸습니다.
  - 로드 시간은 빨랐지만 컴파일-링크 시간이 병목 구간이 있었습니다.
- 그 이후 디스크가 적어지고, 컴퓨터 메모리 또한 저렴해졌으며, 컴퓨터 클록 속도 또한 증가했습니다.
  - 1990년대 후반이 되자 프로그래머가 프로그램 성장시키는 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌습니다.
- 이후에는 .jar 파일도 등장했으며 컴퓨터와 장치가 빨려져서 로드와 링크를 동시에 할 수 있게 되었고 다수의 .jar 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었습니다.
  - 이렇게 컴포넌트 플러그인 아키텍처(component plugin architecture)가 탄생했습니다.
- 오늘날은 .jar 파일, DLL, 공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것이 일상적인 일이 되었습니다.

### 결론

런타임에 플러그인 형태로 결합할 수 잇는 동적 링크 파일이 이 책에서 이야기하는 소프트웨어 컴포넌트에 해당합니다. 이 과정이 50년입니다.

<br/>

## 13장. 컴포넌트 응집도

컴포넌트 응집도에 관련된 세 가지 원칙이 있습니다.

- REP: 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)
- CCP: 공통 폐쇄 원칙(Common Closure Principle)
- CRP: 공통 재사용 원칙(Common Reuse Principle)

### REP: 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같습니다.

- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용할 수 없습니다.
- 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는 지 보증할 방법이 전혀 없습니다.
- 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 의미합니다.
  - 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 합니다.
- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 **릴리스할 수 있어야 합니다.**
- 이 조건으로만 클래스와 모듈을 묶는 방법을 설명하기 힘들기에 조건이 약합니다.
  - 즉, 이 원칙을 어기면 '이치에 맞지' 않게 됩니다.
- 이 원칙의 **약점**은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있습니다.
  - CCP와 CRP는 REP를 엄격하게, 제약을 가하는 측면에서 정의합니다

### CCP: 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶습니다. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리합니다.

- 이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴것입니다.
  - SRP에서 단일 **클래스(class)** 는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, **공통 폐쇄 원칙(CCP)** 에서도 마찬가지로 단일 **컴포넌트(component)** 는 변경의 이유가 여러 개 있어서는 안 된다고 말합니다.
- 대다수의 애플리케이션에서 **유지보수성(maintainability)** 은 재사용성보다 훨씬 중요합니다.
  - 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫습니다.
  - 변경을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 됩니다.
- CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권합니다.
  - 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야합니다.
  - 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있습니다.
- 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀 있도록 설계합니다.
- CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로서, 변경이 필요한 요구사항이 발상할 때 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아집니다.

#### SRP와의 유사성

- CCP는 컴포넌트 수준의 SRP입니다.

> 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리합니다.

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 않습니다.

- 공통 재사용 원칙(CRP)도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙입니다.
  - CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말합니다.
- 개별 클래스가 단독으로 재사용되는 경우는 거의 없습니다.
  - 일반적으로는 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 사용작용하는 경우가 많습니다.
  - 컴포넌트 내부에서는 클래스들 사이에 수많은 의존성이 있으리라고 예상할 수 있습니다.
- 간단한 예시로 컨테이너(container) 클래스와 해당 클래스의 이터레이터(iterator) 클래스를 들 수 있으며 강결합되어 있기에 함께 재사용됩니다. 즉, 이 클래스들은 반드시 동일한 컴포넌트에 위치해야 합니다.
- CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 알려줍니다.
  - 컴포넌트가 다른 컴포넌트를 사용하면 두 컴포넌트 사이는 의존성이 생깁니다.
  - 이러한 의존성이 있는 경우, 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트를 변경하거나 재컴파일, 재검증, 재배포 가능성이 남아있습니다.
- 의존하는 컴포넌트가 있다면 핻아 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야합니다.
- CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 묶어서 안되는지에 대해서 훨씬 더 많은 것을 이야기합니다.
  - CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 이야기합니다.

#### ISP와의 관계

CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전입니다.

- ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언하며, CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언합니다.

> 필요하지 않은 것에 의존하지 않습니다.

### 컴포넌트 응집도에 대한 균형 다이어그램

- 응집도에 관한 세 원칙은 상충됩니다.
- REP와 CCP는 **포함(inclusive)** 원칙이며, 컴포넌트를 더욱 크게 만듭니다.
- CRP는 **배제(exclusive)** 원칙이며, 컴포넌트를 더욱 작게 만듭니다.

![결합도 원칙들의 균형 다이어그램](https://user-images.githubusercontent.com/42582516/145679950-6d46552b-e2f1-40ca-a0a8-9e0a7b87270e.png)

- REP와 CRP에만 중점을 두면 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미치며 반대로 CCP나 REP에만 과도하게 집중되면 불필요한 릴리스가 너무 빈번해집니다.
- 뛰어난 아키텍트라면 이 균형 삼각형에서 개발팀이 **현재** 관심을 기울이는 부분을 **충족**시키는 위치를 찾아야하며, 시간이 흐르면서 우선순위가 바뀌는 부분도 인지해야합니다.
  - 초기에는 CCP가 REP보다 훨씬 중요합니다. (개발가능성이 재사용성보다 중요하므로)
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 오직 재사용성만 희생하면 됩니다.
  - 프로젝트가 성숙해지고 파생된 또 다른 프로젝트가 시작되면서 프로젝트는 삼각형에서 점차 왼쪽으로 이동합니다.
  - 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변합니다.

### 결론

- 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 합니다.
- 이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요합니다.

시간에 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화합니다.

<br/>

## 14장. 컴포넌트 결합
