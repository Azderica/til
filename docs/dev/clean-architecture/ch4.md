---
sidebar_position: 4
---

# 4. 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 아려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 알려줍니다.

## 12장. 컴포넌트

- 컴포넌트는 배포 단위며, 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위입니다.
  - 자바의 경우 jar 파일, 루비는 gem 파일, 닷넷은 DLL입니다.
  - 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체입니다.
  - 인터프리터형 언어의 경우는 소스 파일의 결합체입니다.
- 여러 머포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있습니다.
  - 여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로 만들 수 잇습니다.
  - 컴포넌트 각각을 .jar 이나 .dll 같이 동적으로 로드할 수 있는 플러그인이나 .exe 파일로 만들어서 독립적으로 배포할 수 있습니다.
  - **컴포넌트**가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 **독립적으로 배포 가능**한, **독립적으로 개발 가능한 능력을 갖춰야 합니다.**

### 컴포넌트의 간략한 역사

- 소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했습니다.
  - 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정할 사항 중 하나 였습니다.
  - 장치가 느리고 메모리가 바싸서 자원이 한정적이였습니다.
- 오늘날은 프로그램을 메모리의 어느 위치에 로드할지 고민할 필요가 거의 없습니다.

![초기의 메모리 배치](https://user-images.githubusercontent.com/42582516/145665076-ad012b0c-509e-45ef-8a2d-566a94b3cc87.png)

- 프로그램과 라이브러리가 사용하는 메모리가 늘수록 위의 단편화가 게속되므로 문제가 있었습니다.

### 재배치성

- 해결책은 **재배치가 가능한 바이너리(relocatable binary)** 였습니다.
  - 지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것입니다.
- 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었습니다.
  - 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었습니다.
- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었스빈다.
  - 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 **외부 참조(external reference)** 로 생성했습니다.
  - 라이브러리 함수를 정의하는 프로그램이라면 이름을 **외부 정의(external definition**) 로 생성했습니다.
  - 이렇게 함으로 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 되는 **링킹 로더(linking loader)** 가 탄생했습니다.

### 링커

- 링킹 로더의 등장으로 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었습니다.
- 그러나 프로그램이 커지게되며 링킹 로더가 너무 느려지는 문제가 발생했습니다.
- 이를 해결하기 위해 **로드**와 **링크**로 분리되었습니다.
  - 느린 링크 과정을 해결하기 위해 **링커(linker)** 라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었습니다.
  - 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌습니다.
- 1980년대가 되며 C와 같은 고수준 언어를 사용하게 되며 프로그램이 더 커졌습니다.
- 소스 모듈은 .c파일에서 .o 파일로 컴파일된 후, 링커로 전달되어 빠르게 로드될 수 있는 형태의 실행 파일로 만들어졌습니다.
  - 각 모듈은 컴파일하는 과정은 상대적으로 빨랐지만, **전체** 모듈을 컴파일 하는 일은 꽤 시간이 걸렸습니다.
  - 로드 시간은 빨랐지만 컴파일-링크 시간이 병목 구간이 있었습니다.
- 그 이후 디스크가 적어지고, 컴퓨터 메모리 또한 저렴해졌으며, 컴퓨터 클록 속도 또한 증가했습니다.
  - 1990년대 후반이 되자 프로그래머가 프로그램 성장시키는 속도보다 링크 시간이 줄어드는 속도가 더 빨라졌습니다.
- 이후에는 .jar 파일도 등장했으며 컴퓨터와 장치가 빨려져서 로드와 링크를 동시에 할 수 있게 되었고 다수의 .jar 파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었습니다.
  - 이렇게 컴포넌트 플러그인 아키텍처(component plugin architecture)가 탄생했습니다.
- 오늘날은 .jar 파일, DLL, 공유 라이브러리를 기존 애플리케이션에 플러그인 형태로 배포하는 것이 일상적인 일이 되었습니다.

### 결론

런타임에 플러그인 형태로 결합할 수 잇는 동적 링크 파일이 이 책에서 이어ㅑ기하는 소프트웨어 컴포넌트에 해당합니다. 이 과정이 50년입니다.

<br/>

## 13장. 컴포넌트 응집도

<br/>

## 14장. 컴포넌트 결합
