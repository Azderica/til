---
sidebar_position: 6
---

# 6. 세부사항

## 30장. 데이터베이스는 세부사항이다

- 아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아닙니다.
  - 즉, 데이터베이스는 세부사항이라 아키텍처의 구성요소 수준으로 끌어올릴 수 없습니다.
- 데이터베이스는 데이터 모델이 아닌 일개 소프트웨어일 뿐입니다.

### 관계형 데이터베이스

- 관계형 데이터베이스의 원칙을 정으히ㅏ고, 관계형 모델은 계속 성장합니다.
- 관리형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리하지만, 데이터를 테이블에 핻 단위로 배치한다는 자체는 아키텍처적으로는 전혀 중요하지 않습니다.

### 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?

- 데이터베이스는 디스크를 통해 데이터 저장소의 중심이 되었습니다.
- 그러나, 디스크 때문에 피해갈 수 없는 시간 지연이 생겼고 이를 완화하기 위해 색인, 캐시, 쿼리 최적화가 필요했습니다.
  - 이를 할려면 데이터가 어떤 데이터인지를 알아야했고, 이에 따라 데이터 접근 및 관리시스템이 필요했습니다.
  - 이 시스템은 파일 시스템과 관계형 데이터베이스 관리 시스템(RDBMS)이 되었습니다.
- 데이터베이스 시스템은 내용 기반입니다. 데이터베이스 시스템은 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공합니다.- 이 두 시스템은 데이터를 디스크에 체계화해서, 각 시스템에 특화된 방식을로 접근해야 할 때 가능한 효율적으로 데이터를 저장하고 검색할 수 있게 합니다.

### 디스크가 없다면 어떻게 될까

- 그러나 최근 추세는 디스는 RAM으로 대체되고 있습니다.
- 데이터를 저장할 때는 연결 리스트, 트리, 해시 테이블, 스택, 큐와 같은 무수히 많은 데이터구조로 체계화하여 저장하며, 이는 **프로그래머가 하는 일**입니다.

### 세부사항

- 데이터베이스가 세부사항인 이유는 이러한 현실 때문입니다.
- 데이터베이스는 메커니즘에 불과하며, 디스크와 RAM 사이에서 데이터를 옮길 때 사용할 뿐입니다.

### 하지만 성능은?

- 데이터 저장소의 측면에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사입니다.
- 성능은 시스템의 번반적인 아키텍처와는 아무런 관련이 없습니다.

### 개인적인 일화

- '엔터프라이즈'라는 단어와 '서비스-지향 아키텍처'라는 개념은 현실보다는 마케팅과 더 관련이 깊습니다.

### 결론

- 체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요합니다.
- 데이터를 테이블 구조로 만들고 SQL로만 접근하도록 하는 관계형 데이터베이스 시스템은 전자보다는 후자와 훨씬 관련이 깊습니다.
- 데이터는 중요하며, 데이터베이스는 세부사항입니다.

<br/>

## 31장. 웹은 세부사항이다

- 사실 웹이 바꾼 것은 없습니다.

### 끝없이 반복하는 추

- 앱의 아키텍트와 UI와 업무 규칙을 서로 격리하면 좋습니다.

### 요약

- 요약하면 GUI는 세부사항입니다.
- 웹을 다른 측면으로 보면, 입출력 장치입니다.
- 각 유즈케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 간주할 수 있습니다.

### 결론

- 추상화는 어려우며 제대로 만들려면 수차례의 반복 과정이 필요합니다.

<br/>

## 32장. 프레임워크는 세부사항이다

프레임워크는 강력하며 유용하지만 아키텍처가 될 수 없습니다.

### 프레임워크 제작자

- 프레임워크는 커뮤니티에 도움이 되기를 바라는 마음에 제공하지만, 이는 다른 사람의 관심사를 반영하지 않은 부분입니다.
- 다만, 겹치는 영역이 크면 클수록 프레임워크는 실제로 더 유용해집니다.

### 혼인 관계의 비대칭성

- 프레임워크는 애플리케이션이 결합되게 만듭니다. 또한 이러한 결합은 관계를 깨기가 어렵습니다.
- 이러한 결합 관계는 일방적이며, 이를 진행하는 개발자가 취험과 부담을 가져야합니다.

### 위험 요인

고려해야할 위험 요인은 다음과 같습니다.

- 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많습니다.
- 프레임워크는 애플리케이션의 초기 기능을 만드는 데 도움이 됩니다.
- 프레임워크는 당신에게 도움되지 않는 방향으로 진화할 수도 있습니다.
- 새롭고 더 나은 프레임워크가 등장하여 바꾸고 싶습니다.

### 해결책

- 해결책은 `프레임워크와 결합해서는 안됩니다.`
- 업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면 거절합니다.
- 프레임워크가 핵심 코드 안으로 들어오지 못하게 합니다.
  - 즉, `의존성 규칙을 준수해야합니다`.
- 대표적인 예시로 스프링의 `@autowired` 어노테이션은 업무 객체 도처에 산재해서는 안됩니다.
  - 이보다는 메인에서 의존성을 주입하는 것이 맞습니다.

### 이제 선언합니다.

- 그러나 C++과 STL 관계는 뗄 수 없습니다. 즉, 표준 라이브러리와는 반드시 결합해야합니다.
- 이러한 관계는 정상적이나 항상 `선택적`인 것을 알고 있어야합니다. 가볍게 선택하지 않는 것이 좋습니다.

### 결론

- 프레임워크와 처음부터 결합하려 하지 않습니다.
- 가능한 오랫동안 아키텍처 경계 너머에 두는 것이 필요합니다.

<br/>

## 33장. 사례 연구: 비디오 판매

- 뛰어난 아키텍트가 일을 처리하는 과정과 결정은 다음과 같습니다.

### 제품

웹 사이트에서 비디어를 판매하는 소프트웨어 예시입니다. 아래는 그 요구사항입니다.

- 판매하길 원하는 비디오들이 있고, 이를 개인과 기업에게 웹을 통해 판매하는 사이트입니다.
- 개인은 단품 가격을 지불해 스트리밍으로 보거나, 더 높은 가격으로 비디오를 다운로드해서 영구 소장이 가능하빈다.
- 기업용 라이선스는 스트리밍 전용이며, 대량 구매를 하면 할인을 받을 수 있습니다.
- 일반적으로 개인은 시청자인 동시에 구매자이며, 기업은 다른 사람들이 신청할 비디오를 구매하는 사람이 따로 있습니다.
- 비디오 제작자는 비디오 파일과 바디오에 대한 설명서, 부속 파일을 제공해야 합니다.
- 부속 파일에는 시험, 문제, 해법, 소스 코드 등이 포함됩니다.
- 관리자는 신규 비디오 시리즈물을 추가하거나 기존 시리즈물에 비디오를 추가/삭제하며 다양한 라이선스에 맞춰 가격을 측정합니다.

### 유스케이스 분석

첫 단계는 액터와 유스케이스를 식별해야 합니다.

![유즈케이스 분석](https://user-images.githubusercontent.com/42582516/148851150-52ff9abe-61c2-4fc7-91fc-40118930898e.png)

점선으로 표시된 추상 유스케이스는 점용적인 정책을 가지고 있으며, 다른 유스케이스에서 이를 더 구체화합니다.

### 컴포넌트 아키텍처

이를 바탕으로 예비 단계의 컴포넌트 아키텍처를 만들 수 있습니다.

![예비 단계 컴포넌트 아키텍처](https://user-images.githubusercontent.com/42582516/148852225-4926856e-f5d7-4b0e-8fc4-e5e51fef8fa2.png)

- 뷰(View), 프레젠터(Presenter), 인터랙터(Interactor), 컨트롤러(Controller) 로 분리된 전형적인 분할 방법을 확인할 수 있습니다.
- 이중선은 아키텍처 경계를 나타냅니다.
- 다만 이를 분할해서 여러개의 .jar 파일을 만들 지, 더 크게 혹은 더 작게 할 수도 있습니다. 이처럼 선택지를 열어두면 시스템이 변경되는 양상에 맞춰 시스템 배포 방식을 조정할 수 있습니다.

### 의존성 관리

- 위의 그림에서 제어 흐름은 오른쪽에서 왼쪽으로 이동합니다.
- 그러나 모든 화살표가 오른쪽에서 왼쪽을 가리키지는 않습니다. 모든 의존성은 더 높은 수준의 정책을 포함하는 컴포넌트를 향합니다.
- 사용 관계(열린 화살표)는 제어흐름과 같은 방향을 가리키며, 상속 관계(닫힌 화살표)는 제어흐름과는 반대 방향을 가리킵니다. 이는 **개방 폐쇄 원칙을 적용한 것**입니다.
  - 이를 통해 저수준의 세부사항 변경이 상위로 파급되어서 상위 수준의 정책에 영향을 미치지 않음을 보장할 수 있습니다.

### 결론

- 아키텍처 다이어그램은 **단일 책임 원칙에 기반한 액터의 분리** 개념과 **의존석 규칙**의 개념을 가지고 있습니다.
- 서로 다른 이유라는 것은 액터와 관련이 있으며, 서로 다른 속도라는 것은 정책 수준과 관련이 있습니다.
- 코드를 한번 구조화하고 나면 시스템을 실제로 배포하는 방식은 다양하게 선택할 수 있게 됩니다.

<br/>

## 34장. 빠져 있는 장
