---
sidebar_position: 5
---

# 5. 아키텍처

## 15장. 아키텍처란?

- 소프트웨어 아키텍처는 코드와 동떨어져서는 안됩니다.
- 소프트웨어 시스템의 아키텍처란 시스템을 구축했던 사람들이 만들어낸 시스템의 형태입니다.
  - 그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해집니다.
- 시스템의 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽개 개발, 배포, 운영, 유지보수되도록 만들어집니다.

> > 이러한 일을 용이하게 만들기 위해서는 가능한 많은 선택지를, 가능한 오래 남겨두는 전략을 따라야 합니다.

- 시스템 아키텍처는 시스템의 동작 여부와 거의 상관이 없습니다.
  - 아무런 역할을 하는 것은 또 아닙니다. 이 역할은 수동적이며 피상적인 것이지, 능동적이거나 본질적인 것은 아닙니다.
- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것입니다.
  - 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해줍니다.
  - 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성을 최대화하는 데 있습니다.

### 개발

- 개발하기 힘든 시스템이라면 수명이 길지도 않고 건강하지도 않을 것입니다. 따라서 **시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷 받침해야만 합니다.**
- 개발팀이 여러개로 될 수록, 시스템을 신뢰할 수 있고 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않습니다. 이 경우, 시스템의 아키텍처는 팀의 갯수만큼의 컴포넌트로 발전될 가능성이 높습니다.
- 위의 '팀별 단일 컴포넌트' 아키텍처가 시스템을 배포, 운영, 유지보수하는 데 최적일 가능성은 거의 없습니다.
  - 일정에 쫓겨 일한다면 이 아키텍처로 귀착될 예정입니다.

### 배포

- 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 합니다.
  - 배포 비용이 높을수록 시스템의 유용성은 떨어집니다.
  - 소프트웨어 아키텍처는 시스템을 **단 한번에** 싑게 배포할 수 있도록 만드는 데 그 목표를 두어야 합니다.
- 초기 개발 단계에서는 배포 전략을 거의 고려하지 않기 때문에, 개발하기는 쉬울지 몰라도 배포하기는 어려운 아키텍처가 만들어집니다.
- 아키텍처가 배포 문제를 초기에 고려했다면, 다른 결정을 내릴 것입니다.

### 운영

- 아키텍처가 시스템 운영에 미치는 영향은 개발, 배포, 유지보수에 미치는 영향보다는 덜 극적입니다.
  - 운영에서 대다수의 어려움은 하드웨어를 더 투입해서 해결할 수 있습니다.
- 소프트웨어 아키텍처가 비효율적이라면 단순히 스토리지와 서버를 추가하는 것만으로 제대로 동작하도록 만들 수 있을 대가 많습니다.
- 시스템을 쉽게 운영하게 해주는 아키텍처가 바람직하지 않다는 말이 아니며 이러한 아키텍처는 바람직합니다. 다만 비용 공식 관점에서 운영보다는 개발, 배포, 유지보수 쪽으로 더 기웁니다.
- 좋은 소프트웨어 아키텍처는 시스템을 우녕하는 데 필요한 요구도 알려줍니다.
- 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급(first-class) 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야 합니다.
  - 시스템을 이해하기 쉬워지며, 개발과 유지보수에 큰 도움이 됩니다.

### 유지보수

- 모든 측면에서 봤을 때 소프트웨어 시스테멩서 비용이 가장 많이 발생합니다.
  - 새로운 기능과, 뛰따라 발생하는 결함, 결함을 수정하는 인적 자원 소모 등이 있습니다.
- 유지보수의 가장 큰 비용은 **탐사(spelunking)** 와 이로 인한 위험부담이 있습니다.
  - 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 대, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 경정할 때 드는 비용입니다.
  - 이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로 인한 위험부담 비용이 추가됩니다.
- 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있습니다.
  - 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리합니다.

### 선택사항 열어 두기

- 소프트웨어는 행위적 가치와 구조적 가치를 지닙니다. 이중에서 두 번째 가치가 더 중요한데, 소프트웨어를 **부드럽게(soft)** 만드는 것은 바로 구조적 가치입니다.
- 소프트웨어를 만든 이유는 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요하기 때문입니다.
  - 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존합니다.
- 소프트웨어를 부드럽게 유지하는 방법은 서택사항을 가능한 많이, 그리고 가능한 오랫동안 열어 두는 것입니다.
  - 열어 둬야 할 선택사항은 **중요하지 않은 세부사항**을 의미합니다.
- 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있습니다. 즉, 정책과 세부사항입니다.
  - 정책 요소는 모든 업무 규칙과 업무 절차를 구체화합니다. 즉, 시스템의 진정한 가치가 살아있습니다.
  - 세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소이며, 정책이 가진 행위에는 조금도 영향을 미치지 않습니다. 예시로 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있습니다.
- 아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 **무관하게** 만들 수 있는 형태의 시스템을 구축하는 데 있습니다. 이를 통해 세부사항을 결정하는 일은 **미루거나 연기**할 수 있게 됩니다.
  - 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없습니다.
  - 개발 초기에는 웹 서버를 선택할 필요가 없습니다.
    - **시스템을 웹을 통해 전송할 것인지조차도 결정할 필요가 없습니다.**
  - 개발 초기에는 REST를 적용할 필요가 없습니다.
  - 개발 초기에는 의존성 주입(DI) 프레임워크를 적용할 필요가 없습니다.
    - 고수준의 정책은 의존성을 해석하는 방식에 대해 신경 써서는 안됩니다.
- 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있습니다.
  - 이러한 결정을 더 오래 참을 수 있다면, **더 많은 정보를 얻을 수 있고, 이를 기초로 제대로 된 결정을 내릴 수 있습니다.**
- 선택사항을 더 오랫동안 열어 둘 수 있다면 더 많은 실험을 해볼 수 있고 더 많은 것을 시도할 수 있습니다.
- **뛰어난 아키텍트라면 이러한 결정이 아직 내려지지 않은 것처럼 행동하며**, 여전히 결정을 가능한 오랫동안 연기하거나 변경할 수 있는 형태로 시스템을 만듭니다.

> > 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화합니다.

### 장치 독립성

- 코드를 입출력 장치와 직접 결합한 것은 가장 큰 실수 중 하나입니다.
  - 이러한 코드는 **장치 종속적(device dependent)** 입니다.
- 1960년대에 후반에 이르어서야 **장치 독립성(device independent)** 을 생각했습니다.
- 이제는 동일한 프로그램을 **아무런 변경 없이도** 진행할 수 있습니다.
  - 개방 폐쇄 원칙이 이로써 탄생했습니다.

### 광고 우편

- 장치 독립성은 어떤 장치를 사용할지 전혀 모르더라도, 프로그램을 작성할 수 있습니다.

### 물리적 주소 할당

- 시스템에서 고수준의 정책이 디스크의 물리적 구조로부터 독립되는 것 처럼, 일종의 결정사항을 애플리케이션에서 분리하는 것은 중요합니다.

### 결론

- 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리합니다.
- 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 됩니다.
- 좋은 아키텍트는 세부사항에 대한 결정을 가능한 오랫동안 미룰 수 있는 방향으로 정책을 설계합니다.

<br/>

## 16장. 독립성

<br/>

## 17장. 경계: 선 긋기

<br/>

## 18장. 경계 해부학

<br/>

## 19장. 정책과 수준

<br/>

## 20장. 업무 규칙

<br/>

## 21장. 소리치는 아키텍처

<br/>

## 22장. 클린 아키텍처

<br/>

## 23장. 프레젠터와 험블 객체

<br/>

## 24장. 부분적 경계

<br/>

## 25장. 계층과 경계

<br/>

## 26장. 메인(Main) 컴포넌트

<br/>

## 27장. '크고 작은 모든' 서비스들

<br/>

## 28장. 테스트 경계

<br/>

## 29장. 클린 임베디드 아키텍처
