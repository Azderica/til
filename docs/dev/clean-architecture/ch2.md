---
sidebar_position: 1
---

# 2부. 벽돌부터 시작하기: 프로그래밍 패러다임

## 3장. 패러다임 개요

이 장에서는 세 가지 패러다임인 **구조적 프로그래밍(structured programming)** , **객체지향 프로그래밍(object-oriented programming)** , **함수형 프로그래밍(functional programming)**

### 구조적 프로그래밍

- 1968년도에 등장
- `if/then/else`와 `do/while/until` 과 같은 익숙한 구조입니다.
- **구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과합니다.**

### 객체 지향 프로그래밍

- 1966년도 등장
- **객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과합니다.**

### 함수형 프로그래밍

- 1958년도에 만들어졌으나, 최근에 들어서야 만들어 졌습니다.
- **함수형 프로그래밍은 할당문에 대해 규칙을 부과합니다.**

### 생각할 거리

- 각 패러다임은 프로그래머에게서 권한을 박탈합니다.
  - 즉, 어떤 패러다임도 새로운 권한을 부여하지 않습니다.
- 위 패러다임은 각각 `goto`문, 함수 포인터, 할당문을 가져갑니다.
- 아마도 프로그래밍 패러다임은 앞으로도 딱 세가지만 있을 것으로 예상됩니다.
  - 위 패러다임은 1958년부터 1968년에 나온 것이며 현재까지도 새로운 패러다임은 없습니다.

<br/>

## 4장. 구조적 프로그래밍

### 증명

- 데이크스트라는 증명(proof)라는 수학적 원리를 적용하여 어려운 프로그래밍을 해결할려고 노력했습니다.
  - 공리, 정리. 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것입니다.
- 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며 코드가 올바르다는 사실을 스스로 증명하게 되는 방식입니다.
- 데이크스트라가 이를 진행하며 `goto` 문장이 모듈을 더 작게 분해하는 과정에 방해되는 경우가 있다는 사실을 발견하빈다.
- 이러한 제어 구조는 순차 실행(sequential execution)에 결합했을 때 특별합니다.
  - 모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration) 이라는 세 가지 구조만으로 표현할 수 있습니다.
  - 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실입니다.
- 데이크스트라는 아래를 증명했습니다.
  - 열거법을 이용해 순차 구문(sequential statement)이 올바름을 증명할 수 있다는 사실을 증명합니다.
  - 분기(selection)의 경우, 열거법을 재적용하는 방식으로 처리했습니다.
  - 반복(iteration)은 귀납법으로 증명했습니다. 

### 해로운 성명서

- `goto`문의 해로움은 1968년도에 실렸습니다.
- 그 후 `goto` 문장은 없어졋습니다.

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 결국 모듈을 기능적으로 분해할 수 있음을 뜻합니다.
- 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있습니다. 그리고 이러한 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 수 있습니다.
- 이를 토대로 구조적 분석(structured analysis)이나 구조적 설계(structured design)와 같은 기법이 1970~1980년대에 인기를 끌었습니다.
- 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있습니다.

### 엄밀한 증명은 없었다

- 결국 증명은 이루어지지 않았습니다.
- 현재의 개발자는 엄밀한 증명이 고품질의 소프트웨어를 생산하기 위한 적절한 방법이라고 생각하지 않습니다.
- 무엇인가를 증명할 때는 유클리드 방식같이 수학적인 증명만이 있는 것이 아닌, 과학적 방법(scientific method)가 있습니다.

### 과학이 구출하다

- 꽈학적 이론과 법칙이 지닌 본성입니다. 즉, 과학적 방법은 **반증은 가능하지만 증명은 불가능**합니다.
- 과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작합니다.
- 수학은 증명 가능한 서술이 참임을 입증하는 윈리라면 과학은 증명 가능한 서술이 거짓임을 입증하는 원리입니다.

### 테스트

- "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없습니다."
- 소프트웨어는 일종한 과학과 같습니다.
- 부정확함에 대한 증명은 입증 가능한 프로그램에만 적용할 수 있습니다.
- 구조적 프로그래밍은 프로그램을 증명 가능한 세부 집합으로 재귀적으로 분해할 것을 강요합니다.

### 결론

- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문입니다.
- 가장 작은 기능에서부터 가장 큰 컴포턴트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도됩니다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 분주히 노력해야 합니다.

<br/>

## 5장. 객체 지향 프로그래밍

### 캡슐화?

### 상속?

### 다형성?

### 결론

<br/>

## 6장. 함수형 프로그래밍