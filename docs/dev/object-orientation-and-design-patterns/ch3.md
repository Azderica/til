# 주요 디자인 패턴

## 디자인 패턴이란?

객체 지향 설계는 소프트웨어로 해결하고자 하는 문제를 다루면서, 동시에 재설계 없이 또는 재 설계를 최소화하면서 요구 사항의 변화를 수용할 수 있도록 만들어줍니다.

이러한 좋은 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖게됩니다. 이런 패턴을 잘 습득하면 다음의 이득이 있습니다.

- 상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있습니다.
- 각 패턴의 장단점을 통해서 설계를 선택하는데 도움을 얻을 수 있습니다.
- 설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있습니다.

이러한 패턴을 모은 책이 있는데 GoF의 디자인 패턴은 많은 프로그래머에게 도움이 되었습니다. 이중에서 자주사용되는 패턴과, GoF 패턴에는 없으나 자주 사용하는 널(Null) 객체 패턴을 설명합니다.

### 종류

- 전략 패턴 / 템플릿 패턴 / 상태 패턴
- 데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴
- 옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴
- 추상 팩토리 패턴 / 컴포지트 패턴
- 널(Null) 객체 패턴

<br/>

## 전력 패턴

콘텍스트 ---> 전략(strategry) <--(상속)-- 전략 콘크리트 클래스

이처럼 **특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법**입니다.

- 전략 패턴에서는 콘텍스트는 사용할 전략을 직접 선택하지 않습니다.
- 콘텍스트의 클라이언트가 콘텍스트에 사용활 전략을 전달해줍니다. (DI)

### 장점

- 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있습니다.
- 일반적으로 if-else로 구성된 블록이 비슷한 기능을 수행할 때, 전략패턴을 적용함으로써 코드의 확장이 편하게 할 수 있습니다.

<br/>

## 템플릿 패턴

코드를 작성하다보면, 완전히 동일한 절차를 가진 코드를 작성하게 될 때가 있습니다. 보통 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴입니다. 일반적으로는 아래 2개로 이뤄집니다.

- 실행 과정을 구현한 상위 클래스
- 실행 과정의 일부 단계를 구현한 하위 클래스

상위 클래스는 실행 과정을 구현한 메서드를 제공하며, 이 메서드는 기능을 구현하는데 필요한 각 단계를 정의하며 일부 단게는 추상 메서드를 호출하는 방식으로 구현됩니다.

### 상위 클래스가 흐름을 주체합니다.

템플릿 메서드 패턴은 하위 클래스가 아닌 상위 클래스에서 프름을 제어합니다. 즉, 상위 타입의 템플릿 메서드가 모든 실행 흐름을 제어하고 하위 타입의 메서드는 템플릿 메서드에서 호출되는 구조를 갖게 합니다.

### 훅(hook) 메서드

**상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드**를 훅 메서드라고 합니다.

### 템플릿 메서드와 전략 패턴의 조합

일반적으로 템플릿 메서드/전략 패턴 조합은 엄격하게는 전략 패턴에 가깝습니다. 다만 이를 같이 사용하게 되면 상속이 아닌 조립의 방식으로 템플릿 메서드 패턴을 사용할 수 있습니다.

```java
public <T> T execute(TransactionCallback<T> action) throws TransactionException {
  // 일부 코드 생략.
  TransactionStatus status = this.transactionManager.getTransaction(this);
  T result;
  try {
    result = action.doInTransaction(status);
  } catch (RuntimeException ex) {
    rollbackOnException(status, ex);
    throw ex;
  }
  ... // 다른 익셉션 코드
  this.transactionManager.commit(status);
  return result;
}
```

```java
transactionTemplate.execute(new TransactionCallback<String>()) {
  public String doInTransaction(TransactionStatus status) {
    // 트랜잭션 범위 안에서 실행될 코드
  }
}
```

이와 같이 조합하면, 상속에 기반을 둔 템플릿 메서드 구현과 비교해서 유연함을 가집니다. 상속을 사용하는 경우에는 클래스가 불필요하게 증가하고 런타임에 교체할 수 없습니다. 다만 조립/위임의 경우에는 런타임에 템플릿 메서드에서 사용할 객체를 교체할 수 있는 장점을 가집니다.

하지만, 상속 방식의 경우 훅 메서드를 재정의하는 방법으로 하위 클래스에서 쉽게 확장 기능을 제공할 수 있는 장점이 있고, 조립/위임 방식에서는 확장 기능을 제공하려면 복잡해지는 단점이 있습니다.

<br/>

## 상태 패턴

상태에 따라 동일한 기능 요청의 처리를 다르게 하는 경우가 있습니다. 이때 상태 패턴을 적용합니다.

콘텍스트 ---> 상태 <--(상속)-- 상태 콘크리트 클래스들

이러한 방식은 객체에 처리를 위임하는 방식으로 동작합니다.

상태 패턴의 장점은 크게 두가지입니다.

- 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화됩니다.
- 상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기 때문에 상태 별 동작을 수정하기가 쉽습니다.

### 상태 변경의 주체

- 콘텍스트에서 상태를 변경하는 방식
  - 비교적 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리합니다.
- 상태 객체에서 콘텍스트의 상태를 변경하는 방식
  - 콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있게 됩니다.

위 두 방식의 서로 상반되는 장단점을 잘 고려하는 것이 중요합니다.

<br/>

## 데코레이터 패턴

상속은 기능을 확장하는 방법을 제공합니다. 상속을 이용한 기능 확장 방법이 쉽긴 하지만, 다양한 조합의 기능 확장이 요구될 때 클래스가 불필요하게 증가하는 문제가 발생합니다.

데코레이터 패턴은 상속이 아닌 위임을 하는 방식입니다. 기능 확장을 위해 데코레이터라 불리는 추상 클래스를 만듭니다.

또는 기존 기능에 새로운 기능을 추가해준다는 의미에서 객체를 데코레이터라고 부릅니다.

### 데코레이터 패턴의 장점

- 데코레이터를 조합하는 방식으로 기능을 확장할 수 있습니다.
- 기능 적용 순서의 변경도 쉽습니다.
- 각 확장 기능들의 구현이 별도의 클래스로 분리되기 때문에 각 확장 기능 및 원래 기능을 서로 영향 없이 변경할 수 있도록 만들어줍니다.
- 데코레이터 패턴은 단일 책임 원칙을 지킬 수 있도록 만들어줍니다.

일반적으로 데코레이터 패턴은 전략 패턴/템플릿 메서드 패턴/상태 패턴과 함께 매우 흔하게 사용되는 패턴입니다. 스프링 프레임워크의 경우 트랜잭션 처리를 위해 데코레이터 패턴을 사용합니다.

### 고려할 점.

- 데코레이터 대상이 되는 타입의 기능 개수에 대해 신경을 써야합니다.
  - 구현이 비교적으로 간단하지만 정의되어 있는 메서드가 증가하게 되면 그 만큼 데코레이터의 구현도 복잡해집니다.
- 데코레이터 객체가 비정상적으로 동작할 때 어떻게 처리할 지 고민이 필요합니다.

### 단점.

사용자 입장에서 데코레이터 객체와 실제 구현 객체의 구분이 되지 않기 때문에 코드만으로는 기능이 어떻게 동작하는지 이해하기 어렵습니다.

<br/>

## 프록시 패턴

<br/>

## 어댑터 패턴

<br/>

## 옵저버 패턴

<br/>

## 미디에이터 패턴

<br/>

## 파사드 패턴

<br/>

## 추상 팩토리 패턴

<br/>

## 컴포지트 패턴

<br/>

## 널(Null) 객체 패턴
