<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">주요 디자인 패턴 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/object-orientation-and-design-patterns/ch3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="주요 디자인 패턴 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="디자인 패턴이란?"><meta data-react-helmet="true" property="og:description" content="디자인 패턴이란?"><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/object-orientation-and-design-patterns/ch3"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/object-orientation-and-design-patterns/ch3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/object-orientation-and-design-patterns/ch3" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.f02746e6.js" as="script">
<link rel="preload" href="/til/assets/js/main.0df9871a.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch11">11. 합성과 유연한 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">주요 디자인 패턴</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="디자인-패턴이란"></a>디자인 패턴이란?<a class="hash-link" href="#디자인-패턴이란" title="Direct link to heading">#</a></h2><p>객체 지향 설계는 소프트웨어로 해결하고자 하는 문제를 다루면서, 동시에 재설계 없이 또는 재 설계를 최소화하면서 요구 사항의 변화를 수용할 수 있도록 만들어줍니다.</p><p>이러한 좋은 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖게됩니다. 이런 패턴을 잘 습득하면 다음의 이득이 있습니다.</p><ul><li>상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있습니다.</li><li>각 패턴의 장단점을 통해서 설계를 선택하는데 도움을 얻을 수 있습니다.</li><li>설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있습니다.</li></ul><p>이러한 패턴을 모은 책이 있는데 GoF의 디자인 패턴은 많은 프로그래머에게 도움이 되었습니다. 이중에서 자주사용되는 패턴과, GoF 패턴에는 없으나 자주 사용하는 널(Null) 객체 패턴을 설명합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="종류"></a>종류<a class="hash-link" href="#종류" title="Direct link to heading">#</a></h3><ul><li>전략 패턴 / 템플릿 패턴 / 상태 패턴</li><li>데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴</li><li>옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴</li><li>추상 팩토리 패턴 / 컴포지트 패턴</li><li>널(Null) 객체 패턴</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="전력-패턴"></a>전력 패턴<a class="hash-link" href="#전력-패턴" title="Direct link to heading">#</a></h2><p>콘텍스트 ---&gt; 전략(strategry) &lt;--(상속)-- 전략 콘크리트 클래스</p><p>이처럼 <strong>특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법</strong>입니다.</p><ul><li>전략 패턴에서는 콘텍스트는 사용할 전략을 직접 선택하지 않습니다.</li><li>콘텍스트의 클라이언트가 콘텍스트에 사용활 전략을 전달해줍니다. (DI)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="장점"></a>장점<a class="hash-link" href="#장점" title="Direct link to heading">#</a></h3><ul><li>콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있습니다.</li><li>일반적으로 if-else로 구성된 블록이 비슷한 기능을 수행할 때, 전략패턴을 적용함으로써 코드의 확장이 편하게 할 수 있습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="템플릿-패턴"></a>템플릿 패턴<a class="hash-link" href="#템플릿-패턴" title="Direct link to heading">#</a></h2><p>코드를 작성하다보면, 완전히 동일한 절차를 가진 코드를 작성하게 될 때가 있습니다. 보통 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴입니다. 일반적으로는 아래 2개로 이뤄집니다.</p><ul><li>실행 과정을 구현한 상위 클래스</li><li>실행 과정의 일부 단계를 구현한 하위 클래스</li></ul><p>상위 클래스는 실행 과정을 구현한 메서드를 제공하며, 이 메서드는 기능을 구현하는데 필요한 각 단계를 정의하며 일부 단게는 추상 메서드를 호출하는 방식으로 구현됩니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상위-클래스가-흐름을-주체합니다"></a>상위 클래스가 흐름을 주체합니다.<a class="hash-link" href="#상위-클래스가-흐름을-주체합니다" title="Direct link to heading">#</a></h3><p>템플릿 메서드 패턴은 하위 클래스가 아닌 상위 클래스에서 프름을 제어합니다. 즉, 상위 타입의 템플릿 메서드가 모든 실행 흐름을 제어하고 하위 타입의 메서드는 템플릿 메서드에서 호출되는 구조를 갖게 합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="훅hook-메서드"></a>훅(hook) 메서드<a class="hash-link" href="#훅hook-메서드" title="Direct link to heading">#</a></h3><p><strong>상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드</strong>를 훅 메서드라고 합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="템플릿-메서드와-전략-패턴의-조합"></a>템플릿 메서드와 전략 패턴의 조합<a class="hash-link" href="#템플릿-메서드와-전략-패턴의-조합" title="Direct link to heading">#</a></h3><p>일반적으로 템플릿 메서드/전략 패턴 조합은 엄격하게는 전략 패턴에 가깝습니다. 다만 이를 같이 사용하게 되면 상속이 아닌 조립의 방식으로 템플릿 메서드 패턴을 사용할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 일부 코드 생략.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  TransactionStatus status = this.transactionManager.getTransaction(this);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  T result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    result = action.doInTransaction(status);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (RuntimeException ex) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    rollbackOnException(status, ex);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw ex;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // 다른 익셉션 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.transactionManager.commit(status);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">transactionTemplate.execute(new TransactionCallback&lt;String&gt;()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public String doInTransaction(TransactionStatus status) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 트랜잭션 범위 안에서 실행될 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같이 조합하면, 상속에 기반을 둔 템플릿 메서드 구현과 비교해서 유연함을 가집니다. 상속을 사용하는 경우에는 클래스가 불필요하게 증가하고 런타임에 교체할 수 없습니다. 다만 조립/위임의 경우에는 런타임에 템플릿 메서드에서 사용할 객체를 교체할 수 있는 장점을 가집니다.</p><p>하지만, 상속 방식의 경우 훅 메서드를 재정의하는 방법으로 하위 클래스에서 쉽게 확장 기능을 제공할 수 있는 장점이 있고, 조립/위임 방식에서는 확장 기능을 제공하려면 복잡해지는 단점이 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상태-패턴"></a>상태 패턴<a class="hash-link" href="#상태-패턴" title="Direct link to heading">#</a></h2><p>상태에 따라 동일한 기능 요청의 처리를 다르게 하는 경우가 있습니다. 이때 상태 패턴을 적용합니다.</p><p>콘텍스트 ---&gt; 상태 &lt;--(상속)-- 상태 콘크리트 클래스들</p><p>이러한 방식은 객체에 처리를 위임하는 방식으로 동작합니다.</p><p>상태 패턴의 장점은 크게 두가지입니다.</p><ul><li>새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화됩니다.</li><li>상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기 때문에 상태 별 동작을 수정하기가 쉽습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상태-변경의-주체"></a>상태 변경의 주체<a class="hash-link" href="#상태-변경의-주체" title="Direct link to heading">#</a></h3><ul><li>콘텍스트에서 상태를 변경하는 방식<ul><li>비교적 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리합니다.</li></ul></li><li>상태 객체에서 콘텍스트의 상태를 변경하는 방식<ul><li>콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있게 됩니다.</li></ul></li></ul><p>위 두 방식의 서로 상반되는 장단점을 잘 고려하는 것이 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데코레이터-패턴"></a>데코레이터 패턴<a class="hash-link" href="#데코레이터-패턴" title="Direct link to heading">#</a></h2><p>상속은 기능을 확장하는 방법을 제공합니다. 상속을 이용한 기능 확장 방법이 쉽긴 하지만, 다양한 조합의 기능 확장이 요구될 때 클래스가 불필요하게 증가하는 문제가 발생합니다.</p><p>데코레이터 패턴은 상속이 아닌 위임을 하는 방식입니다. 기능 확장을 위해 데코레이터라 불리는 추상 클래스를 만듭니다.</p><p>또는 기존 기능에 새로운 기능을 추가해준다는 의미에서 객체를 데코레이터라고 부릅니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데코레이터-패턴의-장점"></a>데코레이터 패턴의 장점<a class="hash-link" href="#데코레이터-패턴의-장점" title="Direct link to heading">#</a></h3><ul><li>데코레이터를 조합하는 방식으로 기능을 확장할 수 있습니다.</li><li>기능 적용 순서의 변경도 쉽습니다.</li><li>각 확장 기능들의 구현이 별도의 클래스로 분리되기 때문에 각 확장 기능 및 원래 기능을 서로 영향 없이 변경할 수 있도록 만들어줍니다.</li><li>데코레이터 패턴은 단일 책임 원칙을 지킬 수 있도록 만들어줍니다.</li></ul><p>일반적으로 데코레이터 패턴은 전략 패턴/템플릿 메서드 패턴/상태 패턴과 함께 매우 흔하게 사용되는 패턴입니다. 스프링 프레임워크의 경우 트랜잭션 처리를 위해 데코레이터 패턴을 사용합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="고려할-점"></a>고려할 점.<a class="hash-link" href="#고려할-점" title="Direct link to heading">#</a></h3><ul><li>데코레이터 대상이 되는 타입의 기능 개수에 대해 신경을 써야합니다.<ul><li>구현이 비교적으로 간단하지만 정의되어 있는 메서드가 증가하게 되면 그 만큼 데코레이터의 구현도 복잡해집니다.</li></ul></li><li>데코레이터 객체가 비정상적으로 동작할 때 어떻게 처리할 지 고민이 필요합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단점"></a>단점.<a class="hash-link" href="#단점" title="Direct link to heading">#</a></h3><p>사용자 입장에서 데코레이터 객체와 실제 구현 객체의 구분이 되지 않기 때문에 코드만으로는 기능이 어떻게 동작하는지 이해하기 어렵습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="프록시-패턴"></a>프록시 패턴<a class="hash-link" href="#프록시-패턴" title="Direct link to heading">#</a></h2><p>불필요하게 메모리를 사용하는 문제가 발생할 수 있습니다.</p><p><strong>변경없이 이미지 로딩 방식을 교체할 수 있도록 해주는 패턴</strong>이 <strong>프록시 패턴</strong>입니다. 프록시 패턴은 실제 객체를 대신하는 프록시 객체를 사용해서 실제 객체의 생성이나 접근 등을 제어할 수 있도록 하는 패턴입니다.</p><p>프록시에는 여러 종류가 존재합니다.</p><ul><li>가상 프록시<ul><li>필요한 순간에 실제 객체를 생성해 주는 프록시</li></ul></li><li>보호 프록시<ul><li>실제 객체에 대한 접근을 제어하는 프록시</li><li>접근 권한이 있는 경우에만 실제 객체의 메서드를 실행하는 방식으로 구현</li></ul></li><li>원격 프록시<ul><li>자바의 RMI처럼 다른 프로세스에 존재하는 객체에 접근할 때 사용되는 프록시</li><li>IPC나 TCP 통신을 이용해서 다른 프로세스의 객체를 실행합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="고려할-점-1"></a>고려할 점<a class="hash-link" href="#고려할-점-1" title="Direct link to heading">#</a></h3><p>실제 객체를 누가 생성할 것이냐에 대한 고민을 해야합니다.</p><ul><li>가상 프록시는 필요한 순간에 실제 객체를 생성하는 경우가 많습니다.</li><li>보호 프록시는 접근 제어를 목적으로 하기에, 이를 생성할 때 실제 객체를 전달하면 되므로 실제 객체의 타입을 알 필요 없이 추상 타입을 사용하면 됩니다.</li></ul><p>상속 방식의 프록시는 간단해서 구현이 쉽지만 객체 생성시 실제 객체가 생성되므로 가상 프록시에는 적절하지 않습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="어댑터-패턴"></a>어댑터 패턴<a class="hash-link" href="#어댑터-패턴" title="Direct link to heading">#</a></h2><p><strong>클라이언트가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 패턴</strong>이 어댑터 패턴입니다.</p><p>어댑터 패턴을 적용한 구조는 다음과 같습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120910654-7e97e580-c6bb-11eb-8b97-c46de7981b3d.png" alt="image"></p><p>코드의 예시는 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class SearchServiceTolrAdapter implements SearchService {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private TolrClient tolrClient = new TolrClient();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public SearchResult search(String keyword) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    TolrQuery tolrQuery = new TolrQuery(keyword);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    QueryResponse response = tolrClient.query(tolrQuery);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    SearchResult result = convertToResult(response);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 어댑터 패턴을 적용된 예는 <code>SLF4J</code> 라는 로깅 API입니다. SLF4J는 단일 로깅 API를 사용하면서 자바 로깅, log4j, LogBack 등의 로깅 프레임워크를 선택적으로 사용할 수 있도록 해줍니다. 이때 SLF4J가 제공하는 인터페이스와 각 로깅 프레임워크를 맞춰 주기 위해 어댑터를 사용하고 있습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120910633-5e682680-c6bb-11eb-91f8-cc5bfefc27f3.png" alt="image"></p><p>이러한 어댑터 패턴은 개방 폐쇄 원칙을 따를 수 있게 해줍니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="옵저버-패턴"></a>옵저버 패턴<a class="hash-link" href="#옵저버-패턴" title="Direct link to heading">#</a></h2><p><strong>한 객체의 상태 변화를 정해지지 않은 여러 다른 객체에 주입하고 싶을 때 사용하는 패턴</strong>을 옵저버 패턴이라고 합니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120910857-63c67080-c6bd-11eb-8801-fe8659a1b8a1.png" alt="image"></p><p>옵저버 패턴은 크게 주제(subject) 객체와 옵저버(observer) 객체가 등장하며, <strong>주제 객체</strong>는 다음의 두가지 책임을 가집니다.</p><ul><li>옵저버 목록을 관리하고 옵저버를 등록하고 제거할 수 있는 메서드를 제공합니다.</li><li>상태의 변경이 발생하면 등록된 옵저버에 변경 내역을 알립니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 옵저버 패턴에서 주제에 해당하는 클래스의 구현</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public abstract class StatusSubject {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private List&lt;StatusObserver&gt; observers = new ArrayList&lt;StatusObserver&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void add(StatusObserver observer) {observers.add(observer);}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void remove(StatusObserver observer) {observers.remove(observer);}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void notifyStatus(Status status) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for(StatusObserver observer : observers)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      observer.onAbnormalStatus(status);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 옵저버 인터페이스</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public interface StatusObserver {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void onAbnormalStatus(Status status);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 콘클이트 옵저버 클래스의 구현 예시</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class StatusEmailSender implements StatusObserver {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void onAbnormalStatus(Status status) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sendEmail(status);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void sendEmail(Status status) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ... // 이메일 전송 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 옵저버 패턴을 적용할 때의 <strong>장점</strong>은 <strong>주제 클래스 변경 없이 상태 변경을 통지 받을 옵저버를 추가할 수 있습니다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="옵저버-객체에게-상태-전달-방법"></a>옵저버 객체에게 상태 전달 방법<a class="hash-link" href="#옵저버-객체에게-상태-전달-방법" title="Direct link to heading">#</a></h3><p>일반적으로는 주체 객체에서 상태 값을 전달하면, 옵저버 객체에서 파라미터로 받아 상태를 전달 받습니다. 다만, 필요에 따라, 콘크리트 주체 객체에서 직접 접근하는 경우도 존재합니다. 이러한 경우에는 콘크리트 주제 클래스에 의존을 가지게 됩니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="주제-객체-구분"></a>주제 객체 구분<a class="hash-link" href="#주제-객체-구분" title="Direct link to heading">#</a></h3><p>옵저버 패턴을 자주 사용되는 영역은 GUI 프로그래밍 영역입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="옵저버-패턴-구현의-고려-사항"></a>옵저버 패턴 구현의 고려 사항<a class="hash-link" href="#옵저버-패턴-구현의-고려-사항" title="Direct link to heading">#</a></h3><p>일반적으로 옵저버 패턴을 구현할 때는 다음을 고려합니다.</p><ul><li>주제 객체의 통지 기능 실행 주체<ul><li>옵저버에 통지하는 시점을 결정하는 주체가 누가 되는지에 대한 고민</li></ul></li><li>옵저버 인터페이스의 분리<ul><li>옵저버 인터페이스 개수에 대한 고민(ex. 마우스 클릭 이벤트, 터치 이벤트 ...)</li></ul></li><li>통지 시점에서의 주제 객체 상태<ul><li>통지 시점에서 주제 객체의 상태에 결함이 없어야합니다.</li><li>이러한 방법의 예시로는 상태 변경과 통지 기능에 템플릿 메서드 패턴을 적용하는 것입니다.</li></ul></li><li>옵저버 객체의 실행 제약 조건<ul><li>옵저버 객체의 실행에 대한 제약 규칙을 정해야합니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="미디에이터-패턴"></a>미디에이터 패턴<a class="hash-link" href="#미디에이터-패턴" title="Direct link to heading">#</a></h2><p>미디에이터(Mediator) 패턴을 사용하면 각 객체들이 직접 메세지를 주고 받는 대신에 중간에 중계 역할을 수행하는 미디에이터 객체를 두고 미디에이터를 통해서 각 객체들이 간접적으로 메시지를 주고 받도록 합니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120911624-c02c8e80-c6c3-11eb-9aba-f5e9ced4aac3.png" alt="image"></p><p>다른 협업 객체들도 모든 요청을 미디에이터에 보내며, 미디에이터는 그 요청을 처리할 알맞은 객체를 실행합니다. 신규로 클래스가 추가되더라도 미디에이터만 수정될 뿐 <strong>각 협업 클래스를 수정할 필요는 없으며 수정하더라도 변경 범위가 최소화됩니다.</strong></p><p>미디에이터 패턴을 사용할 때의 단점은 협업 클래스의 개수가 증가할수록 미디에이터의 코드는 복잡해지기 때문에 미디에이터 자체를 유지 보수하는 것은 협업 클래스에 비해 어려워집니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="추상-키디에이터-클래스의-재사용"></a>추상 키디에이터 클래스의 재사용<a class="hash-link" href="#추상-키디에이터-클래스의-재사용" title="Direct link to heading">#</a></h3><p>메시지 흐름이 서로 다른 기능에서 반복해서 사용될 결우, 미디에이터 추상 클래스를 사용함으로써 미디에이터 자체의 재사용을 높일 수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파사드-패턴"></a>파사드 패턴<a class="hash-link" href="#파사드-패턴" title="Direct link to heading">#</a></h2><p>다음과 같은 구조를 가진 프로그램이 있을 때,</p><p><img src="https://user-images.githubusercontent.com/42582516/120911823-31b90c80-c6c5-11eb-8b0e-36f485f54f17.png" alt="image"></p><p>이러한 구조는 문제를 가집니다.</p><ul><li>코드 중복이 발생합니다. (관리가 어려워지고, 버그가 생기기 쉽습니다.)</li><li>Dao의 직접적인 의존을 하고 있습니다.</li></ul><p>이를 해결하는 파사드 패턴은 다음과 같습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120911880-a8eea080-c6c5-11eb-8fed-51acff53fcfe.png" alt="image"></p><p>파사드를 통해서 간접적으로 서비스 시스템에 접근합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파사드-패턴의-장점과-특징"></a>파사드 패턴의 장점과 특징<a class="hash-link" href="#파사드-패턴의-장점과-특징" title="Direct link to heading">#</a></h3><p>클라이언트와 서브 시스템 간의 결합을 제거함으로써 얻을 수 있는 장점은 다음과 같습니다.</p><ul><li>코드가 간결해집니다.</li><li>파사드를 인터페이스로 정의함으로써 클라이언트의 변경 없이 서브 시스템 자체를 변경할 수 있습니다.</li></ul><p>파사드는 서브 시스템의 상세함을 감춰 주는 인터페이스와 유사하며, 파사드를 통해서 서비 시스템의 상세한 구현을 캡슐화합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="추상-팩토리-패턴"></a>추상 팩토리 패턴<a class="hash-link" href="#추상-팩토리-패턴" title="Direct link to heading">#</a></h2><p><strong>객체 생성 책임을 분리함으로써 문제를 해결하는 패턴</strong>을 추상 팩토리 패턴이라고 합니다. 추상 팩토리 패턴을 사용할 때의 장점은 클라이언트에 영향을 주지 않으면서 사용할 제품(객체) 군을 교체할 수 있습니다.</p><p>만약에 팩토리가 생성하는 객체가 늘 동일한 상태를 갖는 다면, 프로토타입 방식으로 팩토리를 구현할 수 있습니다. <strong>프로토타입 방식</strong>은 아래 <strong>코드처럼 생성할 객체의 원형 객체를 등록하고, 객체 생성 요청이 있으면 원형 객체를 복제해서 생성합니다.</strong></p><p>프로토타입 방식을 사용하면 추상 팩토리 타입과 팩토리 클래스를 따로 만들 필요가 없어 구현이 쉽지만, 제품 객체의 생성 규칙이 복잡할 경우 적용할 수 없는 한계가 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컴포지트-패턴"></a>컴포지트 패턴<a class="hash-link" href="#컴포지트-패턴" title="Direct link to heading">#</a></h2><p>예를 들어 빌딩의 장비들의 전원을 관리하는 제어 프로그램을 개발할 때, 전체를 관리하는 기능이 필요할 수 있다. 이 경우에 클래스를 관리하는 클래스를 만들어서 해결할 수 있는데 이는 여러 단점이 존재합니다.</p><p>이는 동일한 코드가 중복된다는 점은 복잡도를 높여서 코드의 수정이나 확장을 어렵게 만듭니다. 이러한 문제를 해결하는 패턴이 <strong>컴포지트 패턴</strong>입니다. 컴포지트 패턴은 전체-부분을 구성하는 클래스가 동일 인터페이스를 구현함으로서 해결합니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120912359-51523400-c6c9-11eb-91b4-3aef3cd4a525.png" alt="image"></p><p>컴포지트 패턴에서 컴포지트는 다음의 책임을 가집니다.</p><ul><li>컴포넌트 그룹을 관리합니다.</li><li>컴포지트에 기능 실행을 요청하면, 컴포지트는 포함하고 있는 컴포넌트들에게 기능 실행 요청을 위임합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컴포지트-패턴의-장점"></a>컴포지트 패턴의 장점<a class="hash-link" href="#컴포지트-패턴의-장점" title="Direct link to heading">#</a></h3><ul><li>전체나 부분이냐 상관없이 클라이언트는 단일 인터페이스로 기능을 실행할 수 있는 장점을 가집니다.</li><li>컴포지트 자체도 컴포넌트이기 때문에 컴포지트에 다른 컴포지트를 등록할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컴포지트-패턴-구현의-고려사항"></a>컴포지트 패턴 구현의 고려사항<a class="hash-link" href="#컴포지트-패턴-구현의-고려사항" title="Direct link to heading">#</a></h3><ul><li>컴포넌트를 관리하는 인터페이스를 어디서 구현할지에 대한 여부입니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="널null-객체-패턴"></a>널(Null) 객체 패턴<a class="hash-link" href="#널null-객체-패턴" title="Direct link to heading">#</a></h2><p>코드를 작성하다보면 null 검사 코드를 빼먹기 쉽습니다. 이를 대비하기 위해서 널 객체 패턴을 사용할 수 있습니다.</p><p>널(Null) 객체 패턴은 null 검사 코드 누락에 다른 문제를 없애 줍니다. <strong>널 객체 패턴</strong>은 <strong>null을 리턴하지 않고 null을 대신할 객체를 리턴함으로써 null 검사 코드를 없앨 수 있도록 합니다.</strong> 널 객체 패턴은 다음과 같이 구현합니다.</p><ul><li>null 대신 사용될 클래스를 구현합니다. 이 클래스는 상위 타입을 상속 받으며 아무 기능도 수행하지 않습니다.</li><li>null을 리턴하는 대신, null을 대체할 클래스의 객체를 리턴합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="널-객체-패턴의-장점"></a>널 객체 패턴의 장점<a class="hash-link" href="#널-객체-패턴의-장점" title="Direct link to heading">#</a></h3><ul><li>null 검사 코드를 사용할 필요가 없기 때문에 코드가 간결해집니다.</li><li>코드가 간결해지므로서 코드 가독성을 높여주고 향후에 코드 수정을 보다 쉽게 해줍니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/object-orientation-and-design-patterns/ch3.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-12-12T23:09:29.000Z" class="lastUpdatedDate_1WI_">12/12/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/object-orientation-and-design-patterns/ch2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 설계 원칙/ DI와 서비스 로케이터</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/object/ch1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">1. 객체, 설계 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#디자인-패턴이란" class="table-of-contents__link">디자인 패턴이란?</a><ul><li><a href="#종류" class="table-of-contents__link">종류</a></li></ul></li><li><a href="#전력-패턴" class="table-of-contents__link">전력 패턴</a><ul><li><a href="#장점" class="table-of-contents__link">장점</a></li></ul></li><li><a href="#템플릿-패턴" class="table-of-contents__link">템플릿 패턴</a><ul><li><a href="#상위-클래스가-흐름을-주체합니다" class="table-of-contents__link">상위 클래스가 흐름을 주체합니다.</a></li><li><a href="#훅hook-메서드" class="table-of-contents__link">훅(hook) 메서드</a></li><li><a href="#템플릿-메서드와-전략-패턴의-조합" class="table-of-contents__link">템플릿 메서드와 전략 패턴의 조합</a></li></ul></li><li><a href="#상태-패턴" class="table-of-contents__link">상태 패턴</a><ul><li><a href="#상태-변경의-주체" class="table-of-contents__link">상태 변경의 주체</a></li></ul></li><li><a href="#데코레이터-패턴" class="table-of-contents__link">데코레이터 패턴</a><ul><li><a href="#데코레이터-패턴의-장점" class="table-of-contents__link">데코레이터 패턴의 장점</a></li><li><a href="#고려할-점" class="table-of-contents__link">고려할 점.</a></li><li><a href="#단점" class="table-of-contents__link">단점.</a></li></ul></li><li><a href="#프록시-패턴" class="table-of-contents__link">프록시 패턴</a><ul><li><a href="#고려할-점-1" class="table-of-contents__link">고려할 점</a></li></ul></li><li><a href="#어댑터-패턴" class="table-of-contents__link">어댑터 패턴</a></li><li><a href="#옵저버-패턴" class="table-of-contents__link">옵저버 패턴</a><ul><li><a href="#옵저버-객체에게-상태-전달-방법" class="table-of-contents__link">옵저버 객체에게 상태 전달 방법</a></li><li><a href="#주제-객체-구분" class="table-of-contents__link">주제 객체 구분</a></li><li><a href="#옵저버-패턴-구현의-고려-사항" class="table-of-contents__link">옵저버 패턴 구현의 고려 사항</a></li></ul></li><li><a href="#미디에이터-패턴" class="table-of-contents__link">미디에이터 패턴</a><ul><li><a href="#추상-키디에이터-클래스의-재사용" class="table-of-contents__link">추상 키디에이터 클래스의 재사용</a></li></ul></li><li><a href="#파사드-패턴" class="table-of-contents__link">파사드 패턴</a><ul><li><a href="#파사드-패턴의-장점과-특징" class="table-of-contents__link">파사드 패턴의 장점과 특징</a></li></ul></li><li><a href="#추상-팩토리-패턴" class="table-of-contents__link">추상 팩토리 패턴</a></li><li><a href="#컴포지트-패턴" class="table-of-contents__link">컴포지트 패턴</a><ul><li><a href="#컴포지트-패턴의-장점" class="table-of-contents__link">컴포지트 패턴의 장점</a></li><li><a href="#컴포지트-패턴-구현의-고려사항" class="table-of-contents__link">컴포지트 패턴 구현의 고려사항</a></li></ul></li><li><a href="#널null-객체-패턴" class="table-of-contents__link">널(Null) 객체 패턴</a><ul><li><a href="#널-객체-패턴의-장점" class="table-of-contents__link">널 객체 패턴의 장점</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.f02746e6.js"></script>
<script src="/til/assets/js/main.0df9871a.js"></script>
</body>
</html>