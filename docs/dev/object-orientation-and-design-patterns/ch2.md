# 설계 원칙/ DI와 서비스 로케이터

## 설계 원칙 : SOLID

### SOLID란?

다섯가지의 원칙으로 구성됨

- 단일 책임 원칙(SRP, Single Responsibility principle)
- 개방-패쇄 원칙(OCP, Open-closed principle)
- 리스코프 치환 원칙(LSP, Liskov substituion principle)
- 인터페이스 분리 원칙(ISP, Interface segregation principle)
- 의존 역전 원칙(DIP, Dependency inversion principle)

### 단일 책임 원칙(SRP, Single Responsibility principle)

정의 : 클래스는 단 한개의 책임을 가져야 한다.

#### 위반하는 경우.

- 절차지향적으로 구성되어 변경이 어려워집니다. 그 이유는책임의 단위는 변화되는 부분과 관련된다.

#### 지키는 방법

- 메서드를 실행하는 주체를 아는 것이 중요하다.
- 일반적으로 사용자들이 다른 경우는 다른 책임에 속할 확률이 높기 때문에 책임 분리 후보가 될 수 있습니다.

### 개방-패쇄 원칙(OCP, Open-closed principle)

정의 : 확장에는 열려있어야하고, 변경에는 닫혀 있어야한다.

- 기능을 변경하거나 확장할 수 있으며
- 그 기능을 사용하는 코드는 수정하지 않는다.

즉, 기능을 확장하면서도 기능을 사용하는 기존 코드는 변경되지 않는 것입니다. 이를 구현할 수 있는 이유는 변화되는 부분을 추상화 했기 때문입니다.

이 외에도 개방 폐쇄 원칙을 구현하는 방법은 상속입니다. 오버라이딩을 통해서 이 원칙을 지킬 수 있습니다.

#### 위반 하는 경우

추상화와 다형성을 이용해서 일반적으로 개방 폐쇄 원칙을 구현하는데, 추상화나 다형성을 제대로 지키지 않은 코드는 개방폐쇄 원칙을 어기게 됩니다.

대표적인 예시

- 다운 캐스팅을 합니다.
- 비슷한 if-else 블록이 존재합니다.

#### 개방 폐쇄 원칙은 유연함에 대한 것입니다.

개방 폐쇄 원칙은 변경의 유연함과 관련된 원칙입니다. 즉, 변화가 예상되는 곳을 추상화해서 변경의 유연함을 얻도록 해줍니다. 따라서 코드에 대한 변화 요구가 발생하면, 변화와 관련된 구현을 추상화해서 개방 폐쇄 원칙에 맞게 수정할 수 있는지 확인하는 습관을 갖도록 해야합니다.

### 리스코프 치환 원칙(LSP, Liskov substituion principle)

정의 : 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야합니다. 일밙적으로 개방 페쇄 원칙을 받혀 주는 다형성에 관한 원칙을 제공합니다.

#### 위반 하는 경우

예시

- `instanceof` 연산자 사용
- 상위 타입에서 지정한 리턴 값의 범위에 해당되지 않는 값을 리턴

위반 사례

- 명시적 명세에서 벗어난 값을 리턴합니다.
- 명시된 명세에서 벗어난 익셉션이 발생합니다.
- 명시된 명세에서 벗어난 기능을 수행합니다.

#### 리스코프 치환 원칙은 계약과 확장에 대한 것

일반적으로 리스코프 치환 원칙을 어기면 개방 폐쇄 원칙을 어길 가능성이 높아집니다.

### 인터페이스 분리 원칙(ISP, Interface segregation principle)

정의 : 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야합니다.

#### 인터페이스 분리 원칙

- 자신이 사용하는 메서드에만 의존해야 한다는 원칙
- 단일 책임 원칙이 잘지켜질 때, 인터페이스와 콘크리트 클래스의 재사용 가능성을 높일 수 있으므로 인터페이스 분리 원칙은 결국 인터페이스와 콘크리트 클래스의 재사용성을 높여줍니다.

### 의존 역전 원칙(DIP, Dependency inversion principle)

정의 : 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안됩니다. 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야합니다.

고수준 모듈

- 어떤 의미가 있는 단일 기능을 제공하는 모듈
- ex) 바이트 데이터를 읽어와 암호화 하고, 결과 바이트 데이트를 쓴다

저수준 모듈

- 고수준 모듈 들의 기능을 구현하기 위해 필요한 하위 기능의 실제구현
- ex) 파일에서 바이트 데이터를 읽어옴, AES 알고리즘으로 암호화, 파일에 바이트 데이터를 씀

#### 위반 하는 경우, 고수준 모듈이 저수준 모듈에 의존할 때

프로젝트 초기에 요구사항이 어느 정도 안정화되면 이후부터는 큰틀에서 프로그램이 변경되기 보다는 상세 수준에서의 변경이 발행할 가능성이 높아집니다. 그렇기 때문에 변경이 어려워집니다.

#### 의존 역전 원칙을 통해 변경의 유연함 확보

추상화를 통해서 유연함을 얻을 수 있습니다. 고수준 모듈의 변경없이 저수준 모듈을 변경할 수 있는 유연함을 얻습니다.

즉, 리스코프 치환 원칙과 함께 개방 폐쇄 원칙을 따르는 설계를 만들어 주는 기반이됩니다.

#### 의존 역전 원칙과 패키지

- 의존 역전 원칙은 타입의 소유도 역전시킵니다.
- 이를 통해, 각 패키지를 독립적으로 배포할 수 있게 해줍니다.

### SOLID 정리

변화에 유연하게 대처할 수 있는 설계 원칙

- 단일 책임 원칙과 인터페이스 분리 원칙을 통해 객체가 커지는 것을 막아줍니다. 이를 통해 객체가 단일 책임을 가지고 변경이 다른 곳에 미치는 영향을 최소화합니다.
- 리스코프 치환 원칙과 의존 역전 원칙은 개방 폐쇄 원칙을 지원합니다.
- 개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능을 확장하면서 기존 코드를 수정하지 않도록 만들어줍니다.

사용자 입장에서의 기능 사용을 중시합니다. 즉, SOLID 원칙은 사용자 관점에서의 설계를 지향합니다.

<br/>

## DI와 서비스 로케이터
