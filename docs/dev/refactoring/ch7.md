# 캡슐화

모듈을 분리하는 중요한 기준 중 하나는 모듈을 얼마나 잘 숨기는 지입니다.

다음의 방법이 있습니다.

- 레코드 캡슐화하기, 컬렉션 캡슐화하기, 기본형을 객체로 바꾸기, 임시 변수를 질의로 바꾸기
- 여러 함수를 클래스로 묶기, 클리스 추출하기, 클래스 인라인하기
- 위임 숨기기, 중개자 제거하기
- 함수 추출하기, 알고리즘 교체하기

## 1. 레코드 캡슐화하기

### 배경

- 일반적으로는 레코드보다는 객체를 선호하는 것이 좋습니다.
  - 이는 레코드는 결국 헷갈릴 수 있습니다.
- 레코드 구조는 두 가지로 구분할 수 있는데 하나는 필드 이름을 노출하는 형태와 다른 하나는 내가 원하는 이름을 쓸 수 있는 형태입니다.
  - 후자는 일반적으로 해시, 맵, 해시맵, 딕셔너리, 연관 배열 등을 제공하지만 일종의 단점이 될 수 있습니다.
- 객체를 사용하면 이후에 JSON이나, XML 같은 포맷으로 직렬화할 때나 수정할 때 편해집니다.

### 절차

- 레코드를 담은 변수를 캡슐화합니다.
  - 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어줍니다.
- 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체합니다. 이 클래스에 원본 레코를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정합니다.
- 테스트합니다.
- 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만듭니다.
- 레코드를 반환하는 예전 함수를 사용하는 코드를 위에서 만든 새 함수를 사용하도록 바꿉니다. 필드에 접근할 때는 객체의 접근자를 사용합니다. 적절한 접근자가 없다면 추가하고, 한 부분을 바꿀 때마다 테스트합니다.
- 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거합니다.
- 테스트합니다.
- 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용합니다.

### 예시

#### 간단한 레코드 캡슐화하기

다음과 같이 리팩토링을 진행할 수 있습니다.

- [리팩토링 전 코드](https://github.com/Azderica/js-test/blob/master/refactoring/ch7/ex1/refactoring-step-0.js)
- [중간 리팩토링 코드, 1](https://github.com/Azderica/js-test/blob/master/refactoring/ch7/ex1/refactoring-step-1.js)
- [중간 리팩토링 코드, 2](https://github.com/Azderica/js-test/blob/master/refactoring/ch7/ex1/refactoring-step-2.js)
- [최종 리팩토링 코드](https://github.com/Azderica/js-test/blob/master/refactoring/ch7/ex1/refactoring-step-3.js)

#### 중첩된 레코드 캡슐화하기

다음과 같은 데이터를 사용하는 경우에도 리팩토링을 진행할 수 있습니다.

```json
"1920":{
  name: "마틴 파울러",
  id: "1920",
  usages: {
    "2016": {
      "1": 50,
      "2": 55,
      // 생략
    },
    "2015": {
      "1": 70,
      "2": 63,
      // 생략
    }
  }
},
"38673": {
  name: "닐 포드",
  id: "38763"
  // 생략
}
```

이를 사용하는 코드는 다음과 같습니다.

- [리팩토링 전 코드](https://github.com/Azderica/js-test/blob/master/refactoring/ch7/ex1/refactoring-step-4.js)
- [최종 리팩토링 코드](https://github.com/Azderica/js-test/blob/master/refactoring/ch7/ex1/refactoring-step-5.js)

중첩된 레코드를 처리할 때는 두가지 방법으로 진행할 수 있습니다.

- 모든 데이터를 명시적인 API로 제공하기
  - 장점 : 클래스를 통해서 데이터 사용 방법을 모두 파악 가능합니다.
  - 단점 : 읽는 패턴이 다양하면 작성할 코드가 늘어납니다.
- 실제 데이터를 제공, 레코드 캡슐화를 재귀적으로 하기
  - 장점 : 확실한 제어가 가능합니다.
  - 단점 : 모든 쓰기를 함수안에서 처리가 불가능합니다. (이를 clone으로 처리), 복제 비용이 커집니다.

<br/>

## 2. 컬렉션 캡슐화하기

<br/>

## 3. 기본형을 객체로 바꾸기

<br/>

## 4. 임시 변수를 질의 함수로 바꾸기

<br/>

## 5. 클래스 추출하기

<br/>

## 6. 클래스 인라인하기

<br/>

## 7. 위임 숨기기

<br/>

## 8. 중개자 제거하기

<br/>

## 9. 알고리즘 교체하기
