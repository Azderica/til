---
sidebar_position: 10
---

# 조건부 로직 간소화

- 조건문 분해하기, 중복 조건식 통합하기
  - 복잡한 조건문인 경우나 논리적 조합을 명확하게 다듬는 경우
- 중첩 조건문을 보호 구문으로 바꾸기, 조건부 로직을 다형성으로 바꾸기
  - 핵심 로직 전 무언가를 검사하거나, 같은 분기 로직이 자주 등장하는 경우
- 특이 케이스 추가하기(널 개체 추가하기), 어서션 추가하기
  - 특이 케이스 처리시
- 제어 플래그를 탈출문으로 바꾸기
  - 제어 플래그를 이용해 코드 동작 흐름을 바꾸는 경우

## 조건문 분해하기

```js
// before
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
  change = quantity * plan.summerRate
else change = quantity * plan.regularRate + plan.regularServiceCharge

// after
if (summer()) charge = summerCharge()
else charge = regularCharge()
```

### 배경

- 복잡한 조건부 로직은 프로그램을 만들게 합니다.
- 거대한 코드 블럭은 코드를 부위별로 분해한 다음 해체된 코드 덩어리들을 각 덩어리의 의도를 살인 이름의 함수 호출을 했습니다.

### 절차

1. 조건식과 그 조건식에 달린 조건절 각각을 함수로 추출했습니다.

### 예시

- 리팩터링 전 코드

```js
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
  change = quantity _ plan.summerRate
else change = quantity _ plan.regularRate + plan.regularServiceCharge
```

- 리팩터링 후 코드

```js
charge = summer() ? summerCharge() : regularCharge()

function summer() {
  return !aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)
}
function summerCharge() {
  return quantity * plan.summerRate
}
function regularCharge() {
  return quantity * plan.regularRate + plan.regularServiceCharge
}
```

<br/>

## 조건식 통합하기

```js
// before
if (anEmployee.seniority < 2) return 0
if (anEmployee.monthsDisabled > 12) return 0
if (anEmployee.isPartTime) return 0

// after
if (isNotEligibleForDisability()) return 0

function isNotEligibleForDisability() {
  return (
    anEmployee.seniority < 2 ||
    anEmployee.monthsDisabled > 12 ||
    anEmployee.isPartTime
  )
}
```

### 배경

- 비교하는 조건은 다르나 결과로 수행하는 동작이 똑같은 경우에 할 수 있습니다.
- 조건부 코드를 통합하는 경우는 두가지 이유가 있습니다.
  - 여러 조각으로 나뉜 조건들을 하나로 통합함으로써 하는 일이 명확해집니다.
  - 함수 추출하기 까지 이어질 가능성이 높습니다.

### 절차

1. 해당 조건식을 모두에 보수효과가 없는지 확인합니다.
2. 조건문 두 개를 선택하여 두 조건문의 조건식들을 논리 연산자로 결합합니다.
3. 테스트합니다.
4. 조건을 하나만 남을 때까지 2~3 과정을 반복합니다.
5. 하나로 합쳐진 조건식을 함수로 추출할지 고민합니다.

### 예시

앞의 예시 말고도 다음과 같이 사용할 수 있습니다.

```js
// before
if (anEmployee.onVacation) if (anEmployee.seniority > 10) return 1
return 0.5

// after
if (anEmployee.onVacation && anEmployee.seniority > 10) return 1
else return 0
```

<br/>

## 중첩 조건문을 보호 구문으로 바꾸기

```js
// before
function getPayAmount() {
  let result
  if (isDead) result = deadAmount()
  else {
    if (isSeparated) result = separatedAmount()
    else {
      if (isRetired) result = retiredAmount()
      else result = normalPayAmount()
    }
  }
  return result
}

// after
function getPayAmount() {
  if (isDead) return deadAmount()
  if (isSeparated) return separatedAmount()
  if (isRetired) return retiredAmount()
  return normalPayAmount()
}
```

### 배경

- 조건문은 주로 두가지 형태로 쓰입니다.
  - 참인 경로와 거짓인 경로 모두 정상 동작으로 이어지는 형태
  - 한쪽만 정상인 형태
- 중첩 조건문을 보호 구문으로 바꾸기 리팩터팅의 핵심은 의도를 부각하는 데 의미가 있습니다.

### 절차

1. 교체해야 할 조건 중 가장 바깥 것을 선택하여 보호 구문으로 바꿉니다.
2. 테스트합니다.
3. 1~2 과정을 필요한 만큼 반복합니다.
4. 모든 보호 구문이 같은 결과를 반환한다면 보호 구문들의 조건식을 통합합니다.

### 예시

```js
function getPayAmount(employee) {
  let result
  if (employee.isSeparated) result = { amount: 0, reasonCode: 'SEP' }
  else {
    if (employee.isRetired) result = { amount: 0, reasonCode: 'RET' }
    else {
      // 급여 계산 로직
      lorem.ipsum(dolor.sitAet)
      consectetur(adipiscing).elict()
      sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua)
      ut.enim.ad(minim.veniam)
      result = someFinalComputation()
    }
  }
  return result
}
```

- 최상위 조건부터 보호 구문으로 바꿉니다.

```js
function getPayAmount(employee) {
  let result
  if (employee.isSeparated) return { amount: 0, reasonCode: 'SEP' }
  if (employee.isRetired) result = { amount: 0, reasonCode: 'RET' }
  else {
    // 급여 계산 로직
    lorem.ipsum(dolor.sitAet)
    consectetur(adipiscing).elict()
    sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua)
    ut.enim.ad(minim.veniam)
    result = someFinalComputation()
  }
  return result
}
```

- 테스트 후 다음 조건으로 넘깁니다.

```js
function getPayAmount(employee) {
  if (employee.isSeparated) return { amount: 0, reasonCode: 'SEP' }
  if (employee.isRetired) return { amount: 0, reasonCode: 'RET' }
  else {
    // 급여 계산 로직
    lorem.ipsum(dolor.sitAet)
    consectetur(adipiscing).elict()
    sed.do.eiusmod = tempor.incididunt.ut(labore) && dolore(magna.aliqua)
    ut.enim.ad(minim.veniam)
    return someFinalComputation()
  }
}
```

#### 조건 반대로 만들기

```js
function adjustedCapital(anInstrument) {
  let result = 0
  if (anInstrument.capital > 0) {
    if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {
      result =
        (anInstrument.income / anInstrument.duration) *
        anInstrument.adjustmentFactor
    }
  }
  return result
}
```

- 조건을 역으로 바꾸면서 보호구문을 추가합니다.

```js
function adjustedCapital(anInstrument) {
  let result = 0
  if (anInstrument.capital <= 0) return result
  if (anInstrument.interestRate > 0 && anInstrument.duration > 0) {
    result =
      (anInstrument.income / anInstrument.duration) *
      anInstrument.adjustmentFactor
  }
  return result
}
```

- 조건을 간소화하고, 조건식을 통합합니다.

```js
function adjustedCapital(anInstrument) {
  if (
    anInstrument.capital <= 0 ||
    anInstrument.interestRate <= 0 ||
    anInstrument.duration <= 0
  )
    return result
  return (
    (anInstrument.income / anInstrument.duration) *
    anInstrument.adjustmentFactor
  )
}
```

<br/>

## 조건부 로직을 다형성으로 바꾸기

<br/>

## 특이 케이스 추가하기

<br/>

## 어서션 추가하기

<br/>

## 제어 플래크를 탈출문으로 바꾸기
