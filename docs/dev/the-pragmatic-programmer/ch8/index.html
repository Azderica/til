<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">8. 실용주의 프로젝트 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch8"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="8. 실용주의 프로젝트 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="- 프로젝트가 진행됨에 따라 좀 더 큰 관점에서 프로젝트 전체 차원의 문제드렝 대해 이야기할 필요가 있습니다."><meta data-react-helmet="true" property="og:description" content="- 프로젝트가 진행됨에 따라 좀 더 큰 관점에서 프로젝트 전체 차원의 문제드렝 대해 이야기할 필요가 있습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch8"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch8" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch8" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.65b28b65.js" as="script">
<link rel="preload" href="/til/assets/js/main.8ffaa685.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">8. 실용주의 프로젝트</h1></header><div class="markdown"><ul><li>프로젝트가 진행됨에 따라 좀 더 큰 관점에서 프로젝트 전체 차원의 문제드렝 대해 이야기할 필요가 있습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-41-실용주의-팀"></a>Item 41. 실용주의 팀<a class="hash-link" href="#item-41-실용주의-팀" title="Direct link to heading">#</a></h2><ul><li>개인이 더 나은 프로그래머가 되게끔 도와주는 실용주의 기법들이 팀에도 적용됩니다.</li><li>팀 전체에 실용주의 기법들을 어떻게 적용할 수 있는지 간략하게 알아보도록 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="깨진-창문을-없애라"></a>깨진 창문을 없애라<a class="hash-link" href="#깨진-창문을-없애라" title="Direct link to heading">#</a></h3><ul><li>품질은 팀의 이슈입니다.</li><li>품질에 무성한 팀에 부지런한 개발자가 가면, 개발자의 열정이 줄어들게 됩니다.</li><li>팀 전체가 깨진 창문(아무도 고치려고 하지 않는 사소한 결점, imperfection)을 용납하지 않아야 합니다.</li><li>몇몇 팀 방법론에는 <strong>품질 관리 담당자</strong>가 있어 상품의 품질에 대한 책임을 팀에게서 위임을 받습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="삶은-개구리"></a>삶은 개구리<a class="hash-link" href="#삶은-개구리" title="Direct link to heading">#</a></h3><ul><li>프로젝트 개발의 열기속에서 전체 환경의 변화에 계속 유의하는 것은 어려운 일입니다.</li><li>개인보다는 팀이 삶은 개구리가 되기 쉽습니다.</li><li>모든 사람이 적극적으로 환경 변화를 감시해야 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="소통하라"></a>소통하라!<a class="hash-link" href="#소통하라" title="Direct link to heading">#</a></h3><ul><li>한 팀에 속한 개발자들이 서로 대화를 해야 하는것은 당연합니다.</li><li>팀은 나머지 세상과 명확히 의사소통해야 할 필요가 있습니다.</li><li>바깥의 사람들에게 무뚝뚝하게 과묵해 보이는 프로젝트 팀이야말로 최악입니다.</li><li>훌륭한 프로젝트 팀은 <strong>뚜렷한 특성</strong>을 갖습니다.</li><li>팀이 하나로서 의사소통하게 도와주는 간단한 마케팅 비결이 있습니다.<ul><li>프로젝트를 시작할 때 유별한 이름을 지어주는 것입니다.</li><li>팀 이름을 거리낌 없이 사용함으로 정체성 확립의 기반을 얻고, 작업에 관련되어 기억할만한 것을 얻을 수 있습니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="반복하지-마라"></a>반복하지 마라<a class="hash-link" href="#반복하지-마라" title="Direct link to heading">#</a></h3><ul><li>중복은 노력을 낭비하고, 유지보수의 악몽을 끌어들일 수도 있습니다.</li><li>어떤 팀은 팀원 한 명을 프로젝트 사서로 임명해서 문서와 코드 저장고를 관리하는 책무를 맡깁니다.</li><li>프로젝트가 한 사람의 사서가 감당하기에 너무 클 경우, 작업의 다양한 기능적 측면의 핵심 사안별로 사람들을 임명합니다.</li><li>질의응답을 주고받고 이를 저장 관리할 때는 그룹웨어 시스템과 유즈넷 뉴스그룹이 갖는 가치를 얻어야 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직교성"></a>직교성<a class="hash-link" href="#직교성" title="Direct link to heading">#</a></h3><ul><li>전통적인 팀 조직은 구식 소프트웨어 구축 모델은 폭포수 모델을 근간으로 합니다.</li><li>극잔적인 경우, 어떤 개발 문화에서는 책임을 엄격하게 분할하는데 이는 문제를 더욱 복잡하게 만듭니다.</li><li>프로젝트의 여러 활동이 독립적으로 이루어진다는 생각은 잘못입니다.</li></ul><blockquote><p>Tip 6. 팀을 기능 중심으로 조직하라</p></blockquote><ul><li>팀을 기능적으로 분리하는 것을 선호합니다.<ul><li>사람들은 작은 팀으로 나누고, 각 팀은 최종 시스템의 특정한 기능 측면에 대해 책임지도록 합니다.</li><li>팀은 개개인의 강점 위에 스스로 내부를 조직하게 합니다.</li></ul></li><li>기능 중심으로 팀을 조직하면 어떤 변화가 있더라도 전체가 영향받는 일이 없게 됩니다.<ul><li>책임감 있는 개발자들과 강력한 프로젝트 관리가 있을 경우에만 효과가 있습니다.</li></ul></li><li>좀 더 큰프로젝트의 팀들은 추가적인 리소스를 필요로 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자동화"></a>자동화<a class="hash-link" href="#자동화" title="Direct link to heading">#</a></h3><ul><li>일관성과 정확성을 보장하는 훌륭한 방법은 팀이 하는 모든 일을 자동화하는 것입니다.</li><li>자동화는 모든 프로젝트팀에게 필요불가결한 요소입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="덧칠을-언제-멈출지-알아라"></a>덧칠을 언제 멈출지 알아라<a class="hash-link" href="#덧칠을-언제-멈출지-알아라" title="Direct link to heading">#</a></h3><ul><li>팀은 개인들로 이루어집니다.</li><li>각 팀원이 자신의 방식대로 빛나게 해주어야 합니다.</li><li>프로젝트가 요구사항에 맞게 이루어지기에 딱 좋을 만큼의 구조를 제공합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-42-유비쿼터스-자동화"></a>Item 42. 유비쿼터스 자동화<a class="hash-link" href="#item-42-유비쿼터스-자동화" title="Direct link to heading">#</a></h2><p>프로젝트에서 일관성과 반복가능성을 확보하는 것이 중요합니다. 수작업은 일관성을 운에 맡기는 행동입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="전자동"></a>전자동<a class="hash-link" href="#전자동" title="Direct link to heading">#</a></h3><blockquote><p>Tip 61. 수작업 절차를 사용하지 마라</p></blockquote><ul><li>사람들은 컴퓨터만큼 반복가능하지 않으며 그것을 기대해서도 안됩니다.</li><li>인기 있는 자동화의 예시로 <code>cron</code> 등이 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="프로젝트-컴파일"></a>프로젝트 컴파일<a class="hash-link" href="#프로젝트-컴파일" title="Direct link to heading">#</a></h3><ul><li>프로젝트 컴파일은 귀찮을 일이며 믿을 만하고 반복가능하게 만들어야 합니다.</li><li>대표적인 예시로 <code>makefile</code>로 프로젝트 컴파일을 하며 이는 스크립트로된 자동 과정이기 때문에 매우 좋습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="코드-생성"></a>코드 생성<a class="hash-link" href="#코드-생성" title="Direct link to heading">#</a></h3><ul><li>중복의 해악에서 공통의 소스에서 지식을 유도하기 위해서는 코드 생성을 하는 것이 좋습니다.</li><li>동일한 종류의 규칙들을 사용해서 소스코드, 헤더 파일 혹은 문서까지도 다른 형태의 자료에서 자동으로 생성할 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="회귀-테스트"></a>회귀 테스트<a class="hash-link" href="#회귀-테스트" title="Direct link to heading">#</a></h4><ul><li>개개 모듈 혹은 전체 서브시스템에 대해 회귀 테스트가 실행되도록 makefile을 사용할 수도 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="빌드-자동화"></a>빌드 자동화<a class="hash-link" href="#빌드-자동화" title="Direct link to heading">#</a></h3><ul><li><strong>빌드</strong>는 비어있는 디렉터리 하나를 가지고 프로젝트를 밑바닥에서부터 만드는 과정</li><li>일반적인 빌드의 단계는 다음과 같습니다.<ul><li>(1) repository에서 소스코드를 끄집어 냅니다.</li><li>(2) 프로젝트를 밑바닥부터 빌드합니다. (각 빌드마다 모종의 릴리스 번호나 버전, 날짜 등이 표시됩니다.)</li><li>(3) 배포용 이미지를 만듭니다.</li><li>(4) 테스트를 실행합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="최종-빌드"></a>최종 빌드<a class="hash-link" href="#최종-빌드" title="Direct link to heading">#</a></h4><ul><li>상품으로 선적하려고 하는 최종 빌드는 주기적인 빌드와는 다른 요구사항이 있을 수도 있습니다. 최종 빌드에서는 저장소를 잠그고 릴리스 번호를 태그로 붙이는 작업이 필요할 수도 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자동화된-관리"></a>자동화된 관리<a class="hash-link" href="#자동화된-관리" title="Direct link to heading">#</a></h3><ul><li>프로그래머는 모든 시간을 프로그래밍에 투자할 수 없습니다.</li><li>기억은 잊기 때문에 의존하지 않도록해야합니다.</li><li>목표는 자동화, 무인화이며 내용 주도(content-driven)인 작업흐름을 유지하는 것입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="웹사이트-생성"></a>웹사이트 생성<a class="hash-link" href="#웹사이트-생성" title="Direct link to heading">#</a></h4><ul><li>많은 개발 팀들이 프로젝트 내에서 의사소통을 위해 내부 웹사이트를 사용하는데 이는 좋은 생각입니다.</li><li>다만, 웹사이트를 유지보수하는데 너무 많은 시간을 허비해도 안되고, 그렇다고 오랫동안 손을 안되는 것도 좋지않습니다.</li><li>코드에서 추출된 문서나 요구사항 분석, 설계 문서, 그림, 차트, 그래프 등 모두가 정기적으로 웹에 올라가야 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="승인-과정"></a>승인 과정<a class="hash-link" href="#승인-과정" title="Direct link to heading">#</a></h4><ul><li>몇몇 프로젝트에서는 지켜야 할 여러 가지 다양한 행정 절차가 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="중-머리"></a>중 머리<a class="hash-link" href="#중-머리" title="Direct link to heading">#</a></h3><ul><li>소프트웨어를 개발하는 사람들이 때로는 형편 없는 도구를 쓰기도 합니다.</li><li>반복적이고 지루한 작업은 컴퓨터에게 시켜야 합니다. 이는 컴퓨터가 더 잘하는 일이고, 우리는 더 중요한 어려운 일들이 있습니다.</li></ul><blockquote><p>개인 의견. 과거 vi 시절에만 이말이 먹히지, 현대 개발은 IDE에서 지원해주는 것도 너무 많다고 생각. 굳이 무기가 있는데 맨몸으로 싸워햐할까.</p></blockquote><blockquote><p>Q. 일할 때 자신의 습관을 보고, 반보고디는 작업이 있는가</p></blockquote><blockquote><p>Q. 프로젝트 문서 작업 가운데 얼마만틈을 자동화할 수 있을 지 생각해봐라.</p></blockquote><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-43-가차-없는-테스트"></a>Item 43. 가차 없는 테스트<a class="hash-link" href="#item-43-가차-없는-테스트" title="Direct link to heading">#</a></h2><ul><li>많은 개발자가 테스트를 싫어합니다.</li><li>실용주의 프로그래머들은 당장 버그를 찾도록 내몰리지만, 이를 통해 나중에 다른 사람이 자기 버그를 발견하게 되는 수치를 피할 수 있는 것입니다.</li></ul><blockquote><p>Tip 62. 일찍 테스트하고, 자주 테스트하고, 자동으로 테스트하라.</p></blockquote><ul><li>코드를 작성하자마자 테스트해야합니다.</li><li>자동화된 테스트를 사용하는 것이 테스트 계획을 상세하게 짜는 것보다 성공 가능성이 높습니다.</li><li>버그가 빨리 발견될수록 고치는 비용이 적어집니다.<ul><li><strong>코드 조금, 테스트 조금</strong> 이라는 격언도 있습니다.</li></ul></li><li>훌륭한 프로젝트에는 제품 코드보다 테스트 코드가 더 많을지 모릅니다.</li><li>테스트를 통과했다는 것은 그 코드가 &quot;완료되었다, done&quot; 라고 말할 수 있는 높은 수준의 확신을 갖게 합니다.</li></ul><blockquote><p>Tip 63. 모든 테스트가 통과하기 전엔 코딩이 다 된 게 아니다.</p></blockquote><ul><li>프로젝트 범위에서 이루어지는 테스트는 세 가지 측면으로 봐야합니다. (무엇, 어떻게, 언제)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="무엇을-테스트할지"></a>무엇을 테스트할지<a class="hash-link" href="#무엇을-테스트할지" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단위-테스트"></a>단위 테스트<a class="hash-link" href="#단위-테스트" title="Direct link to heading">#</a></h4><ul><li><strong>단위 테스트</strong>는 하나의 모듈을 테스트하는 코드입니다.</li><li>단위 테스트는 이 항목에서 논의할 다른 모든 형태 테스트의 근간이 됩니다.</li><li>모든 모듈을 갖고 진행하기 전에 단위 테스트를 통과해야합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="통합-테스트"></a>통합 테스트<a class="hash-link" href="#통합-테스트" title="Direct link to heading">#</a></h4><ul><li>통합 테스트는 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 보여줍니다.</li><li>계약(contract)이 제대로 되어 있고 테스트가 잘 되어 있다면, 어떤 통합 문제건 쉽게 발견할 수 있습니다.</li><li>시스템에서 버그의 큰 원인이 이를 제대로 구성하지 않아서인 경우가 많습니다.</li><li>통합 테스트는 단위 테스트의 확장이며, 전체 서브시스템이 계약을 제대로 지키는지 테스트하는 것 뿐입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="유효성-평가validation와-검증verification"></a>유효성 평가(validation)와 검증(verification)<a class="hash-link" href="#유효성-평가validation와-검증verification" title="Direct link to heading">#</a></h4><ul><li>실행가능한 사용자 인터페이스나 프로토타입이 갖춰지자마자, 사용자들이 정말로 필요로 하는지에 대한 확인이 필요합니다.</li><li>시스템의 기능적 요구사항을 충족하는지도 테스트해봐야합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자원-고갈-에러-그리고-복구"></a>자원 고갈, 에러, 그리고 복구<a class="hash-link" href="#자원-고갈-에러-그리고-복구" title="Direct link to heading">#</a></h4><ul><li>이상적인 상황에서 시스템이 올바르게 작동한다는 확신이 있다면, 시스템이 실세계의 상황에서 어떻게 작동할지도 알아야합니다.</li><li>실세계에서 프로그램은 무한한 자원을 보장받지 못합니다. 여러 제한 사항에 대해 고려해야 합니다.<ul><li>메모리, 디스크 공간, CPU 대역폭, 벽시계 시간, 디스크 대역폭, 네트워크 대역폭 등등</li></ul></li><li>모든 실패가 복구까능한 것은 아니지만, 이를 최선으로 방지할 수는 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="성능performance-테스트"></a>성능(performance) 테스트<a class="hash-link" href="#성능performance-테스트" title="Direct link to heading">#</a></h4><ul><li>성능 테스트의 테스트 역시 프로젝트의 중요한 부분입니다.</li><li>초당 예상 사용자 및 접속 혹은 트랜잭션 숫자를 염두에 두는 것이 좋습니다.</li><li>어떤 애플리케이션은 부하를 현실적으로 시뮬레이션하기 위해 특화된 테스트 하드웨어나 소프트웨어가 필요할 수도 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="사용편의성usability-테스트"></a>사용편의성(usability) 테스트<a class="hash-link" href="#사용편의성usability-테스트" title="Direct link to heading">#</a></h4><ul><li>사용편의성(usability) 테스트는 위의 테스트와 다르게 실제 환경의 조건 하에 실제 사용자들이 시행합니다.</li><li>인간적 요소라는 측면에서 사용편의성을 바라봅니다.</li><li>유호성 평가와 검증과 마찬가지로, 사용편의성 테스트는 보정할 시간이 있을 때에 되도록 일찍 시행해야 합니다.</li></ul><blockquote><p>설계/방법론 테스트</p></blockquote><ul><li>코드 설게 자체와 소프트웨어를 만드는데 사용한 방법론을 모두 테스트할 수 잇습니다.</li><li>메트릭(코드의 다양한 측면에 대한 측정)을 분석해서 가능합니다.</li><li>가장 단순한 메트릭은 코드 줄 수 입니다.</li><li>어던 메트릭은 &#x27;통과 점수&#x27;를 제공하도록 만들어졌지만, 어떤 것들은 그 점수를 서로 비교해야지만 의미가 있습니다.</li><li>특히 어떤 모듈이 다른 것들과 큰 차이가 있을 경우, 그래도 괜찮은지 자문해봐야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="어떻게-테스트할까"></a>어떻게 테스트할까<a class="hash-link" href="#어떻게-테스트할까" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="회귀-테스트-1"></a>회귀 테스트<a class="hash-link" href="#회귀-테스트-1" title="Direct link to heading">#</a></h4><ul><li>이전 값과 현재 테스트의 출력을 비교합니다.</li><li>오늘 고친 버그가 어제 작동하던 것들을 망치지 않는다고 확신할 수 있습니다.</li><li>위에서 언급한 모든 테스트는 새로운 코드를 개발하면서 이전의 것을 잃지 않았다는 것을 확신시켜 주는 회귀 테스트로 실행할 수 있습니다. (성능, 계약, 유효성 등을 검증하기 위해)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테스트-데이터"></a>테스트 데이터<a class="hash-link" href="#테스트-데이터" title="Direct link to heading">#</a></h4><ul><li>테스트를 실행할 데이터는 <strong>실세계 데이터</strong>와 <strong>합성 데이터</strong>입니다.</li><li>실세계 데이터는 현실에서 옵니다.</li><li>합성(synthetic) 데이터는 어떤 통계적 조건하에서 인공적으로 생성됩니다.<ul><li>실세계 샘플이 제공하는 것보다 많은 데이터가 필요한 경우</li><li>경계 조건을 테스트할 데이터가 필요한 경우</li><li>특정 통계 특성을 보이는 데이터가 필요한 경우</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="gui-시스템-구동"></a>GUI 시스템 구동<a class="hash-link" href="#gui-시스템-구동" title="Direct link to heading">#</a></h4><ul><li>GUI의 비중이 큰 시스템을 테스트하려면 많은 경우 특화된 테스트 도구가 필요합니다.</li><li>조금 덜 세련된 도구는 테스트되는 소프트웨어의 버전과 테스트 스크립트 자체 간에 높은 결합(coupling)을 요구합니다.</li><li>모든 것을 자동화할 수는 없습니다.</li><li>결합도가 낮은 코드를 작성하는 많은 이점 중 하나는 좀 더 모듈화된(modular) 테스트가 가능하다는 것입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테스트를-테스트하기"></a>테스트를 테스트하기<a class="hash-link" href="#테스트를-테스트하기" title="Direct link to heading">#</a></h4><ul><li>완벽한 소프트웨어을 작성할 수 없기 때문에, 완벽한 테스트 소프트웨어 역시 작성할 수 없습니다. 그렇다면 테스트를 테스트할 필요가 있습니다.</li><li>어떤 버그를 감지해내는 테스트를 작성한 후, 그 버그가 의도적으로 생기도록 한 다음 테스트가 불평을 해대는지 확인합니다. 이를 통해 테스트가 버그를 잡아낼 것이라는 확신을 할 수 있습니다.</li></ul><blockquote><p>Tip 64. 파괴자를 써서 테스트를 테스트하빈다.</p></blockquote><ul><li>정말 테스트에 대해 심각하게 생각한다면 <strong>프로젝트 파괴자</strong>를 임명할 수 있습니다.<ul><li>파괴자는 소스 트리의 카피를 별도로 만든다음 고의로 버그를 심고 테스트가 잡아낼지 검증하는 것입니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="철저히-테스트하기"></a>철저히 테스트하기<a class="hash-link" href="#철저히-테스트하기" title="Direct link to heading">#</a></h4><ul><li>테스트가 올바르다는 확신이 들고, 버그를 찾아내도 철저하게 테스트했는지는 확신할 수 없습니다.</li><li>이때는 완벽을 바라지말고 <strong>커버리지 분석 도구</strong>를 통해 테스트 중의 코드를 보고, 어느 라인이 실행되지 않았는지 기억합니다.</li><li>코드가 모든 라인이 실행되더라도, 정말로 중요한 것은 프로그램이 갖는 상태 수입니다.</li></ul><blockquote><p>Tip 65. 코드 커버리지보다 상태 커버리지를 테스트하라</p></blockquote><ul><li>훌륭한 코드 커버리지가 있어도 테스트를 위해 사용하는 데이터는 여전히 상당한 영향을 미칠 뿐 아니라, 실행하는 순서가 가장 큰 영향을 미칠 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="언제-테스트할까"></a>언제 테스트할까<a class="hash-link" href="#언제-테스트할까" title="Direct link to heading">#</a></h3><ul><li>테스트는 대부분 자동화되어야 합니다.<ul><li>여기서의 자동화는 테스트 결과 해석의 자동화를 포함합니다.</li></ul></li><li>테스트를 되도록 자주, 소스 저장소에 넣기전 등에 하는 것이 좋습니다.</li><li>자동화를 하는 것이 힘들다면 task에 모든 필요 자원을 넣고 일정표에 넣어둡니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="그물-조이기"></a>그물 조이기<a class="hash-link" href="#그물-조이기" title="Direct link to heading">#</a></h3><ul><li>현존하는 테스트의 그물을 빠져 나가는 버그가 있으면 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 합니다.</li></ul><blockquote><p>Tip 66. 버그는 한 번만 잡아라</p></blockquote><ul><li>인간 테스터가 버그를 찾으면, 그 이후는 인간이 잡으면 안됩니다. 즉 자동화해야합니다.<ul><li>무조건, 매번, 예외없이, 아무리 사소한 것일지라도 자동화 테스트를 수정화해야 합니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-44-결국은-모두-글쓰기"></a>Item 44. 결국은 모두 글쓰기<a class="hash-link" href="#item-44-결국은-모두-글쓰기" title="Direct link to heading">#</a></h2><ul><li>개발자들은 문서화를 그리 대단하게 생각하지 않습니다.</li><li>실용주의 프로그래머들은 문서화를 전체 개발 프로세스의 필요불가결한 부분으로 포용합니다.<ul><li>노력을 중복거나 시간을 낭비하지 않고, 문서를 늘 손에 닿는 가까이에 둡니다.</li></ul></li><li>실용주의 원칙 모두를 코드느 물론 문서화에 적용시키면 좋습니다.</li></ul><blockquote><p>Tip 67. 한국어도 하나의 프로그래밍 언어인 것처럼 다루라.</p></blockquote><ul><li>프로젝트에서 생산되는 문서에서 기본적으로 내부, 외부의 두 종류가 있습니다.<ul><li>내부 문서에는 소스코드, 주석, 설계와 테스트 문서 등이 포함됩니다.</li><li>외부 문서에는 사용자 메뉴얼 같이 외부 세계로 출간되거나 출하되는 모든 것이 포함됩니다.</li></ul></li><li>모든 문서는 코드의 거울이며 불일치가 있으면 중요한 것은 코드입니다.</li></ul><blockquote><p>Tip 68. 문서가 애초부터 전체의 일부가 되게 하고, 나중에 집어넣으려고 하지 말라.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="코드-내의-주석"></a>코드 내의 주석<a class="hash-link" href="#코드-내의-주석" title="Direct link to heading">#</a></h3><ul><li>코드에는 주석이 있어야 하지만 너무 많은 것은 너무 적은 것만큼 좋지 않습니다.</li><li>일반적으로 주석은 왜 이렇게 되어 있는지,. 그 목적을 논해야 합니다. 코드가 이미 어떻게 되어 있는지 보여 주기 때문에 이에 대해 주석을 다는 것은 DRY원칙 위반입니다.</li><li>소스코드에 주석을 다는 것은 예컨대 공학적인 트레이드오프나 어떤 결정의 이유, 어떤 대안을 버렸는지 등 다른 곳에서 문서화할 수 없는, 바로 프로젝트에서 잘 빠져 나가는 부분들을 문서화하기 위한 완벽한 기회가 됩니다.</li><li>변수 이름은 물론 선별해서 유의미한 것으로 해야합니다.</li><li>의미 없는 이름보다 더 고약한 것은 오해를 불러일으키는 이름입니다.</li><li>대표적인 문서화 도구는 <code>JavaDoc</code>이 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * 주어진 날짜 범위 안의 표본에서 정점(최대) 값을 찾습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * @param aRange 데이터를 찾아볼 날자의 범위</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * @param aThreshold 유효한 값으로 간주할 최소값</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * @return 찾은 값, 만약 최소값과 크기가 같거나 더 큰 값을 찾을 수 없으면 &lt;code&gt;null&lt;/code&gt;을 돌려줍니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Sample findPeek(DataRange aRange, double aThreshold)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>소스 주석에 나오지 말야 할 것들의 목록은 다음과 같습니다.</p><ul><li>파일 내의 코드가 익스포트(export)  하는 함수들의 목록<ul><li>대신해 소스 코드를 분석해주는 프로그램을 사용할 것, 최신 버전을 보장 받을 수 있음.</li></ul></li><li>리버전 기록<ul><li>이는 소스코드 관리 시스템이 해주는 일입니다.</li></ul></li><li>이 파일이 사용하는 파일 목록<ul><li>자동화 도구를 사용하면 훨씬 더 정확한 목록을 얻을 수 있습니다.</li></ul></li><li>파일 이름</li><li>만약 이것이 파일 속에 드러나야 한다면 수작업으로 관리하면 안됩니다.</li></ul><p>소스 파일에 나타나야만 하는 가장 중요한 정보 중 하나는 저자의 이름입니다.</p><p>적절한 주석이 제자리에 있으면 <code>JavaDoc</code>이나 <code>DOC++</code> 같은 도구가 API 수준의 문서를 자동으로 추출, 포맷까지 해줄 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="실행가능한-문서"></a>실행가능한 문서<a class="hash-link" href="#실행가능한-문서" title="Direct link to heading">#</a></h3><ul><li>명세 문서를 소스로 선택하는 것도 좋은 방법 중 하나입니다. (DRY 원칙을 위해)</li><li>문서가 데이터베이스 스키마인 경우, 프로세스의 모델이나 뷰가 대표적인 예시가 됩니다.</li><li>문서가 마크업 명령어로 된 일반 텍스트로 저장되어 있다면 펄과 같은 도구를 통해 추출할 수도 있습니다.</li><li>이를 통해서 <strong>문서는 프로젝트 개발에서 중요한 부분</strong>이 됩니다.</li><li>JavaDoc이나 DOC++ 같은 도구를 이와 유사한 방식을 사용해서 소스코드에서 API 수준의 문서를 만들 수 있습니다.</li></ul><blockquote><p>만약 문서가 일반 텍스트가 아니라면? 아래의 방법이 있습니다.</p></blockquote><ul><li>매크로 작성.</li><li>문서를 종속시키기</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테크니컬-라이터"></a>테크니컬 라이터<a class="hash-link" href="#테크니컬-라이터" title="Direct link to heading">#</a></h3><ul><li>프로젝트에 관련된 전문 테크니컬 라이터들이 있다고 해도, 프로그래머들이 신경을 써야합니다.</li><li>글을 쓴느 사람이라면 실용주의 프로그래머가 가진 것도 동일한 기본 원칙을 지키는 것이 중요합니다.<ul><li>DRY 원칙, 직교성, 모듈-뷰 개념, 자동화, 스크립팅의 사용</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="찍기나-짜기"></a>찍기나 짜기<a class="hash-link" href="#찍기나-짜기" title="Direct link to heading">#</a></h3><ul><li>문서화는 단지 <strong>스냅숏</strong>입니다.</li><li>문서의 외양은 내용과는 독립되어 있어야합니다.</li><li>마크업 시스템을 사용하고 있으면 다양한 출력 포맷을 구성할 수 있습니다.</li><li>워드 프로세서도 비슷한 기능이 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="마크업-언어"></a>마크업 언어<a class="hash-link" href="#마크업-언어" title="Direct link to heading">#</a></h3><ul><li>규모가 큰 문서화 프로젝트에서라면 좀 더 현대적인 문서 마크업체계를 사용할 것을 권하고 싶습니다.</li><li>대표적인 예시로 문서를 정의하는데 DocBook을 사용합니다.</li><li>원본 마크업이 하이퍼링크를 포함해 필요한 모든 개념을 표현하기에 부족함이 없으면, 다른 형태로 변환이나 자동화가 싶습니다.</li><li>문서와 코드는 밑에 깔려 있는 동일 모델에 대한 서로 다른  뷰이며, 다른 것은 오직 뷰입니다.<ul><li>즉, 문서화를 프로젝트 작업 흐름에 어긋나게 둬서는 안됩니다.</li><li>코드를 다룰 때와 똑같은 관심을 문서화에도 주어야 합니다.</li></ul></li></ul><blockquote><p>Q. 작성한 소스코드를 설명하는데 주석을 제대로 달았는지, 안달았는지? 안달았다면 이유는?</p></blockquote><blockquote><p>Q. 때로는 설계가 명확하지 않으므로 설계를 문서화하는 것이 불편할 때가 있습니다. 근데 이경우에는 굳이 필요할까요?</p></blockquote><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-45-위대한-유산"></a>Item 45. 위대한 유산<a class="hash-link" href="#item-45-위대한-유산" title="Direct link to heading">#</a></h2><ul><li>이론적으로 명세를 올바르게 구현했다면 성공적인 애플리케이션이나, 돈도 이론적으로 벌게 됩니다.</li><li>현실적으로 프로젝트의 성공은 사용자들의 <strong>기대</strong>를 얼마나 잘 충족하는가에 따라 측정됩니다.</li></ul><blockquote><p>Tip 69. 사용자의 기대를 부드럽게 넘어서라</p></blockquote><ul><li>이러한 팁을 실행하기 위해서는 몇 가지 작업이 필요합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="기대를-상호-소통하기"></a>기대를 상호 소통하기<a class="hash-link" href="#기대를-상호-소통하기" title="Direct link to heading">#</a></h3><ul><li>사용자는 처음에 그들이 원하는 바에 대한 어떤 비전을 가지고 우리르 찾아옵니다.<ul><li>불완전하고 모순이 있거나 혹은 기술적으로 불가능할 수도 있지만, 그 기대는 사용자의 것입니다.</li></ul></li><li>그들의 필요에 대한 이해가 깊어질수록, 그들의 기대가 충족될 수 없는 영역이나 혹은 그들의 기대가 너무 보수적으로 보이는 영역을 발견하게 됩니다. 이 부분을 소통하는 것이 우리의 역활 중 하나입니다.<ul><li>애플리케이션이 해결하기로 한 비지니스 문제에 대해 절대로 눈을 떼지 않는 것이 중요합니다.</li></ul></li><li>이러한 과정을 몇몇 컨설턴트들은 이 과정을 &#x27;기대 관리&#x27;라고 부릅니다.<ul><li><strong>사용자가 시스템에서 무엇을 얻기를 기대해야 할지에 대해 적극적으로 제어(control)하는 것</strong>을 일컫는 말입니다.</li></ul></li><li>프로세스를 용이하게 하기 위해 사용할 수 있는 기술로는 <code>예광탄</code>이나 <code>프로토타입과 포스트잇</code>이 있습니다.<ul><li>위 두가지   방법을 통해 사용자와 소통하는 훈련을 하게 해줍니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="한-계단-더"></a>한 계단 더<a class="hash-link" href="#한-계단-더" title="Direct link to heading">#</a></h3><ul><li>사용자와 가깝게 그들의 기대를 공유하고 하는 일에 대해 소통하면서 작업을 했다면, 프로젝트가 끝나고 산출물이 전달되었을 때 <strong>사용자를 놀래켜 주려고(기쁘게)</strong> 노력해야합니다.</li><li>일반적인 사용자가 좋아할만한 것은 아래와 같습니다.<ul><li>풍선 혹은 툴 팁 도움말</li><li>키보드 단축키</li><li>사용자 메뉴얼의  부록으로 만든 빠른 참조</li><li>색깔 입히기</li><li>로그 분석기</li><li>자동 설치</li><li>시스템의 상태를 체크하는 도구</li><li>훈련 목적으로 여러 버전의 시스템을 실행시킬 수 있는 기능</li><li>각 회사나 조직을 위해 만든 스플래시 스크린</li></ul></li><li>위의 기능은 표면적인 부분이므로 시스템에 부담을 주지 않습니다. 다만 이 부분이 장애를 만들어서는 절대 안됩니다.</li></ul><blockquote><p>Q. 프로젝트에 대해 실망했던가 있는가 (만들었는게 별로 맘에 안들때)</p></blockquote><blockquote><p>Q. 소프트웨어를 전달할 때 사용자는 뭐라고 언급하는가</p></blockquote><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-46-오만과-편견"></a>Item 46. 오만과 편견<a class="hash-link" href="#item-46-오만과-편견" title="Direct link to heading">#</a></h2><ul><li>실용주의 프로그래머들은 책임을 회피하지 않습니다. 도전을 수용하고 전문 지식이 널리 알려지는 것을 기뻐합니다. 설계 혹은 코드에 대한 책임을 맡는다면, 스스로 자랑스러워할 만한 일입니다.</li></ul><blockquote><p>Tip 70. 자신의 작품에 서명하라</p></blockquote><ul><li>프로젝트에 서명하는 것을 자랑스러워야 합니다.</li><li>프로젝트에서는 코드 소유권 때문에 협력에 차질이 생길 수도 있습니다.<ul><li>코드는 고립되어서는 안됩니다.</li></ul></li><li>개발자간에 황금률(자신에게 해주기 바라는 대로 남에게 행하라)와 상호 존중이라는 기반을 지키는 것이 핵심입니다.</li><li>익명성은 특히 큰 프로젝트에서 적당주의, 실수, 태만 그리고 나쁜 코드의 번식지가 될 수 있씁니다.</li><li>코드에는 주인이 있어야하지만 꼭 개인일 필요는 없습니다.</li><li>소유권에 대한 긍지를 가져야합니다.</li><li>서명이 품질의 보증수표로 인식되게 만들어야 합니다.<ul><li>우리의 이름을 보고 튼튼하고 잘 작성되고 제대로 테스트되었으며 또 훌륭히 문서화되었을 것이라고 기대하게 만듭니다.</li><li>그것이 프로페셔널입니다.</li></ul></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/the-pragmatic-programmer/ch8.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-11-14T09:30:00.000Z" class="lastUpdatedDate_1WI_">11/14/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/the-pragmatic-programmer/ch7"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 7. 프로젝트 전에</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">1. 소개 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-41-실용주의-팀" class="table-of-contents__link">Item 41. 실용주의 팀</a><ul><li><a href="#깨진-창문을-없애라" class="table-of-contents__link">깨진 창문을 없애라</a></li><li><a href="#삶은-개구리" class="table-of-contents__link">삶은 개구리</a></li><li><a href="#소통하라" class="table-of-contents__link">소통하라!</a></li><li><a href="#반복하지-마라" class="table-of-contents__link">반복하지 마라</a></li><li><a href="#직교성" class="table-of-contents__link">직교성</a></li><li><a href="#자동화" class="table-of-contents__link">자동화</a></li><li><a href="#덧칠을-언제-멈출지-알아라" class="table-of-contents__link">덧칠을 언제 멈출지 알아라</a></li></ul></li><li><a href="#item-42-유비쿼터스-자동화" class="table-of-contents__link">Item 42. 유비쿼터스 자동화</a><ul><li><a href="#전자동" class="table-of-contents__link">전자동</a></li><li><a href="#프로젝트-컴파일" class="table-of-contents__link">프로젝트 컴파일</a></li><li><a href="#코드-생성" class="table-of-contents__link">코드 생성</a></li><li><a href="#빌드-자동화" class="table-of-contents__link">빌드 자동화</a></li><li><a href="#자동화된-관리" class="table-of-contents__link">자동화된 관리</a></li><li><a href="#중-머리" class="table-of-contents__link">중 머리</a></li></ul></li><li><a href="#item-43-가차-없는-테스트" class="table-of-contents__link">Item 43. 가차 없는 테스트</a><ul><li><a href="#무엇을-테스트할지" class="table-of-contents__link">무엇을 테스트할지</a></li><li><a href="#어떻게-테스트할까" class="table-of-contents__link">어떻게 테스트할까</a></li><li><a href="#언제-테스트할까" class="table-of-contents__link">언제 테스트할까</a></li><li><a href="#그물-조이기" class="table-of-contents__link">그물 조이기</a></li></ul></li><li><a href="#item-44-결국은-모두-글쓰기" class="table-of-contents__link">Item 44. 결국은 모두 글쓰기</a><ul><li><a href="#코드-내의-주석" class="table-of-contents__link">코드 내의 주석</a></li><li><a href="#실행가능한-문서" class="table-of-contents__link">실행가능한 문서</a></li><li><a href="#테크니컬-라이터" class="table-of-contents__link">테크니컬 라이터</a></li><li><a href="#찍기나-짜기" class="table-of-contents__link">찍기나 짜기</a></li><li><a href="#마크업-언어" class="table-of-contents__link">마크업 언어</a></li></ul></li><li><a href="#item-45-위대한-유산" class="table-of-contents__link">Item 45. 위대한 유산</a><ul><li><a href="#기대를-상호-소통하기" class="table-of-contents__link">기대를 상호 소통하기</a></li><li><a href="#한-계단-더" class="table-of-contents__link">한 계단 더</a></li></ul></li><li><a href="#item-46-오만과-편견" class="table-of-contents__link">Item 46. 오만과 편견</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.65b28b65.js"></script>
<script src="/til/assets/js/main.8ffaa685.js"></script>
</body>
</html>