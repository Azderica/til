---
sidebar_position: 6
---

# 6. 코딩하는 동안 해야 할 일들

- 코딩은 기계적인 작업이 아니며 프로그래밍이 정확하고 생산적으로 작동하면서 천수를 누리도록 하기 위해서는 사려 깊은 생각과 판단을 통한 결정이 필요합니다.
- 우연에 맡기는 프로그래밍(programming by coincidence)는 좋지 않습니다.
- 실용주의 프로그래머는 모든 코드를 비판적으로 바라봐야하며 자신의 코드도 예외가 아닙니다.
- 언제나 코드를 작성할 때는 언젠가 그 코드를 테스트하게 될 것이라는 생각을 가지고 있어야합니다.
- 마음을 늘 깨어있도록 유지하는 것은 여러 문제를 막을 수 있습니다.

## Item 31. 우연에 맡기는 프로그래밍

개발자는 수많은 함정속에서 개발을 하며, 잘못된 결론을 내리지 않도록 언제나 주의해야 합니다.

### 프로그래밍을 우연에 맡기면 어떻게 되는가

- 코드가 어떻게 돌아가는지 몰랐기 때문에 왜 안돌아가게 되는지 모르게 됩니다.
- 테스트를 했을 때, 코드가 잘 돌아가는 것처럼 보였지만 이것이 우연의 산물입니다.

#### 우연적 구현

- 우연적 구현(accidents of implementation)은 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일입니다.
- 결과물이 괜찮다고, 잘 작동한다고 건드리지 않으면 여러 문제가 발생할 수 있습니다.
  - 정말로 제대로 돌아가는 것이 아닌 우리에게만 그런 것 처럼 보이는 건지
  - 의존하는 조건이 단순히 우연인 경우이고, 다른상황에서는 이상하게 작동할지도 모릅니다.
  - 문서화되지 않는 동작은 라이브러리의 다음 릴리스에서 변경될 가능성이 있습니다.
  - 불필요한 추가 호출은 코드를 더 느리게 만듭니다.
  - 추가로 호출한 루틴 때무넹 새로운 버그들이 코드에 들어올 가능성이 있습니다.

#### 우연적 맥락

- 우연적 맥락(accidents of context)도 마찬가지로 생길 수 있습니다.
  - 어떤 GUI 환경용 애플리케이션에서 쓰려고 모듈을 작성한다고 해도 반드시 GUI가 있어야만 돌아갈 필요는 없습니다.

#### 암묵적인 가정

- 요구사항을 만들어 내는 것부터 테스트에 이르기까지 어느 차원에서든 우연은 잘못된 길로 이끌 수 있습니다.
  - 테스팅이 특히 거짓 원인과 우연적인 결과로 가득 찬 영역입니다.
- 모든 차원에서 사람들은 많은 것을 가정하고 작업합니다. 그러나 이는 문서화되는 경우가 드물며 가정이 다른 경우가 많습니다.

> Tip 44. 우연에 맡기는 프로그래밍을 하지 말라

### 의도적으로 프로그래밍하기

의도적으로 프로그래밍을 하는 것은 도움이 됩니다.

- 언제나 자기가 지금 무엇을 하고 있는지 알아야합니다.
- 맹목적으로 코딩하지 말라
- 계획을 세우고 그것을 바탕으로 진행하라
- 신뢰할 수 있는 것에만 기대하라
- 여러분의 가정을 문서로 남겨라
- 코드만 테스트할 것이 아니라 세운 가정도 테스트해봐야합니다.
- 노력을 기울일 대상의 우선순위를 정하라
- 과거의 노예가 되지 마라

<br/>

## Item 32. 알고리즘의 속도

### 알고리즘을 추정한다는 말의 의미는 무엇인가

- 간단한 몇몇 알고리즘을 제외한 대부분의 알고리즘은 가변적인 입력 데이터를 다룹니다.
- 입력의 크기가 클수록, 알고리즘의 수행시간이 길어지거나 사용하는 메모리의 양이 늘어납니다.
- 반복문이나 재귀 함수를 담고 있는 코드를 작성할 때는 무의식으로 수행시간과 메모리 요구량을 계산하는 것이 좋으며 O() 표기법 등이 좋습니다.

### O() 표기법

- O() 표기법은 근사값을 다루기 위한 수학적 방법입니다. (상한선을 의미)
- ex) 100개를 처리하는데 1초 걸리는 루틴이 있을 때, 1000개 처리를 하는 경우?
  - O(1) : 1초
  - O(log(N)) : 약 3초
  - O(n^2) : 한참...

### 상식적인 추정

- 간단한 반복문(loop) : O(n)일 확률이 높음
- 겹친 반복분 : O(n \* m)
- 반씩 자르기 : O(log(n))
- 나눠서 정복 : O(n \* log(n))
- 조합적 : 일반적으로 매우 깁니다.

### 실전에서의 알고리즘 속도

- 대부분 라이브러리의 정렬 루틴이 성능이 좋습니다.
- 코드를 실행할 때 외부 요인에 따라 달라진다면, 잠시 작업을 멈추고 커다란 수가 들어왔을 경우 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해 보는 것이 좋습니다.

> Tip 45. 여러분 알고리즘의 차수를 추정하라

- 코드의 실행시간이 얼마나될지, 또는 메모리를 얼마나 사용할지 확실하지 않다면 입력 레코드의 수나 혹은 런타임에 영향을 줄 것이라고 생각되는 요소를 바꿔가며 실행합니다.
- 이론적인 이야기 와중에서도 실무에서 고려할 내용 역시 존재합니다.

> Tip 46. 여러분의 추정을 테스트하라

- 정확하게 시간을 제는 것이 어렵다면 코드 프로파일러(code profiler)를 사용해서 알고리즘이 돌아갈 때 실행되는 각 단계의 반복 회수를 센 다음, 입력값의 규모를 가면서 나오는 값을 그래프로 그립니다.

#### 최고라고 언제나 최고는 아니다

- 적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있습니다.
- 가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아닙니다.
  - 데이터의 규모가 작을 경우, 준비하는 시간이 알고리즘을 돌리는 시간보다 더 적은 경우도 존재합니다.
- 성급한 최적화(premature optimization)을 조심히 해야합니다.

<br/>

## Item 33. 리팩터링

<br/>

## Item 34. 테스트하기 쉬운 코드

<br/>

## Item 35. 사악한 마법사
