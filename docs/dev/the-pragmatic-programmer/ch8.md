---
sidebar_position: 8
---

# 8. 실용주의 프로젝트

- 프로젝트가 진행됨에 따라 좀 더 큰 관점에서 프로젝트 전체 차원의 문제드렝 대해 이야기할 필요가 있습니다.

<br/>

## Item 41. 실용주의 팀

- 개인이 더 나은 프로그래머가 되게끔 도와주는 실용주의 기법들이 팀에도 적용됩니다.
- 팀 전체에 실용주의 기법들을 어떻게 적용할 수 있는지 간략하게 알아보도록 합니다.

### 깨진 창문을 없애라

- 품질은 팀의 이슈입니다.
- 품질에 무성한 팀에 부지런한 개발자가 가면, 개발자의 열정이 줄어들게 됩니다.
- 팀 전체가 깨진 창문(아무도 고치려고 하지 않는 사소한 결점, imperfection)을 용납하지 않아야 합니다.
- 몇몇 팀 방법론에는 **품질 관리 담당자**가 있어 상품의 품질에 대한 책임을 팀에게서 위임을 받습니다.

### 삶은 개구리

- 프로젝트 개발의 열기속에서 전체 환경의 변화에 계속 유의하는 것은 어려운 일입니다.
- 개인보다는 팀이 삶은 개구리가 되기 쉽습니다.
- 모든 사람이 적극적으로 환경 변화를 감시해야 합니다.

### 소통하라!

- 한 팀에 속한 개발자들이 서로 대화를 해야 하는것은 당연합니다.
- 팀은 나머지 세상과 명확히 의사소통해야 할 필요가 있습니다.
- 바깥의 사람들에게 무뚝뚝하게 과묵해 보이는 프로젝트 팀이야말로 최악입니다.
- 훌륭한 프로젝트 팀은 **뚜렷한 특성**을 갖습니다.
- 팀이 하나로서 의사소통하게 도와주는 간단한 마케팅 비결이 있습니다.
  - 프로젝트를 시작할 때 유별한 이름을 지어주는 것입니다.
  - 팀 이름을 거리낌 없이 사용함으로 정체성 확립의 기반을 얻고, 작업에 관련되어 기억할만한 것을 얻을 수 있습니다.

### 반복하지 마라

- 중복은 노력을 낭비하고, 유지보수의 악몽을 끌어들일 수도 있습니다.
- 어떤 팀은 팀원 한 명을 프로젝트 사서로 임명해서 문서와 코드 저장고를 관리하는 책무를 맡깁니다.
- 프로젝트가 한 사람의 사서가 감당하기에 너무 클 경우, 작업의 다양한 기능적 측면의 핵심 사안별로 사람들을 임명합니다.
- 질의응답을 주고받고 이를 저장 관리할 때는 그룹웨어 시스템과 유즈넷 뉴스그룹이 갖는 가치를 얻어야 합니다.

### 직교성

- 전통적인 팀 조직은 구식 소프트웨어 구축 모델은 폭포수 모델을 근간으로 합니다.
- 극잔적인 경우, 어떤 개발 문화에서는 책임을 엄격하게 분할하는데 이는 문제를 더욱 복잡하게 만듭니다.
- 프로젝트의 여러 활동이 독립적으로 이루어진다는 생각은 잘못입니다.

> Tip 6. 팀을 기능 중심으로 조직하라

- 팀을 기능적으로 분리하는 것을 선호합니다.
  - 사람들은 작은 팀으로 나누고, 각 팀은 최종 시스템의 특정한 기능 측면에 대해 책임지도록 합니다.
  - 팀은 개개인의 강점 위에 스스로 내부를 조직하게 합니다.
- 기능 중심으로 팀을 조직하면 어떤 변화가 있더라도 전체가 영향받는 일이 없게 됩니다.
  - 책임감 있는 개발자들과 강력한 프로젝트 관리가 있을 경우에만 효과가 있습니다.
- 좀 더 큰프로젝트의 팀들은 추가적인 리소스를 필요로 합니다.

### 자동화

- 일관성과 정확성을 보장하는 훌륭한 방법은 팀이 하는 모든 일을 자동화하는 것입니다.
- 자동화는 모든 프로젝트팀에게 필요불가결한 요소입니다.

### 덧칠을 언제 멈출지 알아라

- 팀은 개인들로 이루어집니다.
- 각 팀원이 자신의 방식대로 빛나게 해주어야 합니다.
- 프로젝트가 요구사항에 맞게 이루어지기에 딱 좋을 만큼의 구조를 제공합니다.

<br/>

## Item 42. 유비쿼터스 자동화

프로젝트에서 일관성과 반복가능성을 확보하는 것이 중요합니다. 수작업은 일관성을 운에 맡기는 행동입니다.

### 전자동

> Tip 61. 수작업 절차를 사용하지 마라

- 사람들은 컴퓨터만큼 반복가능하지 않으며 그것을 기대해서도 안됩니다.
- 인기 있는 자동화의 예시로 `cron` 등이 있습니다.

### 프로젝트 컴파일

- 프로젝트 컴파일은 귀찮을 일이며 믿을 만하고 반복가능하게 만들어야 합니다.
- 대표적인 예시로 `makefile`로 프로젝트 컴파일을 하며 이는 스크립트로된 자동 과정이기 때문에 매우 좋습니다.

### 코드 생성

- 중복의 해악에서 공통의 소스에서 지식을 유도하기 위해서는 코드 생성을 하는 것이 좋습니다.
- 동일한 종류의 규칙들을 사용해서 소스코드, 헤더 파일 혹은 문서까지도 다른 형태의 자료에서 자동으로 생성할 수 있습니다.

#### 회귀 테스트

- 개개 모듈 혹은 전체 서브시스템에 대해 회귀 테스트가 실행되도록 makefile을 사용할 수도 있습니다.

### 빌드 자동화

- **빌드**는 비어있는 디렉터리 하나를 가지고 프로젝트를 밑바닥에서부터 만드는 과정
- 일반적인 빌드의 단계는 다음과 같습니다.
  - (1) repository에서 소스코드를 끄집어 냅니다.
  - (2) 프로젝트를 밑바닥부터 빌드합니다. (각 빌드마다 모종의 릴리스 번호나 버전, 날짜 등이 표시됩니다.)
  - (3) 배포용 이미지를 만듭니다.
  - (4) 테스트를 실행합니다.

#### 최종 빌드

- 상품으로 선적하려고 하는 최종 빌드는 주기적인 빌드와는 다른 요구사항이 있을 수도 있습니다. 최종 빌드에서는 저장소를 잠그고 릴리스 번호를 태그로 붙이는 작업이 필요할 수도 있습니다.

### 자동화된 관리

- 프로그래머는 모든 시간을 프로그래밍에 투자할 수 없습니다.
- 기억은 잊기 때문에 의존하지 않도록해야합니다.
- 목표는 자동화, 무인화이며 내용 주도(content-driven)인 작업흐름을 유지하는 것입니다.

#### 웹사이트 생성

- 많은 개발 팀들이 프로젝트 내에서 의사소통을 위해 내부 웹사이트를 사용하는데 이는 좋은 생각입니다.
- 다만, 웹사이트를 유지보수하는데 너무 많은 시간을 허비해도 안되고, 그렇다고 오랫동안 손을 안되는 것도 좋지않습니다.
- 코드에서 추출된 문서나 요구사항 분석, 설계 문서, 그림, 차트, 그래프 등 모두가 정기적으로 웹에 올라가야 합니다.

#### 승인 과정

> 개인 의견. 과거 vi 시절에만 이말이 먹히지, 현대 개발은 IDE에서 지원해주는 것도 너무 많다고 생각. 굳이 무기가 있는데 맨몸으로 싸워햐할까.

<br/>

## Item 43. 가차 없는 테스트

<br/>

## Item 44. 결국은 모두 글쓰기

<br/>

## Item 45. 위대한 유산
