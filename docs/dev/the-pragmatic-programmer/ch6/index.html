<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">6. 코딩하는 동안 해야 할 일들 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch6"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="6. 코딩하는 동안 해야 할 일들 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="- 코딩은 기계적인 작업이 아니며 프로그래밍이 정확하고 생산적으로 작동하면서 천수를 누리도록 하기 위해서는 사려 깊은 생각과 판단을 통한 결정이 필요합니다."><meta data-react-helmet="true" property="og:description" content="- 코딩은 기계적인 작업이 아니며 프로그래밍이 정확하고 생산적으로 작동하면서 천수를 누리도록 하기 위해서는 사려 깊은 생각과 판단을 통한 결정이 필요합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch6"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch6" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/the-pragmatic-programmer/ch6" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.dcd175f6.js" as="script">
<link rel="preload" href="/til/assets/js/main.28ed241c.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">6. 코딩하는 동안 해야 할 일들</h1></header><div class="markdown"><ul><li>코딩은 기계적인 작업이 아니며 프로그래밍이 정확하고 생산적으로 작동하면서 천수를 누리도록 하기 위해서는 사려 깊은 생각과 판단을 통한 결정이 필요합니다.</li><li>우연에 맡기는 프로그래밍(programming by coincidence)는 좋지 않습니다.</li><li>실용주의 프로그래머는 모든 코드를 비판적으로 바라봐야하며 자신의 코드도 예외가 아닙니다.</li><li>언제나 코드를 작성할 때는 언젠가 그 코드를 테스트하게 될 것이라는 생각을 가지고 있어야합니다.</li><li>마음을 늘 깨어있도록 유지하는 것은 여러 문제를 막을 수 있습니다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-31-우연에-맡기는-프로그래밍"></a>Item 31. 우연에 맡기는 프로그래밍<a class="hash-link" href="#item-31-우연에-맡기는-프로그래밍" title="Direct link to heading">#</a></h2><p>개발자는 수많은 함정속에서 개발을 하며, 잘못된 결론을 내리지 않도록 언제나 주의해야 합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="프로그래밍을-우연에-맡기면-어떻게-되는가"></a>프로그래밍을 우연에 맡기면 어떻게 되는가<a class="hash-link" href="#프로그래밍을-우연에-맡기면-어떻게-되는가" title="Direct link to heading">#</a></h3><ul><li>코드가 어떻게 돌아가는지 몰랐기 때문에 왜 안돌아가게 되는지 모르게 됩니다.</li><li>테스트를 했을 때, 코드가 잘 돌아가는 것처럼 보였지만 이것이 우연의 산물입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="우연적-구현"></a>우연적 구현<a class="hash-link" href="#우연적-구현" title="Direct link to heading">#</a></h4><ul><li>우연적 구현(accidents of implementation)은 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일입니다.</li><li>결과물이 괜찮다고, 잘 작동한다고 건드리지 않으면 여러 문제가 발생할 수 있습니다.<ul><li>정말로 제대로 돌아가는 것이 아닌 우리에게만 그런 것 처럼 보이는 건지</li><li>의존하는 조건이 단순히 우연인 경우이고, 다른상황에서는 이상하게 작동할지도 모릅니다.</li><li>문서화되지 않는 동작은 라이브러리의 다음 릴리스에서 변경될 가능성이 있습니다.</li><li>불필요한 추가 호출은 코드를 더 느리게 만듭니다.</li><li>추가로 호출한 루틴 때무넹 새로운 버그들이 코드에 들어올 가능성이 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="우연적-맥락"></a>우연적 맥락<a class="hash-link" href="#우연적-맥락" title="Direct link to heading">#</a></h4><ul><li>우연적 맥락(accidents of context)도 마찬가지로 생길 수 있습니다.<ul><li>어떤 GUI 환경용 애플리케이션에서 쓰려고 모듈을 작성한다고 해도 반드시 GUI가 있어야만 돌아갈 필요는 없습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="암묵적인-가정"></a>암묵적인 가정<a class="hash-link" href="#암묵적인-가정" title="Direct link to heading">#</a></h4><ul><li>요구사항을 만들어 내는 것부터 테스트에 이르기까지 어느 차원에서든 우연은 잘못된 길로 이끌 수 있습니다.<ul><li>테스팅이 특히 거짓 원인과 우연적인 결과로 가득 찬 영역입니다.</li></ul></li><li>모든 차원에서 사람들은 많은 것을 가정하고 작업합니다. 그러나 이는 문서화되는 경우가 드물며 가정이 다른 경우가 많습니다.</li></ul><blockquote><p>Tip 44. 우연에 맡기는 프로그래밍을 하지 말라</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="의도적으로-프로그래밍하기"></a>의도적으로 프로그래밍하기<a class="hash-link" href="#의도적으로-프로그래밍하기" title="Direct link to heading">#</a></h3><p>의도적으로 프로그래밍을 하는 것은 도움이 됩니다.</p><ul><li>언제나 자기가 지금 무엇을 하고 있는지 알아야합니다.</li><li>맹목적으로 코딩하지 말라</li><li>계획을 세우고 그것을 바탕으로 진행하라</li><li>신뢰할 수 있는 것에만 기대하라</li><li>여러분의 가정을 문서로 남겨라</li><li>코드만 테스트할 것이 아니라 세운 가정도 테스트해봐야합니다.</li><li>노력을 기울일 대상의 우선순위를 정하라</li><li>과거의 노예가 되지 마라</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-32-알고리즘의-속도"></a>Item 32. 알고리즘의 속도<a class="hash-link" href="#item-32-알고리즘의-속도" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="알고리즘을-추정한다는-말의-의미는-무엇인가"></a>알고리즘을 추정한다는 말의 의미는 무엇인가<a class="hash-link" href="#알고리즘을-추정한다는-말의-의미는-무엇인가" title="Direct link to heading">#</a></h3><ul><li>간단한 몇몇 알고리즘을 제외한 대부분의 알고리즘은 가변적인 입력 데이터를 다룹니다.</li><li>입력의 크기가 클수록, 알고리즘의 수행시간이 길어지거나 사용하는 메모리의 양이 늘어납니다.</li><li>반복문이나 재귀 함수를 담고 있는 코드를 작성할 때는 무의식으로 수행시간과 메모리 요구량을 계산하는 것이 좋으며 O() 표기법 등이 좋습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="o-표기법"></a>O() 표기법<a class="hash-link" href="#o-표기법" title="Direct link to heading">#</a></h3><ul><li>O() 표기법은 근사값을 다루기 위한 수학적 방법입니다. (상한선을 의미)</li><li>ex) 100개를 처리하는데 1초 걸리는 루틴이 있을 때, 1000개 처리를 하는 경우?<ul><li>O(1) : 1초</li><li>O(log(N)) : 약 3초</li><li>O(n^2) : 한참...</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상식적인-추정"></a>상식적인 추정<a class="hash-link" href="#상식적인-추정" title="Direct link to heading">#</a></h3><ul><li>간단한 반복문(loop) : O(n)일 확률이 높음</li><li>겹친 반복분 : O(n * m)</li><li>반씩 자르기 : O(log(n))</li><li>나눠서 정복 : O(n * log(n))</li><li>조합적 : 일반적으로 매우 깁니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="실전에서의-알고리즘-속도"></a>실전에서의 알고리즘 속도<a class="hash-link" href="#실전에서의-알고리즘-속도" title="Direct link to heading">#</a></h3><ul><li>대부분 라이브러리의 정렬 루틴이 성능이 좋습니다.</li><li>코드를 실행할 때 외부 요인에 따라 달라진다면, 잠시 작업을 멈추고 커다란 수가 들어왔을 경우 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해 보는 것이 좋습니다.</li></ul><blockquote><p>Tip 45. 여러분 알고리즘의 차수를 추정하라</p></blockquote><ul><li>코드의 실행시간이 얼마나될지, 또는 메모리를 얼마나 사용할지 확실하지 않다면 입력 레코드의 수나 혹은 런타임에 영향을 줄 것이라고 생각되는 요소를 바꿔가며 실행합니다.</li><li>이론적인 이야기 와중에서도 실무에서 고려할 내용 역시 존재합니다.</li></ul><blockquote><p>Tip 46. 여러분의 추정을 테스트하라</p></blockquote><ul><li>정확하게 시간을 제는 것이 어렵다면 코드 프로파일러(code profiler)를 사용해서 알고리즘이 돌아갈 때 실행되는 각 단계의 반복 회수를 센 다음, 입력값의 규모를 가면서 나오는 값을 그래프로 그립니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="최고라고-언제나-최고는-아니다"></a>최고라고 언제나 최고는 아니다<a class="hash-link" href="#최고라고-언제나-최고는-아니다" title="Direct link to heading">#</a></h4><ul><li>적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있습니다.</li><li>가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아닙니다.<ul><li>데이터의 규모가 작을 경우, 준비하는 시간이 알고리즘을 돌리는 시간보다 더 적은 경우도 존재합니다.</li></ul></li><li>성급한 최적화(premature optimization)을 조심히 해야합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-33-리팩터링"></a>Item 33. 리팩터링<a class="hash-link" href="#item-33-리팩터링" title="Direct link to heading">#</a></h2><ul><li>프로그램이 발전해가며 초기에 내린 결정을 다시 고려하고 코드의 일부분을 다시 결정하는 경우가 많습니다.</li><li>이는 매우 자연스러운 과정이며, 코드는 발전해야합니다.</li><li>소프트웨어는 정원일(gardening)에 가깝습니다.</li><li>코드에서 어떤 루틴은 너무 크거나 하는게 많은 경우, 또한 계획대로 되지 않는 경우에는 잡초 제거나 가지치기가 필요합니다.</li><li>이말은 즉슨, 코드를 다시 작성하거나 다시 작업하기, 다시 설계하기는 리팩터링(refactoring)이라고 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리팩터링은-언제-해야-하는가"></a>리팩터링은 언제 해야 하는가<a class="hash-link" href="#리팩터링은-언제-해야-하는가" title="Direct link to heading">#</a></h3><p>코드가 더 이상 잘 맞지 않아서 장애물에 부딛치거나, 하나로 합쳐져야할 두개를 발견했을 때, 어떤 것이든 잘못되었다고 생각되는 경우, 이를 <strong>변경</strong>해야합니다.</p><ul><li>중복 : DRY 원칙의 위반</li><li>직교성이 좋지 않은 설계 : 직교성을 저 좋게 만들 수 있는 코드나 설계</li><li>유효성이 끝난 지식 : 사물은 변하고, 요구사항은 변경되며, 해결하는 중인 문제에 대한 지식이 증가한 순간</li><li>성능 : 성능을 개선하려면 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 함</li></ul><p>코드를 리팩터링하는 것은 고통 관리(pain management)를 실천하는 것이며 현실을 피하지 않는 것입니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="현실-세계의-복잡한-문제들"></a>현실 세계의 복잡한 문제들<a class="hash-link" href="#현실-세계의-복잡한-문제들" title="Direct link to heading">#</a></h4><ul><li>현실에서 리팩터링을 자주 못하는 핑계는 일정의 압박입니다.</li><li>그러나, 리팩터링을 하지 않으면 일이 더 진척되었을 때 신경써야 할 의존성이 더 많이 생겼을 때 문제를 고치기 위해 훨씬 더 많이 투자해야 합니다.<ul><li>일종의 종양과도 같습니다.</li></ul></li></ul><blockquote><p>Tip 47. 일찍 리팩터링하고, 자주 리팩터링 하라</p></blockquote><p>리팩터링 해야 할 것들의 명단을 만들고 유지하며, 리팩터링하기 힘들다면 일정에 리팩터링할 시간을 확실히 포함시켜 두도록 합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="리팩터링은-어떻게-하는가"></a>리팩터링은 어떻게 하는가<a class="hash-link" href="#리팩터링은-어떻게-하는가" title="Direct link to heading">#</a></h3><ul><li>리팩터링의 본질은 재설계입니다.</li><li>새로운 사실이 밝혀지거나 문제에 대한 이해가 더 깊어지거나 요구사항이 바뀌는 일이 생긴다면 언제든 재설계의 대상이 될 수 있습니다.</li><li>리팩터링은 천천히, 신중하게, 조심스럽게 진행햐아 하는 작업입니다.</li></ul><p>리팩터링에 대한 간단한 조언은 다음과 같습니다.</p><ol><li>리팩터링과 새로운 기능 추가를 동시에 하지 말아라</li><li>리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인합니다.</li><li>단계를 작게 나누어 신중하게 작업합니다.</li></ol><p>모듈에 큰 변화(모듈의 인터페이스, 기능을 이전과 호환성을 유지할 수 없을 정도의 변화)가 있다면 일부로 빌드를 실패하는 기법도 유용합니다.</p><p>코드가 마음에 안든다면 그 코드에 더불어 그 코드에 의존하는 모든 것도 함께 고치도록 합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-34-테스트하기-쉬운-코드"></a>Item 34. 테스트하기 쉬운 코드<a class="hash-link" href="#item-34-테스트하기-쉬운-코드" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단위-테스트"></a>단위 테스트<a class="hash-link" href="#단위-테스트" title="Direct link to heading">#</a></h3><ul><li>각 모듈의 동작을 검증하기 위해 다른 것들과 분리(isolate) 시켜 놓고 테스트가 이루어집니다.</li><li>소프트웨어 다누이 테스트란 어떤 모듈에게 이것저것ㅇ즐 시켜보는 코드를 가리킵니다.</li><li><strong>계약에 의한 설계</strong>의 밑바탕에 깔린 개념들을 사용하면 훨씬 더 나은 작업을 할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="계약을-잘-지키는지-테스트해보기"></a>계약을 잘 지키는지 테스트해보기<a class="hash-link" href="#계약을-잘-지키는지-테스트해보기" title="Direct link to heading">#</a></h3><ul><li>복잡한 모듈은 다른 많은 모듈에게 의존할 가능성이 높습니다. 이 경우에는 모듈의 하위 컴포넌트를 먼저 테스트할 것을 요구합니다.</li><li>이러한 테스트를 통해서 후반에 발생하는 여러 문제를 방지할 수 있습니다.</li></ul><blockquote><p>Tip 48. 테스트를 염두에 두고 설계하라.</p></blockquote><ul><li>모듈을 설계할 때는 심지어 루틴 하나를 설계할 때도, 할 계약과 계약을 지키는지 테스트하는 코드도 함께 설계해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단위-테스트-작성하기"></a>단위 테스트 작성하기<a class="hash-link" href="#단위-테스트-작성하기" title="Direct link to heading">#</a></h3><ul><li>모듈의 단위 테스트는 찾기 편한 곳에 위치해야합니다.</li><li>테스트 코드를 쉽게 접근할 수 있게 해놓는 것은 개발자들에게 소중한 두 가지 자원을 제공합니다.<ul><li>여러분 모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제</li><li>후일 코드 변경시 검증하기 위한 휘기 테스트를 구축할 수 있는 수단</li></ul></li><li>모든 클래스나 모듈안에 자신의 단위 테스트 코드를 넣어두면 편리하나 늘 실용적인 것은 아닙니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테스트-장치test-harness를-사용하기"></a>테스트 장치(Test Harness)를 사용하기<a class="hash-link" href="#테스트-장치test-harness를-사용하기" title="Direct link to heading">#</a></h3><ul><li>보통 많은 테스트 코드를 작성하고 많이 하기 때문에 표준으로 사용할 테스트 장치를 만드는 것이 중요합니다.</li><li>테스트 장치는 상태를 기록으로 남기거나, 예상 결과값에 비추어 출력을 분석하거나 테스트를 선택하고 실행하는 일처럼 자주 쓰이는 작업들을 다룰 수 있어야합니다.<ul><li>테스트 장치는 GUI, 프로젝트 동일 언어, makefile과 Perl Script 등의 조합으로 구현될 수 있습니다.</li></ul></li><li>객체 지향 언어와 환경에서는 이런 공통적인 기능을 제공하는 기반 클래스를 만들고 합니다.</li></ul><p>테스트 장치는 반드시 아래의 기능이 있어야합니다.</p><ul><li>시작할 때 할 일과 마칠 때 할 일을 지정ㅈ할 수 있ㄴ느 표준적인 방법</li><li>개별적인 테스트를 선택하거나 아니면 모든 테스트를 한꺼번에 선택하게 해주는 메서드</li><li>예상한 결과에 비추어 결과를 분석할 수 있는 방법</li><li>실패를 보고하는 표준화된 형태</li></ul><p>테스트는 조립식으로 작동할 수 있어야합니다. 대표적인 예시는 <code>JUnit</code> 입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테스트-윈도우를-만들기"></a>테스트 윈도우를 만들기<a class="hash-link" href="#테스트-윈도우를-만들기" title="Direct link to heading">#</a></h3><ul><li>테스트 집합이 아무리 좋더라도 모든 버그를 발견할 가능성은 없습니다.</li><li>소프트웨어가 deploy 된 후에도 테스트해야만 하는 경우가 자주 생길 수 있습니다.</li><li>추적 메시지를 담아 두는 로그 파일이 이런 종류의 메커니즘 가운데 하나입니다.</li><li>실행 중인 코드의 내부로 들어갈 수 있는 또 다른 메커니즘은 일련의 단축키(hot-key)를 제공하는 것입니다.</li><li>규모가 크고 더 복잡한 서버 코드라면, 웹 서버를 내장시키는 것이 작업 상태를 점검하는 수단을 제공하는 멋진 기법이 될 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테스트-문화"></a>테스트 문화<a class="hash-link" href="#테스트-문화" title="Direct link to heading">#</a></h3><ul><li>작성하는 모든 소프트웨어는 언젠가는 테스트합니다.<ul><li>개발자가 테스트하지 않으면, 결과적으로 사용자들이 테스트하게 됩니다.</li></ul></li><li>대표적인 예시로 펄 공동체는 단위 테스트와 회구 테스트를 매우 중시합니다.<ul><li><code>% make test</code></li></ul></li><li>테스트는 기술적이라기보다는 문화적인 것입니다.</li></ul><blockquote><p>Tip 49. 소프트웨어를 테스트하라. 그렇지 않으면 사용자가 테스트하게 될 것입니다.</p></blockquote><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-35-사악한-마법사"></a>Item 35. 사악한 마법사<a class="hash-link" href="#item-35-사악한-마법사" title="Direct link to heading">#</a></h2><ul><li>애플리케이션을 작성하는 일은 날이갈 수록 어령워지고 있습니다.</li><li>동시에 애플리케이션 자체도 점점 더 복잡해지고 싶습니다.</li><li>옛날에 애플리케이션을 만들던 도구를 지금 사용하면 아무것도 개발하기 힘들 것입니다.</li><li>좋은 도구를 사용해도 평범한 개발자가 자동으로 전문가가 되지 않습니다.<ul><li>이는 우연에 맡기는 코드입니다.</li></ul></li><li>마법사가 만든 코드를 모두 이해하지 못하면 자기가 애플리케이션의 주인이 아닙니다.<ul><li>애플리케이션을 유지보수하지도 못하고, 디버깅해야 할 때가 오면 고생하게 될 것입니다.</li></ul></li></ul><blockquote><p>Tip 50. 자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라</p></blockquote><p><strong>그 누구도 자신이 완전히 이해하지 못하는 코드를 내놓아서는 안됩니다.</strong></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/the-pragmatic-programmer/ch6.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-08-03T14:00:52.000Z" class="lastUpdatedDate_1WI_">8/3/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/the-pragmatic-programmer/ch5"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 5. 구부러지거나 부러지거나</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/the-pragmatic-programmer/ch7"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">7. 프로젝트 전에 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-31-우연에-맡기는-프로그래밍" class="table-of-contents__link">Item 31. 우연에 맡기는 프로그래밍</a><ul><li><a href="#프로그래밍을-우연에-맡기면-어떻게-되는가" class="table-of-contents__link">프로그래밍을 우연에 맡기면 어떻게 되는가</a></li><li><a href="#의도적으로-프로그래밍하기" class="table-of-contents__link">의도적으로 프로그래밍하기</a></li></ul></li><li><a href="#item-32-알고리즘의-속도" class="table-of-contents__link">Item 32. 알고리즘의 속도</a><ul><li><a href="#알고리즘을-추정한다는-말의-의미는-무엇인가" class="table-of-contents__link">알고리즘을 추정한다는 말의 의미는 무엇인가</a></li><li><a href="#o-표기법" class="table-of-contents__link">O() 표기법</a></li><li><a href="#상식적인-추정" class="table-of-contents__link">상식적인 추정</a></li><li><a href="#실전에서의-알고리즘-속도" class="table-of-contents__link">실전에서의 알고리즘 속도</a></li></ul></li><li><a href="#item-33-리팩터링" class="table-of-contents__link">Item 33. 리팩터링</a><ul><li><a href="#리팩터링은-언제-해야-하는가" class="table-of-contents__link">리팩터링은 언제 해야 하는가</a></li><li><a href="#리팩터링은-어떻게-하는가" class="table-of-contents__link">리팩터링은 어떻게 하는가</a></li></ul></li><li><a href="#item-34-테스트하기-쉬운-코드" class="table-of-contents__link">Item 34. 테스트하기 쉬운 코드</a><ul><li><a href="#단위-테스트" class="table-of-contents__link">단위 테스트</a></li><li><a href="#계약을-잘-지키는지-테스트해보기" class="table-of-contents__link">계약을 잘 지키는지 테스트해보기</a></li><li><a href="#단위-테스트-작성하기" class="table-of-contents__link">단위 테스트 작성하기</a></li><li><a href="#테스트-장치test-harness를-사용하기" class="table-of-contents__link">테스트 장치(Test Harness)를 사용하기</a></li><li><a href="#테스트-윈도우를-만들기" class="table-of-contents__link">테스트 윈도우를 만들기</a></li><li><a href="#테스트-문화" class="table-of-contents__link">테스트 문화</a></li></ul></li><li><a href="#item-35-사악한-마법사" class="table-of-contents__link">Item 35. 사악한 마법사</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.dcd175f6.js"></script>
<script src="/til/assets/js/main.28ed241c.js"></script>
</body>
</html>