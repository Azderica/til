---
sidebar_position: 2
---

# 2. 실용주의 접근법

## Item 7. 중복의 해악

- 프로그래머는 지식을 수집하고, 조직하고, 유지하고, 통제합니다.
- 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현양식을 가져야합니다.

> Tip 11. DRY - 반복하지 마라(Don't Repeat Yourself)

### 어떻게 중복이 생기는 지

- 강요된 중복 : 개발자들은 다른 섵낵이 없다고 느끼며, 환경이 중복을 요구하는 것처럼 보입니다.
- 부주의한 중복 : 개발자들은 자신들이 정복을 중복하고 있다는 것을 깨닫지 못합니다.
- 참을성 없는 중복 : 중복이 쉬워보이기 때문에 개발자들이 게을러서 중복합니다.
- 개발자간의 중복 : 한 팀에 있는 여러 사람들이 동일한 정보를 중복합니다.

### 강요된 중복

이를 해결하기 위한 기법은 다음과 같습니다.

- 정보의 다양한 표현 방식 : 간단한 필터나 코드 생성기를 통해서 ㅈ붕복을 제거합니다.
- 코드내의 문서화 : 나쁜 코드일수록 주석이 늘어나며, 좋은 코드는 핵심적인 부분을 위한 주석을 만듭니다.
- 문서화와 코드 : 문서를 수정하고 코드를 갱신하는 순서로 진행합니다.

#### 언어에 관한 문제

- 특정 언어에서는 요구되는 극복 기법은 어렵습니다.
- 예를 들어 C/C++에서는 헤더에서는 인터페이스에 대한 사항을 기록하고, 구현 파일에는 그 코드의 사용자가 알 필요가 없는 상세한 것들을 기록합니다.

### 부주의한 중복

- 설계의 실수에서 발생하기도 합니다.
- 바깥에서는 DRY 원칙의 위배가 노출되지 않고, 클래스 내의 메서드만 고생하도록 코드를 구성하는 것이 좋습니다.

### 참을성 없는 중복

- 돌아가는 길이 지름길입니다. (지금의 몇초가 나중의 몇시간을 초래합니다.)
- 발견하기도 쉽고, 다루기도 쉽지만 미뤄두면 나중에 큰 고통이 됩니다.

### 개발자간의 중복

- 가장 발견하기 어려운 중복 중 하나며 이는 유지보수에 걸리게 됩니다.
- 최선책은 개발자간에 적극적이고 빈번한 소통을 장려하는 것입니다.

> Tip 12. 재사용하기 쉽게 만들라

<br/>

## Item 8. 직교성

설계, 빌드, 테스트 그리고 확장하기에 쉬운 시스템을 만들때 직교성은 중요한 개념입니다.

### 직교성이란

- 직교성은 기하학에서 온 용어이며 컴퓨팅에서는 일종의 독립성이나 결합도 줄이기를 의미합니다.
- 즉, 하나가 바뀌어도 나머지에 어떤 영향도 주지 않는 경우를 의미합니다.

### 직교성의 장점

> Tip 13. 관련 없는 것들 간에 서로 영향이 없도록 하라

일반적으로 직교적인 시스템의 장점은 크게 두가지가 있습니다.

#### 생산성 향상

- 변화가 국소화(localize)되어서 개발 시간과 테스트 시간이 줄어듭니다.
- 직교적인 접근법은 재사용을 촉진합니다.
- 직교적인 컴포넌트들을 결합하는 경우 미묘한 생산성 향상이 있습니다.

#### 리스크 감소

- 감염된 코드는 격리됩니다.
- 시스템이 잘 깨어지지 않습니다.
- 직교적인 시스템은 해당 컴포턴트들에 대해 테스트를 썰계하고 실행하기 훨씬 쉽기 때문에, 더 많은 테스트를 합니다.
- 써드파티 컴포넌트로 연결되는 인터페이스들이 전체 개발의 작은 부분에 한정되기 때문에 특정 벤더나 제품, 플랫폼에 덜 종속될 것입니다.

### 프로젝트 팀

- 프로젝트 팀의 효율성을 결정직는 것도 일종의 직교성 문제인 경우가 있습니다.
- 이러한 직교성을 파악하는 방법은 개별 변화에 대한 토론에 참여할 필요가 있는 사람이 많은 수록 직교성이 낮은 것입니다.

### 설계

- 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야합니다.
- 레이러를 두는 것은 모듈간에 종속성이 빨리 늘어나는 위험을 감소시킵니다.
- 현실세계의 변화와 설계 사이의 결합도를 줄이는 것이 중요합니다.
- 자신의 힘으로 제어할 수 없는 속성에는 의존하지 않습니다.

### 툴킷과 라이브러리

- 써드파티 툴킷이나 라이브러리를 도입할 때, 시스템의 직교성을 보존할 수 있도록 주의 깊게 살펴봅니다.
- 툴킷이나 같은 팀의 다른 멤버가 작성한 라이브러리를 도입시에 자신의 코드에 변화를 강요하는 경우에는 좋지 않습니다.
- 직교성에 대한 흥미로운 변형 중 하나는 **애스펙트 지향 프로그래밍(AOP, Aspect-Oriented Programming)** 입니다.

### 코딩

직교성을 유지하기 위한 코드 기법은 다음과 같습니다.

- 코드의 결합도를 줄여라
  - 불필요한 것은 다른 모듈에 노출하지 않습니다.
  - 다른 모듈의 구현에 의존하지 않는 코드를 작서앟ㅂ니다.
- 전역 데이터를 피하라
  - 전역데이터를 사용하면 그 데이터를 공유하는 다른 컴포턴트와 묶이게 됩니다.
  - 싱글턴 패턴은 특정 클래스의 객체가 단 하나의 인스턴스를 지원하는데 이를 전역처럼 사용하면 안됩니다.
- 유사한 함수를 피하라
  - 유사한 함수의 집합에서의 중복 코드는 구조적 문제의 징후입니다.
  - 스트래티지 패턴([strategy pattern](https://gmlwjd9405.github.io/2018/07/06/strategy-pattern.html))을 사용해서 더 나은 구현을 고민합니다.

### 테스트

- 직교적으로 설계, 구현한 시스템은 테스트하기가 쉽습니다.
- 단위 테스트를 만드는 것 자체가 직교성을 테스트해 볼 수 있는 흥미로운 작업입니다.
- 버그 수정은 시스템의 직교성을 총체적으로 점검해 볼 수 있는 값진 시간입니다.

### 문서화

- 직교성을 문서에 적용하면 내용과 표현이 두 축이됩니다.

### 직교적으로 살아가기

- DRY 원리와 직교성 원리를 충실히 사용한다면 개발하고 있는 시스템이 더 유연하고, 이해하기 쉬우며, 디버그, 테스트, 유지도 쉬워집니다.

<br/>

## Item 9. 가역성

> 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것은 없습니다.

- 중요할 결정들이 수없이 바뀔 수 있습니다.
- 프로젝트를 진행하는 중에 바뀌게 되면 큰 비용을 치뤄야합니다.

### 가역성

- 소프트웨어를 개발하는 속도는 요구사항, 사용자, 하드웨어의 변화를 앞지를 수 없습니다.
- 클라이언트-서버 모델에서 서버를 바꾸는 작업도 어려우면 안됩니다.

> Tip 14. 최종 결정이란 없다

### 유연한 아키텍처

- 아키텍처, 배포, 벤터 통합 영역의 유연성에 대해서도 관심을 기울어야합니다.
- 요구사항을 메타데이터에 넣고, 필요한 수행문을 코드에 넣을 때 애스팩트나 펄 등을 통해서 메커니즘을 자동화합니다.

<br/>

## Item 10. 예광탄

<br/>

## Item 11. 프로토타입과 포스트잇

<br/>

## Item 12. 도메인 언어

<br/>

## Item 13. 추정
