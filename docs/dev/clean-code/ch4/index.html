<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">Clean Code 내용 정리 - 4 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/dev/clean-code/ch4"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Clean Code 내용 정리 - 4 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="11장. 시스템"><meta data-react-helmet="true" property="og:description" content="11장. 시스템"><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/dev/clean-code/ch4"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/clean-code/ch4" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/dev/clean-code/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.ef1a43cb.js" as="script">
<link rel="preload" href="/til/assets/js/main.647c3b77.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">Clean Code 내용 정리 - 4</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="11장-시스템"></a>11장. 시스템<a class="hash-link" href="#11장-시스템" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="도시가-잘-돌아가는-이유"></a>도시가 잘 돌아가는 이유<a class="hash-link" href="#도시가-잘-돌아가는-이유" title="Direct link to heading">#</a></h3><ul><li>다양한 분야를 관리하는 팀원</li><li>적절한 추상화와 모듈화</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="시스템-제작과-시스템-사용을-분리"></a>시스템 제작과 시스템 사용을 분리<a class="hash-link" href="#시스템-제작과-시스템-사용을-분리" title="Direct link to heading">#</a></h3><p>제작과 사용은 다르다.</p><p>소프트웨어 시스템은 <strong>준비 과정</strong>(애플리케이션 객체를 제작하고 의존성을 서로 &#x27;연결&#x27;하는)과 <strong>런타임 로직</strong>(준비 과정 이후의 단계)을 분리해야 한다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="관심사-분리"></a>관심사 분리.<a class="hash-link" href="#관심사-분리" title="Direct link to heading">#</a></h4><ul><li><p>Ex) 초기화 지연(Lazy Initialization), 계산 지연(Lazy Evaluation)</p></li><li><p>장점</p><ol><li>애플리케이션을 시작하는 시간이 그만큼 빨라진다.</li><li>어떤 경우에도 null을 반환하지 않는다.</li></ol></li><li><p>단점</p><ol><li>의존성을 해결해야 한다.</li><li>테스트에서 문제가 생긴다. 즉, 일시적으로라도 단일 책임 원칙(SRP, Single Responsibility Principle)을 깨야한다.</li></ol></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="main-분리"></a>Main 분리.<a class="hash-link" href="#main-분리" title="Direct link to heading">#</a></h4><blockquote><p>시스템 생성과 사용을 분리하는 방법.</p></blockquote><p>main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘기며, 애플리케이션은 그저 객체를 사용한다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="팩토리"></a>팩토리<a class="hash-link" href="#팩토리" title="Direct link to heading">#</a></h4><blockquote><p>Factory 패턴은 부모 클래스에 알려지지 않은 구체 클래스를 생성하는 패턴이며.<br>
자식 클래스가 어떤 객체를 생성할지를 결정하도록 하는 패턴이다.</p></blockquote><p>객체가 생성하는 시점을 애플리케이션이 결정할 필요가 있는 경우에는 Abstact factory 패턴을 사용한다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="의존성-주입"></a>의존성 주입<a class="hash-link" href="#의존성-주입" title="Direct link to heading">#</a></h4><blockquote><p>의존성 주입(DI, Dependency Injection)은 하나의 객체가 다른 객체의 의존성을 제공하는 테크닉이다. &quot;의존성&quot;은 예를 들어 서비스로 사용할 수 있는 객체이다. 클라이언트가 어떤 서비스를 사용할 것인지 지정하는 대신, 클라이언트에게 무슨 서비스를 사용할 것인지를 말해주는 것</p></blockquote><p>사용과 제작을 분리하는 강력한 메커니즘. 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는 대신에 다른 메커니즘에 넘겨야 한다.</p><ul><li>해당 방법으로 &#x27;main&#x27;루틴이나 특수 컨테이너를 사용한다.</li><li>스프링 프레임워크는 잘 알려진 자바 DI 컨테이너를 제공한다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="확장"></a>확장<a class="hash-link" href="#확장" title="Direct link to heading">#</a></h3><p>깨끗한 코드는 코드 수준에서는 시스템을 조정하고 확장하기 쉽게 만들어진다.</p><p>그러나 <strong>시스템 수준</strong>에서는 그렇지 않다. 단순한 아키텍처를 복잡한 아키텍처로 조금씩 키울 수는 없다.</p><ul><li>따라서 소프트웨어 시스템은 관심사를 적절한 게 분리해 관리해야 한다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="횡단cross-cutting-관심사"></a>횡단(Cross-cutting) 관심사<a class="hash-link" href="#횡단cross-cutting-관심사" title="Direct link to heading">#</a></h4><blockquote><p>횡단 관심사는 다른 관심사에 영향을 미치는 프로그램의 측면이다. 이 관심사들은 디자인과 구현 면에서 시스템의 나머지 부분으로부터 깨끗이 분해되지 못하는 경우가 있을 수 있으며 분산되거나 얽히는 일이 일어날 수 있다.</p></blockquote><p>이를 해결하기 대처하기 위해 나온 방법론으로 <strong>관점 지향 프로그래밍</strong>(AOP, Aspet-Oriented Programming)이 있다.</p><ul><li>AOP에서의 관점 : 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="자바-프록시"></a>자바 프록시<a class="hash-link" href="#자바-프록시" title="Direct link to heading">#</a></h3><ul><li><p>단순한 상황에 적합하다. Ex) 개별 객체나 클래스에서 메서드 호출을 감싸는 경우.</p></li><li><p>JDK가 지원하는 동적 프록시는 인터페이스만 지원하며, 클래스 프록시를 사용하려면 CGLIB, ASM. Javassist 같은 바이트 코드 처리 라이브러리가 필요하다.</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="순수-자바-aop-프레임워크"></a>순수 자바 AOP 프레임워크<a class="hash-link" href="#순수-자바-aop-프레임워크" title="Direct link to heading">#</a></h3><p>POJO는 순수하게 도메인에 초점을 맞추며, 다른 도메인에 의존하지 않는다. 따라서 테스트가 개념적으로 더 쉽고 간단하며, 단순하여 구현에 쉬우며 이후 코드를 보수하고 개선하기 편하다.</p><blockquote><p>POJO(Plain Old Java Object) : 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 &quot;무거운&quot; 객체를 만들게 된 것에 반발해서 사용되게 된 용어</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="aspectj-관점"></a>AspectJ 관점<a class="hash-link" href="#aspectj-관점" title="Direct link to heading">#</a></h3><p>AspectJ는 관심사를 관점으로 분리하는 가장 강력한 도구이다.</p><ul><li>AspectJ &#x27;애너테이션 폼&#x27;은 새로운 도구와 새로운 언어의 부담을 제거한다.</li><li>애너테이션이란 주석처럼 프로그래밍에 영향을 미치지 않으며, 유용한 정보를 제공</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="테스트-주도-시스템-아키텍처-구축"></a>테스트 주도 시스템 아키텍처 구축<a class="hash-link" href="#테스트-주도-시스템-아키텍처-구축" title="Direct link to heading">#</a></h3><ul><li>애플리케이션 도메인 논리를 POJO로 작성할 수 있다면 (코드 수준에서 아키텍처 관심사를 분리할 수 있다면), <strong>테스트 주도 아키텍처</strong> 구축이 가능하다.</li><li>좋은 웹 사이트 들은 고도의 자료 캐싱, 보안, 가상화 등을 이용해 아주 높은 가용성과 성능을 효율적이고 유연하게 달성한다.</li><li>이를 정리하면, 최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화 된 관심사 영역(도메인)으로 구성된다. 이러한 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합하며, 이러한 구조는 테스트 주도 기법을 사용할 수 있다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="의사-결정을-최적화"></a>의사 결정을 최적화<a class="hash-link" href="#의사-결정을-최적화" title="Direct link to heading">#</a></h3><ul><li>모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능하다.</li><li>가능한 마지막 순간까지 결정을 미루는 방법이 좋은 경우가 있는데, 이러한 경우에서 옳게 쓰일 수 있다.<ul><li>즉, 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공하고, 이러한 기민함은 최신 정보에 기반에 최선의 시점에 최적의 결정을 내리는데 도움을 준다. 더불어 결정의 복잡성도 감소한다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="명백한-가치가-있을-때-표준을-현명하게-사용"></a>명백한 가치가 있을 때 표준을 현명하게 사용<a class="hash-link" href="#명백한-가치가-있을-때-표준을-현명하게-사용" title="Direct link to heading">#</a></h3><p>표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉬우며 컴포넌트를 엮기 쉽다.</p><p>단점으로는 표준을 만드는 시간이 너무 오래 걸리게 된다면, 다른 업계가 기다리지 못한다. 더불어 표준이 목적을 잃어버리는 경우도 발생한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="시스템은-도메인-특화-언어가-필요"></a>시스템은 도메인 특화 언어가 필요<a class="hash-link" href="#시스템은-도메인-특화-언어가-필요" title="Direct link to heading">#</a></h3><blockquote><p>도메인 특화 언어(DSL, Domain-Specific Language)이란. 간단한 스크립트 언어나 표준 언어로 구현한 API</p></blockquote><ul><li>좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 &#x27;의사소통 간극&#x27;을 줄여주며, 도메인을 잘못 구현할 가능성이 줄어든다.</li><li>추상화 수준을 코드 관용구나 디자인 패턴 이상의 효과를 만들어 낼 수 있다.</li><li>DSL을 사용하면 고차원 정책에서 저 차원 세부사항에 이르기까지 모든 추상화 수준과 모든 도메인을 POJO로 표현 가능하다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론"></a>결론<a class="hash-link" href="#결론" title="Direct link to heading">#</a></h3><ul><li>깨끗한 아키텍처는 도메인 논리를 높여주며, 기민성을 높이고, 제품 품질이 떨어지며, TDD가 제공하는 단점이 사라진다.</li><li>POJO를 작성하고 관점 등을 통해 관심사를 분리해서 추상화 단계에서의 의도를 명확히 표현해야 한다.</li><li>핵심 중 하나는 <strong>실제로 돌아가는 가장 단순한 수단을 사용해야 한다.</strong></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="12장-창발성"></a>12장. 창발성<a class="hash-link" href="#12장-창발성" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="창발적-설계로-깔끔한-코드를-구현"></a>창발적 설계로 깔끔한 코드를 구현<a class="hash-link" href="#창발적-설계로-깔끔한-코드를-구현" title="Direct link to heading">#</a></h3><p>우수한 설계가 나오는 간단한 규칙 4가지</p><ol><li>모든 테스트를 실행한다</li><li>중복을 없앤다.</li><li>프로그래머 의도를 표현한다.</li><li>클래스와 메서드 수를 최소로 줄인다.</li></ol><p>단 위가 밑보다 중요하다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단순한-설계-규칙-1-모든-테스트를-실행"></a>단순한 설계 규칙 1: 모든 테스트를 실행<a class="hash-link" href="#단순한-설계-규칙-1-모든-테스트를-실행" title="Direct link to heading">#</a></h3><ul><li>설계는 의도한 대로 돌아가야 한다.</li><li>철저한 테스트가 가능한 시스템은 더 나은 설계를 만든다.</li><li>결합도가 높을수록 테스트 케이스를 작성하기 어렵다.</li><li>테스트 케이스를 만들고 돌리는 것 -&gt; 낮은 결합도와 높은 응집력</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단순한-설계-규칙-24-리팩터링"></a>단순한 설계 규칙 2~4: 리팩터링<a class="hash-link" href="#단순한-설계-규칙-24-리팩터링" title="Direct link to heading">#</a></h3><ul><li>테스트 케이스를 모두 작성했다면, 코드와 클래스를 점진적으로 정리하면 된다.</li><li>코드를 정리하면서 테스트 케이스를 통해 깨지지 않도록 한다.</li><li>리팩터링 단계에서는 소프트웨어 설계 품질을 높이는 기법을 사용하는 것이 좋다.</li><li>이 단계 동안 중복을 없애고, 프로그래머 의도를 표현하고 클래스와 메서드 수를 줄이는 단계이다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="중복을-없애라"></a>중복을 없애라<a class="hash-link" href="#중복을-없애라" title="Direct link to heading">#</a></h3><ul><li>중복은 추가 작업, 추가 위협, 불필요한 복잡도를 의미한다.</li><li>TEMPLATE METHOD 패턴은 고차원 중복을 제거할 목적으로 자주사 사용하는 기법</li></ul><blockquote><p>Templaet Method Pattern. 동작 상의 알고리즘의 프로그램 뼈대를 정의하는 행위 디자인 패턴, 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 다시 정의할 수 있게 해 준다</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="표현하기"></a>표현하기<a class="hash-link" href="#표현하기" title="Direct link to heading">#</a></h3><p>많은 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다.</p><p>이를 해결하는 방법은 다음과 같다.</p><ol><li>좋은 이름 선택한다.</li><li>함수와 클래스 크기를 가능한 줄인다.</li><li>표준 명칭을 사용한다.</li><li>단위 테스트 케이스를 꼼꼼히 작성한다.</li></ol><p>가장 큰 핵심은 나중에 볼 사람을 위해서 <strong>노력</strong>해야 한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="클래스와-메서드-수를-최소로-줄이기"></a>클래스와 메서드 수를 최소로 줄이기<a class="hash-link" href="#클래스와-메서드-수를-최소로-줄이기" title="Direct link to heading">#</a></h3><ul><li>너무 중복을 제거하고, 의도를 표현하고, SRP를 준수하는 경우에는 단점이 발생할 수 있다.</li><li>목표는 함수와 클래스 크기를 줄이면서 시스템 크기를 작게 유지하는 것이다.</li><li>단, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="13장-동시성"></a>13장. 동시성<a class="hash-link" href="#13장-동시성" title="Direct link to heading">#</a></h2><p>동시성과 깔끔한 코드는 양립하기 아주 어렵다. 깨끗한 동시성은 사실 매우 중요하며, 어려운 문제이다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동시성이-필요한-이유"></a>동시성이 필요한 이유?<a class="hash-link" href="#동시성이-필요한-이유" title="Direct link to heading">#</a></h3><ul><li>동시성은 결함(coupling)을 없애는 전략. 즉, <strong>무엇</strong>과 <strong>언제</strong>를 분리하는 전략이다.</li><li>무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.</li><li>시스템 응답 시간과 작업 처리량 개선으로 인해 동시성이 필요하다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="미신과-오해"></a> 미신과 오해<a class="hash-link" href="#미신과-오해" title="Direct link to heading">#</a></h4><p>대표적인 오해.</p><ul><li>동시성은 항상 성능을 높여준다.<ul><li>동시성은 <strong>때로</strong> 성능을 높여준다. 즉, 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.</li></ul></li><li>동시성을 구현해도 설계는 변하지 않는다.<ul><li>단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 <strong>무엇</strong>과 <strong>언제</strong>를 분리하면 시스템 구조가 달라진다.</li></ul></li><li>웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.<ul><li>실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 한다.</li></ul></li></ul><p>타당한 생각.</p><ul><li><strong>동시성은 사소 부하를 유발한다.</strong> 성능 측면에서 부하가 걸리며, 코드도 더 짜야한다.</li><li><strong>동시성은 복잡하다.</strong> 간단한 문제라도 동시성은 복잡하다.</li><li><strong>일반적으로 동시성 버그는 제한하기 어렵다.</strong> 그래서 진짜 결함으로 간주 하지 않고 일회성 문제로 여겨 무시하기 쉽다.</li><li><strong>동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.</strong></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="난관"></a>난관<a class="hash-link" href="#난관" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class X {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int lastIdUsed;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public int getNextId() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return ++lastIdUsed;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음과 같은 경우. 인스턴스 X를 생성하고 lastIdUsed를 필드. 42로 설정하는 경우로 보면.</p><ul><li>어떤 스레드는 43을 받고 다른 스레드는 44를 받는데 저장은 제각각이다. 이러한 스레드가 수많이 있다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동시성-방어-원칙"></a>동시성 방어 원칙<a class="hash-link" href="#동시성-방어-원칙" title="Direct link to heading">#</a></h3><p>다양한 방어 원칙과 기술이 있다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단일-책임-원칙srp-single-reponsibility-priniciple"></a>단일 책임 원칙(SRP, Single Reponsibility Priniciple)<a class="hash-link" href="#단일-책임-원칙srp-single-reponsibility-priniciple" title="Direct link to heading">#</a></h4><blockquote><p>SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙</p></blockquote><p>동시성은 복잡성 하므로 다른 코드와 분리해야 한다. 아래는 고려해야 할 사항이다.</p><ul><li>동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.</li><li>동시성 코드에는 독자적인 난관이 있으며 이는 더 어렵다.</li><li>잘못 구현된 동시성 코드는 온갖 에러가 발생한다.</li></ul><p><strong>따라서. 동시성 코드는 다른 코드와 분리한다.</strong></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="따름-정리corollary--자료-범위를-제한해라"></a>따름 정리(corollary) : 자료 범위를 제한해라<a class="hash-link" href="#따름-정리corollary--자료-범위를-제한해라" title="Direct link to heading">#</a></h4><p>공유 객체를 사용하는 코드 <strong>임계 영역(critical</strong> section)을 synchronized 키워드로 보호하는 것뿐만 아니라, 이 수를 줄여야 한다.</p><p>수가 많으면 다음과 같은 문제가 발생한다.</p><ul><li>보호할 임계 영역을 빼먹어서 해당 자료를 수정하는 모든 코드가 망가진다.</li><li>모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고가 필요하다.</li><li>찾기 어려운 버그를 더 찾기 힘들어진다.</li></ul><p><strong>따라서. 자료를 캡슐화해야 하며, 공유 자료를 최대한 줄여야 한다.</strong></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="따름-정리--자료-사본을-사용하기"></a>따름 정리 : 자료 사본을 사용하기<a class="hash-link" href="#따름-정리--자료-사본을-사용하기" title="Direct link to heading">#</a></h4><p>공유 자료를 줄이는 최고의 방법은 공유하지 않은 방법이다. 즉, 객체를 복사해서 읽는 방법도 존재한다. 객체를 복사하는 비용이 그렇게 크지않다면 나쁘지 않는 방법이다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="따름-정리--스레드는-가능한-독립적으로-구현하라"></a>따름 정리 : 스레드는 가능한 독립적으로 구현하라<a class="hash-link" href="#따름-정리--스레드는-가능한-독립적으로-구현하라" title="Direct link to heading">#</a></h4><p>다른 스레드와 공유하지 않는 독립적인 스레드를 구성해라. (예를 들면 로컬 변수 등)</p><p><strong>따라서, 독자적인 스레드로, 가능하다면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할한다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="라이브러리를-이해하기"></a>라이브러리를 이해하기.<a class="hash-link" href="#라이브러리를-이해하기" title="Direct link to heading">#</a></h3><p>자바 5에서 스레드를 구현한다면 다음을 고려해보기.</p><ul><li>스레드 환경에 안전한 컬렉션을 사용.</li><li>서로 무관한 작업을 수행할 때는 executor 프레임워크 사용.</li><li>가능하다면 스레드가 차단(blocking) 되지 않는 방법을 사용.</li><li>일부 클래스 라이브러리는 스레드에 안전하지 못함.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스레드-환경에-안전한-컬렉션"></a>스레드 환경에 안전한 컬렉션<a class="hash-link" href="#스레드-환경에-안전한-컬렉션" title="Direct link to heading">#</a></h4><p>다중 스레드에서 안전한 메소드로 여러 가지 존재한다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>ConcurrentHashMap</td><td>HashMap보다 거의 모든 상황에서 빠르다.</td></tr><tr><td>ReentrantLock</td><td>한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)이다.</td></tr><tr><td>Semaphore</td><td>전형적인 세마포어, 개수(count)가 있는 락이다.</td></tr><tr><td>CountDownLatch</td><td>지정한 수만큼 이벤트가 발생하고 대기 중인 스레드를 모드 해제하는 락.</td></tr><tr><td>모든 스레드에게 동시에 공평하게 시작할 권리를 제공</td><td></td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="실행-모델을-이해하기"></a>실행 모델을 이해하기.<a class="hash-link" href="#실행-모델을-이해하기" title="Direct link to heading">#</a></h3><p>간단한 기본 용어는 다음과 같다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>한정된 자원 (Bound Resource)</td><td>다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다.</td></tr><tr><td>데이터 베이스 연결, 길이가 일정한 읽기/쓰기 버퍼 등이 예시이다.</td><td></td></tr><tr><td>상호 배제 (Mutual Exclusion)</td><td>한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.</td></tr><tr><td>기아 (Starvation)</td><td>한 스레드나 여러 스레드가 굉장히 오랫동안 호은 영원한 자원을 기다린다.</td></tr><tr><td>예를 들어, 항상 짧은 스레드에게 우선순위를 준다면, 짧은 스레드가 지속적으로 이루어지는 경우, 긴 스레드가 기아 상태에 빠진다.</td><td></td></tr><tr><td>데드락 (Deadlock)</td><td>여러 스레드가 서로가 끝나기를 기다린다.</td></tr><tr><td>모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느쪽도 더이상 진행하지 못한다.</td><td></td></tr><tr><td>라이브락 (Livelock)</td><td>락을 거는 단계에서 각 스레드가 서로를 방해한다.</td></tr><tr><td>스레드는 계속해서 진행하려 하지만, 공명(response)으로 인해, 굉장히 오랫동안 혹은 영원히 진행하지 못한다.</td><td></td></tr></tbody></table><p>다중 스레드 프로그래밍에서 실행하는 방법은 대부분 아래의 3가지 방법이다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="생산자-소비자producer-consumer"></a>생산자-소비자(Producer-Consumer)<a class="hash-link" href="#생산자-소비자producer-consumer" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/92720407-84b49c00-f39f-11ea-971b-582f1952a73a.png" alt="image"></p><p>다음 그림처럼 <strong>한정적 자원</strong>을 생산자는 정보를 생성하고, 소비자는 정보를 사용한다.</p><p>생산자 스레드는 정보를 채우고 시그널을 보내고, 소비자는 대기열에 정보를 읽은 후 시그널을 보낸다. 단, 동시에 시그널을 기다릴 가능성 또한 존재한다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="읽기-쓰기readers-writers"></a>읽기-쓰기(Readers-Writers)<a class="hash-link" href="#읽기-쓰기readers-writers" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/92720672-e412ac00-f39f-11ea-9905-8e06721b39ab.png" alt="image"></p><p>읽기 스레드가 공유 자원을 사용하지만, 처리율이 부족한 경우 기아 현상이나 오래된 정보가 쌓인다.</p><p>이러한 처리율을 높이는 방법은 여러 가지가 있는데.</p><ul><li>간단한 전략 : 읽기 스레드가 없을 때까지 쓰기 스레드가 버퍼를 기다리는 방법, 하지만 쓰기 스레드가 기아 발생 가능.</li><li>이러한 방법을 갱신하는 밥법은 &quot;<strong>식사하는 철학자들</strong>&quot; 방법이 있다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="식사하는-철학자들dining-philosopheres"></a>식사하는 철학자들(Dining Philosopheres)<a class="hash-link" href="#식사하는-철학자들dining-philosopheres" title="Direct link to heading">#</a></h4><p><img src="https://user-images.githubusercontent.com/42582516/92725422-196ec800-f3a7-11ea-8f11-9ff2bbac63f6.png" alt="image"></p><p>여기서 철학자는 스레드이고, 포크는 자원이다. 여기서, 자원을 얻으려면 몇몇의 스레드는 쉬어야 하는 것을 알 수 있다.</p><p>단 이와 같은 설계를 할 때는 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 고려해서 사용해야 한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기화하는-메서드-사이에-존재하는-의존성을-이해"></a>동기화하는 메서드 사이에 존재하는 의존성을 이해<a class="hash-link" href="#동기화하는-메서드-사이에-존재하는-의존성을-이해" title="Direct link to heading">#</a></h3><ul><li><strong>공유 객체 하나에는 메서드 하나만 사용하기.</strong></li></ul><p>공유 객체 하나에 여러 메서드가 필요한 경우는 다음과 같은 세 가지 방법을 고려한다.</p><ul><li>클라이언트에서 잠금 : 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠금. 마지막 메서드를 호출할 때까지 잠금을 유지한다</li><li>서버에서 잠금 : 서버에다 &quot;서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는&quot; 메서드를 구현. 클라이언트는 이 메서드를 구현</li><li>연결(Adapted) 서버 : 잠금을 수행하는 중간 단계를 생성. &#x27;서버에서 잠금&#x27; 방식과 유사하지만 원래 서버는 변경하지 않음</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동기화하는-부분을-작게-만들기"></a>동기화하는 부분을 작게 만들기<a class="hash-link" href="#동기화하는-부분을-작게-만들기" title="Direct link to heading">#</a></h3><p>필요 이상으로 임계 영역 크기를 키우면 스레드 간 경쟁이 늘어나고 프로그램 성능이 떨어진다.</p><p><strong>따라서. 동기화하는 부분을 최대한 작게 만든다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="올바른-종료-코드는-구현하기-어렵다"></a>올바른 종료 코드는 구현하기 어렵다<a class="hash-link" href="#올바른-종료-코드는-구현하기-어렵다" title="Direct link to heading">#</a></h3><p>데드락에 걸려서 종료 코드가 안 갈 수도 있다. 따라서 <strong>종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현해야 한다. 생각보다 오래 걸리고 어려우므로 나온 알고리즘을 검토하는 것도 좋은 방법이다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스레드-코드-테스트하기"></a>스레드 코드 테스트하기<a class="hash-link" href="#스레드-코드-테스트하기" title="Direct link to heading">#</a></h3><p>하나의 스레드에서는 이전에 했던 모든 말 들이 통용되지만, 여러 스레드에서의 상황은 복잡하다.</p><p><strong>따라서. 문제를 노출하는 테스트 케이스를 작성한다. 프로그램 설정과 시스템 설정과 부하를 바꿔가면서 자주 돌리고 테스트가 실패할 경우 원인을 추적해야 한다. 다시 돌렸더니 통과한다는 이유로 넘어가면 안 된다.</strong></p><p>구체적인 지침은 다음과 같다.</p><ul><li>말이 안 되는 실패를 잠정적인 스레드 문제로 취급하기<ul><li>시스템 실패를 &#x27;일회성&#x27;이라고 취급하지 말기.</li></ul></li><li>다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들기<ul><li>스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하면 안 된다. 먼저 스레드 환경 밖부터 해결해야 한다.</li></ul></li><li>다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현<ul><li>다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현</li></ul></li><li>다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정해주기<ul><li>프로그램 처리율과 효율에 따라 스레드 개수를 조율하는 코드도 고민해보기</li></ul></li><li>프로세서 수보다 많은 스레드 돌려보기<ul><li>스와핑이 잦을수록 임계 영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.</li></ul></li><li>다른 플랫폼에서 돌려보기<ul><li>처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려보는 것이 좋다.</li></ul></li><li>코드에 보조 코드(instruction)를 넣어 돌리기. 강제로 실패 만들기.<ul><li>방법 1. 직접 구현하기<ul><li>코드에다 wait(), sleep(), yield(), probity() 함수를 추가하기.</li><li>생각했는 결과물과 맞는지 체크하기.</li></ul></li><li>방법 2. 자동화<ul><li>AOP(Aspect-Oriented Framework), CGLIB, ASM 등의 도구를 사용</li><li><strong>흔들기 기법</strong>(jiggle) 등을 사용해 오류를 찾는 것도 좋다. 이를 사용하면 스레드를 매번 다른 순서로 실행한다.</li></ul></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="결론-1"></a>결론.<a class="hash-link" href="#결론-1" title="Direct link to heading">#</a></h3><p>핵심은 다음과 같다.</p><ul><li>SRP를 준수하기</li><li>동시성 오류를 일으키는 잠정적 원인을 정학하게 이해</li><li>사용하는 라이브러리와 기본 알고리즘을 정확히 이해</li><li>보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/dev/clean-code/ch4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-05-30T06:28:12.000Z" class="lastUpdatedDate_1WI_">5/30/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/dev/clean-code/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Clean Code 내용 정리 - 3</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/dev/clean-code/ch5"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Clean Code 내용 정리 - 5 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#11장-시스템" class="table-of-contents__link">11장. 시스템</a><ul><li><a href="#도시가-잘-돌아가는-이유" class="table-of-contents__link">도시가 잘 돌아가는 이유</a></li><li><a href="#시스템-제작과-시스템-사용을-분리" class="table-of-contents__link">시스템 제작과 시스템 사용을 분리</a></li><li><a href="#확장" class="table-of-contents__link">확장</a></li><li><a href="#자바-프록시" class="table-of-contents__link">자바 프록시</a></li><li><a href="#순수-자바-aop-프레임워크" class="table-of-contents__link">순수 자바 AOP 프레임워크</a></li><li><a href="#aspectj-관점" class="table-of-contents__link">AspectJ 관점</a></li><li><a href="#테스트-주도-시스템-아키텍처-구축" class="table-of-contents__link">테스트 주도 시스템 아키텍처 구축</a></li><li><a href="#의사-결정을-최적화" class="table-of-contents__link">의사 결정을 최적화</a></li><li><a href="#명백한-가치가-있을-때-표준을-현명하게-사용" class="table-of-contents__link">명백한 가치가 있을 때 표준을 현명하게 사용</a></li><li><a href="#시스템은-도메인-특화-언어가-필요" class="table-of-contents__link">시스템은 도메인 특화 언어가 필요</a></li><li><a href="#결론" class="table-of-contents__link">결론</a></li></ul></li><li><a href="#12장-창발성" class="table-of-contents__link">12장. 창발성</a><ul><li><a href="#창발적-설계로-깔끔한-코드를-구현" class="table-of-contents__link">창발적 설계로 깔끔한 코드를 구현</a></li><li><a href="#단순한-설계-규칙-1-모든-테스트를-실행" class="table-of-contents__link">단순한 설계 규칙 1: 모든 테스트를 실행</a></li><li><a href="#단순한-설계-규칙-24-리팩터링" class="table-of-contents__link">단순한 설계 규칙 2~4: 리팩터링</a></li><li><a href="#중복을-없애라" class="table-of-contents__link">중복을 없애라</a></li><li><a href="#표현하기" class="table-of-contents__link">표현하기</a></li><li><a href="#클래스와-메서드-수를-최소로-줄이기" class="table-of-contents__link">클래스와 메서드 수를 최소로 줄이기</a></li></ul></li><li><a href="#13장-동시성" class="table-of-contents__link">13장. 동시성</a><ul><li><a href="#동시성이-필요한-이유" class="table-of-contents__link">동시성이 필요한 이유?</a></li><li><a href="#난관" class="table-of-contents__link">난관</a></li><li><a href="#동시성-방어-원칙" class="table-of-contents__link">동시성 방어 원칙</a></li><li><a href="#라이브러리를-이해하기" class="table-of-contents__link">라이브러리를 이해하기.</a></li><li><a href="#실행-모델을-이해하기" class="table-of-contents__link">실행 모델을 이해하기.</a></li><li><a href="#동기화하는-메서드-사이에-존재하는-의존성을-이해" class="table-of-contents__link">동기화하는 메서드 사이에 존재하는 의존성을 이해</a></li><li><a href="#동기화하는-부분을-작게-만들기" class="table-of-contents__link">동기화하는 부분을 작게 만들기</a></li><li><a href="#올바른-종료-코드는-구현하기-어렵다" class="table-of-contents__link">올바른 종료 코드는 구현하기 어렵다</a></li><li><a href="#스레드-코드-테스트하기" class="table-of-contents__link">스레드 코드 테스트하기</a></li><li><a href="#결론-1" class="table-of-contents__link">결론.</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.ef1a43cb.js"></script>
<script src="/til/assets/js/main.647c3b77.js"></script>
</body>
</html>