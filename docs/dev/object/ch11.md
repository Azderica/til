---
sidebar_position: 11
---

# 11. 합성과 유연한 설계

- 상속 관계는 `is-a 관계` 라 부르고 합성 관계는 `has-a 관계` 라 불립니다.
- 합성은 구현에 의존하지 않다는 점에서 상속과 다릅니다. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존합니다.

## 01. 상속을 합성으로 변경하기

### 불필요한 인터페이스 상속 문제

- 상속이 초래하는 문제는 다음과 같습니다.
  - 불필요한 인터페이스 상속 문제
  - 메서드 오버라이딩의 오작용 문제
  - 부모 클래스와 자식 클래스의 동시 수정 문제

### java.util.Properties와 java.util.Stack

- 합성 관계로 변경함으로써 클라이언트가 Stack을 잘못 사용할 수 있다는 가능성을 깔끔하게 제거합니다.

### 메서드 오버라이딩의 오작용 문제: InstrumentedHashSet

- 내부의 인스턴스에게 동일한 메서드 호출을 그래도 전달하는 것을 포워딩(forwarding) 이라 부르고 동일한 메서드를 호출하기 위해 추가된 메서드를 포워드 메서드(forwarding method)라고 부릅니다.

### 부모 클래스와 자식 클래스의 동시 수정 문제: PersonalPlaylist

- 대부분의 경우 구현에 대한 결합보다는 인터페이스 결합이 더 좋습니다.

<br/>

## 02. 상속으로 인한 조합의 폭발적인 증가

### 기본 정책과 부가 정책 조합하기

### 상속을 이용해서 기본 정책 구현하기

### 기본 정책에서 세금 정책 조합하기

### 기본 정책에 기본 요금 할인 정책 조합하기

### 중복 코드의 덫에 걸리다

<br/>

## 03. 합성 관계로 변경하기

### 기본 정책 합성하기

### 부가 정책 적용하기

### 기본 정책와 부가 정책 합성하기

### 새로운 정책 추가하기

### 객체 합성이 클래스 상속보다 더 좋은 방법이다.

<br/>

## 04. 믹스인

### 기본 정책으로 구현하기

### 트레이트로 부가 정책 구현하기

### 부가 정책 트레이트 믹스인하기

### 쌓을 수 있는 변경