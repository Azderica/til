---
sidebar_position: 8
---

# 8. 애그리거트 트랜잭션 관리

## 애그리거트와 트랜잭션

- 한 애그리거트를 두 사용자가 거의 동시에 변경할 때 트랜잭션이 필요합니다.
- 운영자는 기본 배송지 정보를 이용해서 배송 상태로 변경했는데 그 사이 고객은 배송지 정보를 변경했습니다. 즉, 애그리거트의 일관성이 깨집니다. 이런 문제가 발생하지 않도록 하려면 다음의 두 가지 중 하나를 해야 한다.
  - 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.
  - 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 합니다.
- 이 두가지는 애그리거트 자체의 트랜잭션과 관련이 있습니다.
- 대표적인 트랜잭션 처리 방식에는 **선점(Perssimistic) 잠금**과 **비선점(Optimistic) 잠금**의 두 가지 방식이 있습니다.

<br/>

## 선점 잠금

- 선점 잠금(Pessimistic Lock)은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식입니다.
- 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있습니다.
- 선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현합니다.

### 선점 잠금과 교착 상태

- 선점 잠금 기능을 사용할 때는 잠금 순서에 따한 교착 상태(deadlock)가 발생하지 않도록 주의해야 합니다.
- 선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자 수가 많아지면 교착 상태에 빠지는 스레드가 더 빠르게 증가합니다.
  - 더 많은 스레드가 교착 상태에 빠질수록 시스템은 점점 아무것도 할 수 없는 상황에 이르게 된다.

<br/>

## 비선점 잠금

### 강제 버전 증가

<br/>

## 오프라인 선점 잠금

### 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스

### DB를 이용한 LockManager 구현