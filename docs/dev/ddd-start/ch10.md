---
sidebar_position: 10
---

# 10. 이벤트

## 시스템 간 강결합의 문제

- 쇼핑물에서 구매를 취소하면 환불을 처리해야 합니다.
- 보통 결제 시스템은 외부에 존재하므로 외부의 환불 서시스템 서비스를 호출하는데 두가지 문제가 발생합니다.
  - 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매하다는 것입니다.
  - 환불을 처리하는 외부 시스템의 응답시간이 길어질수록 대기시간이 발생하는 성능에 대한 이슈가 발생합니다.
  - 이 문제 외에도 설계상 문제가 나타날 수 있습니다.
- 위와 같은 강한 결함을 없앨 수 있는 방법으로 **이벤트**를 사용해 결합을 나출 수 있습니다.

<br/>

## 이벤트 개요

- 해당 챕터에서 이벤트(event)는 "과거에 벌어진 어떤 것"을 의미합니다.
- 이벤트가 발생하면 상태가 변경됐다를 의미합니다.

### 이벤트 관련 구성요소

- 도메인 모델에 이벤트를 도입하려면 같은 네 개의 구성요소를 구현해야 합니다.

![이벤트 관련 구성요소](https://user-images.githubusercontent.com/42582516/160224240-ca76a9a2-321c-456b-a27b-d745d5b36b0e.png)

- 도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체입니다.
  - 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 실행합니다.
- 이벤트 핸들러(handler)는 이벤트 생성 주체가 발생한 이벤트에 반응합니다.
- 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것이 이벤트 디스패처(dispatcher)입니다.

### 이벤트의 구성

- 이벤트는 발생한 이벤트에 대한 정보를 담습니다.
  - 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
  - 이벤트 발생 시간
  - 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보
- 이벤트는 이벤트 핸들러가 작업을 수행하는 데 필요한 최소한의 데이터를 담아야합니다.
- 이벤트는 데이터를 담아야 하나 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없습니다.

### 이벤트 용도

- 이벤트는 크게 두 가지 용도로 쓰입니다.
  - 첫번째 용도는 트리거입니다.
  - 두번째 용도는 서로 다른 시스템 간의 데이터 동기화입니다.

### 이벤트 장점

- 이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있습니다.

<br/>

## 이벤트, 핸들러, 디스패처 구현

- 이벤트와 관련된 코드는 다음과 같습니다.
  - 이벤트 클래스
  - 이벤트 핸들러(EventHandler) : 이벤트 핸들러를 위한 상위 타입으로 모든 핸들러는 이 인터페이스를 구현합니다.
  - 이벤트(Events) : 이벤트 디스패처, 이벤트 발행, 이벤트 핸들러 등록, 이벤트를 핸들러에 등록하는 등의 기능을 제공

### 이벤트 클래스

- 이벤트 자체를 위한 상위 타입은 존재하지 않습니다.
- 이벤트 구성에서 설명한 것처럼 이벤트 클래스는 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함해야합니다.
- 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있습니다.

```java
public abstract class Event {
  private long timestamp;

  public Event() {
    this.timestamp = System.currentTimeMillis();
  }

  public long getTimestamp(){
    return timestamp;
  }
}
```

### EventHandler 인터페이스

- EventHandler 인터페이스는 이벤트 핸들러를 위한 상위 인터페이스입니다.

```java
public interface EventHandler<T> {
  void handle(T event);

  default boolean canHandle(Object event) {
    Class<?>[] typeArgs = TypeResolver.resolveRawArguments(EventHandler.class, this.getClass());
    return typeArgs[0].isAssignableFrom(event.getClass());
  }
}
```

- EventHandler 인터페이스를 상속받는 클래스는 handle() 메서드를 이용해서 필요한 기능을 구현하면 됩니다.

### 이벤트 디스패처인 Events 구현

- 이벤트 핸들러 등록을 쉽게 하기 위해 정적 메서드를 이용해서 구현합니다.
- 이벤트를 발생시킬 때에는 `Events.raise()` 메서드를 사용합니다.
- `Events.raise()`를 이용해서 이벤트를 발생시키면 `Events.raise()` 메서는 이벤트를 처리할 핸들러를 찾아 handle()메서드를 실행합니다.

### 흐름 정리

![이벤트 처리 흐름](https://user-images.githubusercontent.com/42582516/160265052-2b521e8a-cb7d-4fcb-9b54-9dd9bdb50d9b.png)

### AOP를 이용한 Events.reset() 실행

- 응용 서비스가 끝나면 ThreadLocal에 등록된 핸들러 목록을 초기화하기 위해 Events.reset() 메서드를 실행합니다.

<br/>

## 동기 이벤트 처리 문제

<br/>

## 비동기 이벤트 처리

### 로컬 핸들러의 비동기 실행

### 메시징 시스템을 이용한 비동기 구현

### 이벤트 저장소를 이용한 비동기 처리

### 이벤트 저장소 구현

### 이벤트 저장을 위한 이벤트 핸들러 구현

### REST API 구현

### 포워드 구현

<br/>

## 이벤트 적용 시 추가 고려사항
