# 가비지 수집 기초

가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하고 쓸모없는 객체를 알아서 제거하는 것입니다. 이렇게 자동 회수한 메모리는 께끗이 비우고 재활용할 수 있습니다.

가비지 수집 구현체는 다음 두 가지 기본 원칙을 준수해야합니다.

- 알고리즘은 반드시 모든 가비지를 수집해야합니다.
- **살아있는 객체는 절대로 수집하면 안됩니다.**

사용중인 객체를 수집하면 세그먼테이션 결함이 발생합니다.

<br/>

## 마크 앤 스위프

> 마크 앤 스위프, 표지하고 쓸어담기

전체적인 GC 알고리즘

- 할당 리스트를 순회하면서 마크 비트를 지웁니다.
- GC 루트부터 살아 있는 객체를 찾습니다.
- 이렇게 찾은 객체마다 마크 비트를 세팅합니다.
- 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾습니다.
  - 힙에서 메모리를 회수해 프리 리스트에 되돌립니다.
  - 할당 리스트에서 객체를 삭제합니다.

보통 살아 있는 객체는 대부분 DFS로 찾습니다. 이렇게 해서 생성된 **객체 그래프를 라이브 객체 그래프**라고하며 접근 가능한 객체의 전이 폐쇄라고 합니다.

### 가비지 수집 용어

- STW
  - GC 사이클이 발생해서 가비지를 수집하는 동안에 모든 애플리케이션 스레드가 중단되는 상황
- 동시
  - GC 스레드는 애플리케이션 스레드와 동시 실행될 수 있습니다.
- 병렬
  - 여러 스레드를 동원해서 가비지 수집을 합니다.
- 정확
  - 정확한 GC 스킵은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 가지고 있습니다.
- 보수
  - 리소스를 낭비하는 일이 많고 근본적으로 타입 체계를 무시하므로 비효율적입니다.
- 이동
  - 이동 수집기에서 객체는 메모리를 오갈 수 있습니다.
  - 객체 주소가 고정된 게 아닙니다.
- 압착
  - 할당된 메모리는 GC 사이클 마지막에 연속된 단일 영역으로 배열되며 배열됩니다.
  - 이는 `memory fragmentation`을 방지합니다.
- 방출
  - 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 방출합니다.

<br/>

## 핫스팟 런타임 개요

자바에서는 두가지 값만 사용함

- 기본형(byte, int 등)
- 객체 레퍼런스

자바는 C++와 달리 **주소를 역참조(dereference)하는 일반적인 메커니즘이 없고 오직 오프셋 연산자나 객체 레퍼런스의 메서드를 호출**할 수 있습니다. 또한 자바는 값으로 호출(`callByValue`)하는 방식으로만 **메서드를 호출**합니다. 객체 레퍼런스의 경우, 복사된 값은 힙에 있는 객체의 주소입니다.

### 객체를 런타임에 표현하는 방법

핫스팟은 런타임에 oop(ordinary object pointer, 평범한 객체 포인터)라는 구조체로 자바 객체를 나타냅니다. (C의 포인터와 비슷합니다.) oop는 참조형 지역 변수 안에 위치하며 메서드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킵니다.

oop를 구성하는 자료 구조는 여러가지가 있습니다. 그중 `instanceOop`는 자바 클래스의 인스턴스를 나타냅니다.

이는 크게 두개의 기계어 워드 2개로 구성됩니다.

- Mark 워드(인스턴스 관련 메타데이터를 가리키는 포인터)
- Klass 워드(클래스 메타데이터를 가리키는 포인터)

자바 8이후로는 기존과 달리 Klass 워드가 자바 힙 밖을 가리키므로 객체 헤더가 필요없습니다.

![image](https://user-images.githubusercontent.com/42582516/120794204-e1319a00-c572-11eb-99ad-01812d930ac8.png)

배열또한 이러한 객체입니다. 그렇기 때문에 Klass 워드 다음에 배열 길이를 나타내는 Length워드가 붙어있어서 C++처럼 길이를 주지 않아도 됩니다.

JVM 환경에서 자바 레퍼런스는 `instanceOop`를 제외한 어떤 것도 가리킬 수 없습니다.

- 자바 값은 기본형 값 또는 `instanceOop` 주소(레퍼런스)에 대응되는 비트 패턴입니다.
- 모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터입니다.
- 자바 레퍼런스가 가리키는 주소에는 `Mark` 워드와 `Klass` 워드가 들어있습니다.
- `klassOop`와 `Class<?>` 의 인스턴스는 다르며 `klassOop`(힙의 메타데이터 영역에 있음)을 자바 변수에 넣을 수 없습니다.

핫스팟의 oop 체계를 까보면 다음과 같습니다. (hotspot/src/share/vm/oops
)

```
oop (추상 베이스)
 instanceOop (인스턴스 객체)
 methodOop (메서드 표현형)
 arrayOop (배열 추상 베이스)
 symbolOop (내부 심볼 / 스트링 클래스)
 klassOop (Klass 헤더) (자바 7 이전만 해당)
 markOop
```

### GC 루트 및 아레나

**GC 루트**는 **메모리의 고정점(앵커 포인트, anchor point)으로 메모리 풀 외부에서 내부를 가리키는 포인터**입니다. 즉, 메모리 풀 내부에서 같은 메모리 풀 내부의 다른 메모리 위치를 가리키는 `내부 포인터(internal pointer)`와 정반대인 외부 포인터입니다.

다음과 같은 종류가 있습니다.

- 스택 프레임(stack frame)
- JNI
- 레지스터(호이스트된 변수)
- 코드 루트
- 전역 객체
- 로드된 클래스의 메타데이터

핫스팟 GC는 `아레나`라는 메모리 영역에서 작동합니다. 핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않습니다.

자바/JVM 워크로드의 **가비지 수집을 일으키는 두 가지 주요 특성**에 대해 살펴보면 다음과 같습니다. 이는 **할당과 수명**입니다.

<br/>

## 할당과 수명

<br/>

## 핫스팟의 가비지 수집

<br/>

## 병렬 수집기

<br/>

## 할당의 역할
