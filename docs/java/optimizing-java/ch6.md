# 가비지 수집 기초

가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하고 쓸모없는 객체를 알아서 제거하는 것입니다. 이렇게 자동 회수한 메모리는 께끗이 비우고 재활용할 수 있습니다.

가비지 수집 구현체는 다음 두 가지 기본 원칙을 준수해야합니다.

- 알고리즘은 반드시 모든 가비지를 수집해야합니다.
- **살아있는 객체는 절대로 수집하면 안됩니다.**

사용중인 객체를 수집하면 세그먼테이션 결함이 발생합니다.

<br/>

## 마크 앤 스위프

> 마크 앤 스위프, 표지하고 쓸어담기

전체적인 GC 알고리즘

- 할당 리스트를 순회하면서 마크 비트를 지웁니다.
- GC 루트부터 살아 있는 객체를 찾습니다.
- 이렇게 찾은 객체마다 마크 비트를 세팅합니다.
- 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾습니다.
  - 힙에서 메모리를 회수해 프리 리스트에 되돌립니다.
  - 할당 리스트에서 객체를 삭제합니다.

보통 살아 있는 객체는 대부분 DFS로 찾습니다. 이렇게 해서 생성된 **객체 그래프를 라이브 객체 그래프**라고하며 접근 가능한 객체의 전이 폐쇄라고 합니다.

### 가비지 수집 용어

- STW
  - GC 사이클이 발생해서 가비지를 수집하는 동안에 모든 애플리케이션 스레드가 중단되는 상황
- 동시
  - GC 스레드는 애플리케이션 스레드와 동시 실행될 수 있습니다.
- 병렬
  - 여러 스레드를 동원해서 가비지 수집을 합니다.
- 정확
  - 정확한 GC 스킵은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 가지고 있습니다.
- 보수
  - 리소스를 낭비하는 일이 많고 근본적으로 타입 체계를 무시하므로 비효율적입니다.
- 이동
  - 이동 수집기에서 객체는 메모리를 오갈 수 있습니다.
  - 객체 주소가 고정된 게 아닙니다.
- 압착
  - 할당된 메모리는 GC 사이클 마지막에 연속된 단일 영역으로 배열되며 배열됩니다.
  - 이는 `memory fragmentation`을 방지합니다.
- 방출
  - 수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 방출합니다.

<br/>

## 핫스팟 런타임 개요

<br/>

## 할당과 수명

<br/>

## 핫스팟의 가비지 수집

<br/>

## 병렬 수집기

<br/>

## 할당의 역할
