<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">9. JVM의 코드 실행 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/optimizing-java/ch9"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="9. JVM의 코드 실행 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="JVM이 제공하는 가장 중요한 서비스는 메모리 관리와 사용하기 쉬운 애플리케이션 코드 실행 컨테이너입니다."><meta data-react-helmet="true" property="og:description" content="JVM이 제공하는 가장 중요한 서비스는 메모리 관리와 사용하기 쉬운 애플리케이션 코드 실행 컨테이너입니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch9"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch9" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch9" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.a52dcdb0.js" as="script">
<link rel="preload" href="/til/assets/js/main.8c5e1940.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">9. JVM의 코드 실행</h1></header><div class="markdown"><p>JVM이 제공하는 <strong>가장 중요한 서비스는 메모리 관리와 사용하기 쉬운 애플리케이션 코드 실행 컨테이너</strong>입니다.</p><p>이 장에서는 바이트코드 해석을 알아보고 인터프리터와 핫스팟의 차이점에 대해 알아봅니다. 그리고 프로파일 기반 최적화의 기초 개념을 다루고 코드 캐시 및 핫스팟 컴파일 서비시스템의 기본적인 내용을 다룹니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="바이트코드-해석"></a>바이트코드 해석<a class="hash-link" href="#바이트코드-해석" title="Direct link to heading">#</a></h2><p>JVM 인터프리터는 일종의 스택 머신처럼 작동하므로 물리적 CPU와는 달리 계산 결과를 보관하는 레지스터리는 없습니다. 대신 작업할 값은 모두 평가 스택에 놓고 스택 머신 명령어로 스택 최상단에 위치한 값을 모두 평가 스택에 놓고 스택 머신 명령어로 스택 최상단에 위치한 값을 변환하는 식으로 작동합니다.</p><p>JVM은 다음 세 공간에 주로 데이터를 담아 높습니다.</p><ul><li>평가 스택 : 메서드별로 하나씩 생성됩니다.</li><li>로컬 변수 : 결과를 임시 저장합니다.</li><li>객체 힙 : 메서드끼리, 스레드끼리 공유됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jvm-바이트코드-개요"></a>JVM 바이트코드 개요<a class="hash-link" href="#jvm-바이트코드-개요" title="Direct link to heading">#</a></h3><p>자바는 처음부터 이식성을 염두에 두고 설계된 언어입니다. 따라서 big endian, little endian 하드웨어 아키텍처 모두 바이트 코드 변경없이 실행 가능하도록 명세에 규정되어 있습니다.</p><p>다음과 같은 명령어가 있습니다.</p><ul><li>로드/스토어 카테고리<ul><li>load, store, ldc, const, pop, dup, getField, putField</li></ul></li><li>산술 카테고리<ul><li>add, sub, div, mul</li></ul></li><li>흐름 제어 카테고리<ul><li>if, goto</li></ul></li><li>메서드 호출 카테고리<ul><li>invokevirtual, invokespecial, ...</li></ul></li><li>플랫폼 카테고리<ul><li>new, newarray, anewarray, ...</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단순-인터프리터"></a>단순 인터프리터<a class="hash-link" href="#단순-인터프리터" title="Direct link to heading">#</a></h3><p><a href="https://github.com/kittylyst/ocelotvm" target="_blank" rel="noopener noreferrer">단순한 인터프리터 예시, 오슬롯</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핫스팟에-특정한-내용"></a>핫스팟에 특정한 내용<a class="hash-link" href="#핫스팟에-특정한-내용" title="Direct link to heading">#</a></h3><p>핫스팟</p><ul><li>상용 제품급 JVM이며 완전한 구현체</li><li>인터프리팆드 모드에서 빠르게 실행될 수 있는 여러 고급 확장 기능을 가지고 있음</li></ul><p>참고 코드</p><ul><li><a href="https://github.com/kittylyst/ocelotvm" target="_blank" rel="noopener noreferrer">https://github.com/kittylyst/ocelotvm</a></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="aot와-jit-컴파일"></a>AOT와 JIT 컴파일<a class="hash-link" href="#aot와-jit-컴파일" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="aot-컴파일"></a>AOT 컴파일<a class="hash-link" href="#aot-컴파일" title="Direct link to heading">#</a></h3><ul><li>C/C++에서 사용하는 방법</li><li>프로그램 소스 코드를 외부 프로그램에 넣고 바로 실행 가능한 기계어를 뽑아내는 과정</li><li>소스코드를 AOT 컴파일하면 어떤 식으로 최적화할 기회는 단 한번입니다.</li><li>CPU 기능을 최대한 활용하지 못하는 경우가 많고 성능향상의 숙제가 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jit-컴파일"></a>JIT 컴파일<a class="hash-link" href="#jit-컴파일" title="Direct link to heading">#</a></h3><ul><li>런타임에 프로그램을 고도로 최적화한 기계어로 변환하는 기법</li><li>대부분의 상용 JVM이 이방식으로 작동됩니다</li><li>런타임 실행 정보를 수집해서 어느 부분이 자주 쓰이고, 어느 부분을 최적화해야 가장 효과가 좋은지 결정합니다.<ul><li>이를 프로파일 기반 최적화(PGO, Profile-guided optimization)</li></ul></li><li>JIT 서브시스템은 실행 프로그램과 VM리소스를 공유하므로 프로파일링 및 최적화 비용 및 성능 향상 기대치 사이의 균형을 맞춰야합니다.</li><li>바이트코드를 네이티브 코드로 컴파일하는 비용은 런타임에 지불됩니다.</li><li>핫스팟은 프로파일링 정보를 보관하지 않고 VM이 꺼지면 일체 폐기됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="aot-컴파일-vs-jit-컴파일"></a>AOT 컴파일 vs JIT 컴파일<a class="hash-link" href="#aot-컴파일-vs-jit-컴파일" title="Direct link to heading">#</a></h3><p>AOT 컴파일</p><ul><li>이해하기 쉬움</li><li>최적화 결정에 대한 정보가 없어서 런타임 정보를 포기하는 만큼 장점이 상쇄됨</li><li>특정 프로세서에서만 사용 가능한 실행 코드가 만들어짐</li><li>확장성에서 문제가 있습니다.</li></ul><p>JIT 컴파일</p><ul><li>새로 릴리즈마다 프로세스 기능에 최적화 코드를 추가할 수 있습니다.</li><li>신기능을 활용할 수 있습니다.</li></ul><blockquote><p>자바 9부터 핫스팟 VM은 JDK 코어 클래스를 대상으로 AOT 컴파일 옵션을 제공합니다.</p></blockquote><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핫스팟-jit-기초"></a>핫스팟 JIT 기초<a class="hash-link" href="#핫스팟-jit-기초" title="Direct link to heading">#</a></h2><ul><li>핫스팟의 기본 <strong>컴파일 단위</strong>는 전체 메서드입입니다.</li><li>한 메서드에 해당하는 바이트 코드는 한꺼번에 네이티브 코드로 컴파일됩니다.</li><li>핫스팟은 핫 루프를 온-스택 치환(OSR, on-stack replacement)라는 기법을 이용해 컴파일 기능을 제공합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="klass-워드-vtable-포인트-스위즐링"></a>klass 워드, vtable, 포인트 스위즐링<a class="hash-link" href="#klass-워드-vtable-포인트-스위즐링" title="Direct link to heading">#</a></h3><ul><li>핫스팟은 멀티스레드 C++ 애플리케이션</li><li>JIT 컴파일 서브시스템을 구성하는 스레드는 핫스팟 내부에서 가장 중요한 스레드</li></ul><blockquote><p>하나의 메서드를 단순 컴파일하는 과정</p></blockquote><p><img src="https://user-images.githubusercontent.com/42582516/124359196-e3187700-dc5e-11eb-9d9c-ba1f4a3c1c5b.png" alt="image"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jit-컴파일-로깅"></a>JIT 컴파일 로깅<a class="hash-link" href="#jit-컴파일-로깅" title="Direct link to heading">#</a></h3><p>성능 엔지니어라면 다음 JVM 스위치를 반드시 기억해야합니다.</p><p><code>-XX:+PrintCompilation</code></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핫스팟-내부의-컴파일러"></a>핫스팟 내부의 컴파일러<a class="hash-link" href="#핫스팟-내부의-컴파일러" title="Direct link to heading">#</a></h3><ul><li>핫스팟 JVM에는 C1, C2라는 두 JIT 컴파일러가 있습니다.</li><li>C1, C2 컴파일러 모두 핵심 측정값, 즉 메서드 호출 횟수에 따라 컴파일이 트리거링됩니다.</li><li>컴파일 프로세스는 가장 먼저 메서드의 내부 표현형을 생성한 다음 인터프리티드 단계에서 수집한 프로파일링 정보를 바탕으로 최적화 로직을 적용합니다.</li><li>같은 코드라도 C1과 C2가 생성한 내부 표현형은 전혀 다릅니다. (일반적으로 C1이 C2보다 컴파일 시간도 더 짧고 단순합니다.)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핫스팟의-단계별-컴파일"></a>핫스팟의 단계별 컴파일<a class="hash-link" href="#핫스팟의-단계별-컴파일" title="Direct link to heading">#</a></h3><p>자바 6부터 JVM은 단계별 컴파일 모드를 지원합니다.</p><ul><li>레벨 0 : 인터프리터</li><li>레벨 1 : C1 - 풀 최적화</li><li>레벨 2 : C1 - 호출 카운터 + 백엣지 카운터</li><li>레벨 3 : C1 - 풀 프로파일링</li><li>레벨 4 : C2</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="코드-캐시"></a>코드 캐시<a class="hash-link" href="#코드-캐시" title="Direct link to heading">#</a></h2><p>JIT 컴파일드 코드는 <strong>코드 캐시</strong>라는 메모리 영역에 저장됩니다. 이곳에는 인터프리터 부속 등 VM 자체 네이티브 코드가 들어있습니다.</p><p>코드 캐시는 <strong>미할당 영역</strong>과 <strong>프리 블록 연결 리스트</strong>를 담은 힙으로 구현됩니다.</p><p>다음의 경우, 네잍티브 코드가 코드 캐시에서 제거됩니다.</p><ul><li>역최적화될 때</li><li>다른 컴파일 버전으로 교체됐을 때</li><li>메서드를 지닌 클래스가 언로딩될 때</li></ul><blockquote><p>풀어설명하면, 추측해서 코드를 최적화했는데 그렇지 않은 경우에 최적화 이전의 형태로 되돌려놓는 행위입니다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단편화"></a>단편화<a class="hash-link" href="#단편화" title="Direct link to heading">#</a></h3><p>C1 컴파일러를 거친 중간 단계의 컴파일드 코드가 C2 컴파일로 치환된 후 삭제되는 일이 잦아지면 코드 캐시는 단편화되기 쉽습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="간단한-jit-튜닝법"></a>간단한 JIT 튜닝법<a class="hash-link" href="#간단한-jit-튜닝법" title="Direct link to heading">#</a></h2><p>코드 튜닝 시 애플리케이션이 JIT 컴파일을 십분 화룡하도록 만드는 것은 그리 어렵지 ㅇ낳습니다.</p><p>단순 JIT 튜닝의 대원칙은 간단합니다. 이는 <strong>컴파일을 원하는 메서드에게 아낌없이 리소스를 베풉니다.</strong></p><p>다음의 항목을 점검합니다.</p><ul><li>먼저 PrintCompilation 스위치를 켜고 애플리케이션을 실행합니다.</li><li>어느 메서드가 컴파일됐는지 기록된 로그를 수집합니다.</li><li>ReservedCodeCacheSize를 통해 코드 캐시를 늘립니다.</li><li>애플리케이션을 재실행합니다.</li><li>확장된 캐시에서 컴파일드 메서드를 살펴봅니다.</li></ul><p>이를 명심하면 두가지 사실을 알 수 있습니다.</p><ul><li>캐시 크기를 늘리면 컴파일드 메서드 규모가 유의미한 방향으로 커지는가.</li><li>주요 트랜잭션 경로상에 위치한 주요 메서드가 모두 컴파일되고 있는가.</li></ul><p>위 두개를 고려하면서 JIT를 튜닝하는 것이 중요합니다.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/optimizing-java/ch9.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-25T10:02:47.000Z" class="lastUpdatedDate_1WI_">7/25/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch8"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 8. GC 로깅, 모니터링, 튜닝, 툴</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch10"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">10. JIT 컴파일의 세계로 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#바이트코드-해석" class="table-of-contents__link">바이트코드 해석</a><ul><li><a href="#jvm-바이트코드-개요" class="table-of-contents__link">JVM 바이트코드 개요</a></li><li><a href="#단순-인터프리터" class="table-of-contents__link">단순 인터프리터</a></li><li><a href="#핫스팟에-특정한-내용" class="table-of-contents__link">핫스팟에 특정한 내용</a></li></ul></li><li><a href="#aot와-jit-컴파일" class="table-of-contents__link">AOT와 JIT 컴파일</a><ul><li><a href="#aot-컴파일" class="table-of-contents__link">AOT 컴파일</a></li><li><a href="#jit-컴파일" class="table-of-contents__link">JIT 컴파일</a></li><li><a href="#aot-컴파일-vs-jit-컴파일" class="table-of-contents__link">AOT 컴파일 vs JIT 컴파일</a></li></ul></li><li><a href="#핫스팟-jit-기초" class="table-of-contents__link">핫스팟 JIT 기초</a><ul><li><a href="#klass-워드-vtable-포인트-스위즐링" class="table-of-contents__link">klass 워드, vtable, 포인트 스위즐링</a></li><li><a href="#jit-컴파일-로깅" class="table-of-contents__link">JIT 컴파일 로깅</a></li><li><a href="#핫스팟-내부의-컴파일러" class="table-of-contents__link">핫스팟 내부의 컴파일러</a></li><li><a href="#핫스팟의-단계별-컴파일" class="table-of-contents__link">핫스팟의 단계별 컴파일</a></li></ul></li><li><a href="#코드-캐시" class="table-of-contents__link">코드 캐시</a><ul><li><a href="#단편화" class="table-of-contents__link">단편화</a></li></ul></li><li><a href="#간단한-jit-튜닝법" class="table-of-contents__link">간단한 JIT 튜닝법</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.a52dcdb0.js"></script>
<script src="/til/assets/js/main.8c5e1940.js"></script>
</body>
</html>