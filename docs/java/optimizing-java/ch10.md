# JIT 컴파일의 세계로

JVM JIT에 대해서 좀 더 자세하게 들어갑ㄴ디ㅏ.

## JITWatch

- [JITWatch](https://github.com/AdoptOpenJDK/jitwatch/)

다음의 기능을 제공합니다.

- 애플리케이션 실행 중에 핫스팟이 실제로 바이트코드에 무슨 일을 했는지 이해하는데 도움이 됩니다.
- 객관적인 비교에 필요한 측정값을 제공합니다.
- 실행 중인 자바 애플리케이션이 생성한 핫스팟 컴파일 상세 로그를 파싱/분석해서 그 결과를 자바 FX GUI 형태로 보여줍니다.
  - 다음 플래그를 추가해야합니다.
  - `-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompilation`

### 디버그 JVM과 hsdis

- 디버그 JVM을 통해서 JIT 서브시스템의 통계칭 등의 상세 디버깅 정보를 얻을 수 있습니다.

<br/>

## JIT 컴파일 개요

- VM이 데이터를 어떻게 수집하는지, 실행 프로그램에 어떤 최적화를 수행하는지 잘 알고 있어야 툴에서 컴파일드 코드를 보면서 올바르게 해석할 수 있습니다.
- 핫스팟은 PGO를 이용해 JIT 컴파일 여부를 판단합니다.

핫스팟 JIT 컴파일러는 다양한 최신 컴파일러 최적화 기법을 동원합니다.

- 인라이닝
- 루프 펼치기
- 탈출 분석
- 락 생략/확장
- 단일형 디스패치
- 인트린직
- 온-스택 치환

아래는 이를 설명합니다. 다만, 최적화 기법은 런타임 정보와 지원 여부에 따라 다소 달라집니다.

<br/>

## 인라이닝

**호출된 메서드의 호출한 지점에 복사하는 것입니다.**

메서드 호출 시 다음과 같은 오버헤드를 제거할 수 있습니다.

- 전달할 매개변수 세팅
- 호출할 메서드를 정확하게 룩업
- 새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성
- 새 메서드로 제어권 이송
- 호출부에 결과 반환 (결과값이 있는 경우)

인라인은 JIT 컴파일러가 제일 먼저 적용하는 최적화라서 **관문 최적화**라고도 합니다. 또한 다른 최적화 범위를 확장시키는 역할도 합니다.

- 탈출 분석, 죽은 코드 제거, 루프 펼치기, 락 생략

### 인라이닝 제어

때로는 VM 차원에서 인라이닝 서브시스템에 제한을 걸어야하는 경우도 있습니다.

- JIT 컴파일러가 메서드를 최적화하는데 소비하는 시간
- 생성된 네이티브 코드크기

핫스팟은 다음 항목을 따지면서 어떤 메서드를 인라이닝할 지 결정합니다.

- 인라이닝할 메서드의 바이트코드 크기
- 현재 호출 체인에서 인라이닝할 메서드의 깊이
- 메서드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 인라이닝 서브시스템 튜닝

| 스위치                  | 설명                                                                |
| ----------------------- | ------------------------------------------------------------------- |
| -XX:MaxInlineSize=<n>   | 메서드를 이 크기 이하로 인라이닝합니다.                             |
| -XX:FreqInlineSize=<n>  | 핫 메서드를 이 크기 이하로 인라이닝합니다.                          |
| -XX:InlineSmallCode=<n> | 최종 단계 컴파일이 이미 존재할 경우 메서드를 인라이닝하지 않습니다. |
| -XX:MaxInlineLevel=<n>  | 이 수준보다 더 깊이 호출 프레임을 인라이닝하지 않습니다.            |

<br/>

## 루프 펼치기

<br/>

## ...

<br/>

## 단형성 디스패치

<br/>

## 인트린직

<br/>

## 온-스택 치환

<br/>

## 세이프포인트 복습

<br/>

## 코어 라이브러리 메서드
