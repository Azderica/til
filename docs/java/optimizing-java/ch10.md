# JIT 컴파일의 세계로

JVM JIT에 대해서 좀 더 자세하게 들어갑ㄴ디ㅏ.

## JITWatch

- [JITWatch](https://github.com/AdoptOpenJDK/jitwatch/)

다음의 기능을 제공합니다.

- 애플리케이션 실행 중에 핫스팟이 실제로 바이트코드에 무슨 일을 했는지 이해하는데 도움이 됩니다.
- 객관적인 비교에 필요한 측정값을 제공합니다.
- 실행 중인 자바 애플리케이션이 생성한 핫스팟 컴파일 상세 로그를 파싱/분석해서 그 결과를 자바 FX GUI 형태로 보여줍니다.
  - 다음 플래그를 추가해야합니다.
  - `-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompilation`

### 디버그 JVM과 hsdis

- 디버그 JVM을 통해서 JIT 서브시스템의 통계칭 등의 상세 디버깅 정보를 얻을 수 있습니다.

<br/>

## JIT 컴파일 개요

- VM이 데이터를 어떻게 수집하는지, 실행 프로그램에 어떤 최적화를 수행하는지 잘 알고 있어야 툴에서 컴파일드 코드를 보면서 올바르게 해석할 수 있습니다.
- 핫스팟은 PGO를 이용해 JIT 컴파일 여부를 판단합니다.

핫스팟 JIT 컴파일러는 다양한 최신 컴파일러 최적화 기법을 동원합니다.

- 인라이닝
- 루프 펼치기
- 탈출 분석
- 락 생략/확장
- 단일형 디스패치
- 인트린직
- 온-스택 치환

아래는 이를 설명합니다. 다만, 최적화 기법은 런타임 정보와 지원 여부에 따라 다소 달라집니다.

<br/>

## 인라이닝

**호출된 메서드의 호출한 지점에 복사하는 것입니다.**

메서드 호출 시 다음과 같은 오버헤드를 제거할 수 있습니다.

- 전달할 매개변수 세팅
- 호출할 메서드를 정확하게 룩업
- 새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성
- 새 메서드로 제어권 이송
- 호출부에 결과 반환 (결과값이 있는 경우)

인라인은 JIT 컴파일러가 제일 먼저 적용하는 최적화라서 **관문 최적화**라고도 합니다. 또한 다른 최적화 범위를 확장시키는 역할도 합니다.

- 탈출 분석, 죽은 코드 제거, 루프 펼치기, 락 생략

### 인라이닝 제어

때로는 VM 차원에서 인라이닝 서브시스템에 제한을 걸어야하는 경우도 있습니다.

- JIT 컴파일러가 메서드를 최적화하는데 소비하는 시간
- 생성된 네이티브 코드크기

핫스팟은 다음 항목을 따지면서 어떤 메서드를 인라이닝할 지 결정합니다.

- 인라이닝할 메서드의 바이트코드 크기
- 현재 호출 체인에서 인라이닝할 메서드의 깊이
- 메서드를 컴파일한 버전이 코드 캐시에서 차지하는 공간

### 인라이닝 서브시스템 튜닝

| 스위치                    | 설명                                                                |
| ------------------------- | ------------------------------------------------------------------- |
| `-XX:MaxInlineSize=<n>`   | 메서드를 이 크기 이하로 인라이닝합니다.                             |
| `-XX:FreqInlineSize=<n>`  | 핫 메서드를 이 크기 이하로 인라이닝합니다.                          |
| `-XX:InlineSmallCode=<n>` | 최종 단계 컴파일이 이미 존재할 경우 메서드를 인라이닝하지 않습니다. |
| `-XX:MaxInlineLevel=<n>`  | 이 수준보다 더 깊이 호출 프레임을 인라이닝하지 않습니다.            |

<br/>

## 루프 펼치기

루프 내부의 메서드 호출을 전부 인라이닝하면, 컴파일러는 루프를 한번 순회할 때마다 비용과 크기를 더 분명하게 알 수 있습니다.

백브랜치(back branch)가 일어나면 그때마다 CPU는 유입된 명령어 파이프라인을 덤프하기 때문에 성능상 바람직하지 않습니다. 일반적으로 루프 바디가 짧을수록 백 브랜치 비용은 상대적으로 높기 때문에 다음의 기준으로 루프 펼치기 여부를 결정합니다.

- 루프 카운터 변수 유형(대부분 객체 아닌 int나 long형 사용)
- 루프 보폭(loop stride, 한번 순회할 때마다 루프 카운터 값이 얼마나 바뀌는 지)
- 루프 내부의 탈출 지점 개수(return 또는 break)

다음과 같이 벤치마킹 할 수 있습니다.

```java
package optjava.jmh;

import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Thread)
public class LoopUnrollingCounter {
  private static Final int MAX = 1_000_000;
  private long[] data = new long[MAX];

  @Setup
  public void createData() {
    java.util.Random random = new java.util.Random();
    for (int i = 0; i < MAX; i++) {
      data[i] = random.nextLong();
    }
  }

  @Benchmark
  public long intStride1() {
    long sum = 0;
    for (int i = 0; i < MAX; i++) {
      sum += data[i];
    }
    return sum;
  }

  @Benchmark
  public long longStride1() {
    long sum = 0;
    for (long l = 0; l < MAX; l++) {
      sum += data[(int) l];
    }
    return sum;
  }
}
```

벤치마크 결과

| Benchmark                            | Mode  | Cnt | Score      | Error | Unites |
| ------------------------------------ | ----- | --- | ---------- | ----- | ------ |
| UnitsLoopUnrollingCounter.intStride1 | thrpt | 200 | 2423.818 ± | 2.547 | ops/s  |
| LoopUnrollingCounter.longStride1     | thrpt | 200 | 1469.833 ± | 0.721 | ops/s  |

### 루프 펼치기 정리

핫스팟은 다양한 최적화 기법으로 루프 펼치기를 합니다.

- 카운터가 int, short, char 형일 경우 루프를 최적화합니다.
- 루프 바디를 펼치고 세이프포인트 폴을 제거합니다.
- 루프를 펼치면 백 브랜치 횟수가 줄고, 그만큼 분기 예측 비용이 적게 듭니다.
- 세이프포인트 폴을 제거하면 루프를 순회할 때마다 하는 일이 줄어듭니다.

<br/>

## ...

<br/>

## 단형성 디스패치

<br/>

## 인트린직

<br/>

## 온-스택 치환

<br/>

## 세이프포인트 복습

<br/>

## 코어 라이브러리 메서드
