<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">10. JIT 컴파일의 세계로 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/optimizing-java/ch10"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="10. JIT 컴파일의 세계로 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="JVM JIT에 대해서 좀 더 자세하게 들어갑니다."><meta data-react-helmet="true" property="og:description" content="JVM JIT에 대해서 좀 더 자세하게 들어갑니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch10"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch10" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch10" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.814d06c1.js" as="script">
<link rel="preload" href="/til/assets/js/main.0e2ed3d1.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">아파치 카프카 애플리케이션 프로그래밍 with 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch1">1. 들어가며</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch2">2. 카프카 빠르게 시작해보기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch3">3. 카프카 기본 개념 설명</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch11">11. 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch12">12. 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch13">13. 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch14">14. 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch15">15. 디자인 패턴과 프레임 워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch16">부록 A. 계약에 의한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch17">부록 B. 타입 계층의 구현</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch18">부록 C. 동적인 협력, 정적인 코드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">react</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">따라하며 배우는 리액트 A-Z</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch1">따라하는 리액트, 리액트란?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch2">간단한 To-Do 앱 만들며 리액트 익히기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch3">To-Do 앱 최적화하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch4">4. Netflix 앱 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch5">5. 넷플릭스 앱 모달 및 이미지 불러오기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch6">6. React TDD 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch8">8. Nextjs and Typescript</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch9">9. React Version</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch10">10. Redux</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch11">도커로 리액트 실행하기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">스프링 시큐리티(강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-security/ch1">1부 스프링 시큐리티: 폼 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-security/ch2">2부 스프링 시큐리티: 아키텍처</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">10. JIT 컴파일의 세계로</h1></header><div class="markdown"><p>JVM JIT에 대해서 좀 더 자세하게 들어갑니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jitwatch"></a>JITWatch<a class="hash-link" href="#jitwatch" title="Direct link to heading">#</a></h2><ul><li><a href="https://github.com/AdoptOpenJDK/jitwatch/" target="_blank" rel="noopener noreferrer">JITWatch</a></li></ul><p>다음의 기능을 제공합니다.</p><ul><li>애플리케이션 실행 중에 핫스팟이 실제로 바이트코드에 무슨 일을 했는지 이해하는데 도움이 됩니다.</li><li>객관적인 비교에 필요한 측정값을 제공합니다.</li><li>실행 중인 자바 애플리케이션이 생성한 핫스팟 컴파일 상세 로그를 파싱/분석해서 그 결과를 자바 FX GUI 형태로 보여줍니다.<ul><li>다음 플래그를 추가해야합니다.</li><li><code>-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompilation</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="디버그-jvm과-hsdis"></a>디버그 JVM과 hsdis<a class="hash-link" href="#디버그-jvm과-hsdis" title="Direct link to heading">#</a></h3><ul><li>디버그 JVM을 통해서 JIT 서브시스템의 통계칭 등의 상세 디버깅 정보를 얻을 수 있습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jit-컴파일-개요"></a>JIT 컴파일 개요<a class="hash-link" href="#jit-컴파일-개요" title="Direct link to heading">#</a></h2><ul><li>VM이 데이터를 어떻게 수집하는지, 실행 프로그램에 어떤 최적화를 수행하는지 잘 알고 있어야 툴에서 컴파일드 코드를 보면서 올바르게 해석할 수 있습니다.</li><li>핫스팟은 PGO를 이용해 JIT 컴파일 여부를 판단합니다.</li></ul><p>핫스팟 JIT 컴파일러는 다양한 최신 컴파일러 최적화 기법을 동원합니다.</p><ul><li>인라이닝</li><li>루프 펼치기</li><li>탈출 분석</li><li>락 생략/확장</li><li>단일형 디스패치</li><li>인트린직</li><li>온-스택 치환</li></ul><p>아래는 이를 설명합니다. 다만, 최적화 기법은 런타임 정보와 지원 여부에 따라 다소 달라집니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인라이닝"></a>인라이닝<a class="hash-link" href="#인라이닝" title="Direct link to heading">#</a></h2><p><strong>호출된 메서드의 호출한 지점에 복사하는 것입니다.</strong></p><p>메서드 호출 시 다음과 같은 오버헤드를 제거할 수 있습니다.</p><ul><li>전달할 매개변수 세팅</li><li>호출할 메서드를 정확하게 룩업</li><li>새 호출 프레임에 맞는 런타임 자료 구조(지역 변수 및 평가 스택 등) 생성</li><li>새 메서드로 제어권 이송</li><li>호출부에 결과 반환 (결과값이 있는 경우)</li></ul><p>인라인은 JIT 컴파일러가 제일 먼저 적용하는 최적화라서 <strong>관문 최적화</strong>라고도 합니다. 또한 다른 최적화 범위를 확장시키는 역할도 합니다.</p><ul><li>탈출 분석, 죽은 코드 제거, 루프 펼치기, 락 생략</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인라이닝-제어"></a>인라이닝 제어<a class="hash-link" href="#인라이닝-제어" title="Direct link to heading">#</a></h3><p>때로는 VM 차원에서 인라이닝 서브시스템에 제한을 걸어야하는 경우도 있습니다.</p><ul><li>JIT 컴파일러가 메서드를 최적화하는데 소비하는 시간</li><li>생성된 네이티브 코드크기</li></ul><p>핫스팟은 다음 항목을 따지면서 어떤 메서드를 인라이닝할 지 결정합니다.</p><ul><li>인라이닝할 메서드의 바이트코드 크기</li><li>현재 호출 체인에서 인라이닝할 메서드의 깊이</li><li>메서드를 컴파일한 버전이 코드 캐시에서 차지하는 공간</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인라이닝-서브시스템-튜닝"></a>인라이닝 서브시스템 튜닝<a class="hash-link" href="#인라이닝-서브시스템-튜닝" title="Direct link to heading">#</a></h3><table><thead><tr><th>스위치</th><th>설명</th></tr></thead><tbody><tr><td><code>-XX:MaxInlineSize=&lt;n&gt;</code></td><td>메서드를 이 크기 이하로 인라이닝합니다.</td></tr><tr><td><code>-XX:FreqInlineSize=&lt;n&gt;</code></td><td>핫 메서드를 이 크기 이하로 인라이닝합니다.</td></tr><tr><td><code>-XX:InlineSmallCode=&lt;n&gt;</code></td><td>최종 단계 컴파일이 이미 존재할 경우 메서드를 인라이닝하지 않습니다.</td></tr><tr><td><code>-XX:MaxInlineLevel=&lt;n&gt;</code></td><td>이 수준보다 더 깊이 호출 프레임을 인라이닝하지 않습니다.</td></tr></tbody></table><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="루프-펼치기"></a>루프 펼치기<a class="hash-link" href="#루프-펼치기" title="Direct link to heading">#</a></h2><p>루프 내부의 메서드 호출을 전부 인라이닝하면, 컴파일러는 루프를 한번 순회할 때마다 비용과 크기를 더 분명하게 알 수 있습니다.</p><p>백브랜치(back branch)가 일어나면 그때마다 CPU는 유입된 명령어 파이프라인을 덤프하기 때문에 성능상 바람직하지 않습니다. 일반적으로 루프 바디가 짧을수록 백 브랜치 비용은 상대적으로 높기 때문에 다음의 기준으로 루프 펼치기 여부를 결정합니다.</p><ul><li>루프 카운터 변수 유형(대부분 객체 아닌 int나 long형 사용)</li><li>루프 보폭(loop stride, 한번 순회할 때마다 루프 카운터 값이 얼마나 바뀌는 지)</li><li>루프 내부의 탈출 지점 개수(return 또는 break)</li></ul><p>다음과 같이 벤치마킹 할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">package optjava.jmh;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import org.openjdk.jmh.annotations.*;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">import java.util.concurrent.TimeUnit;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@BenchmarkMode(Mode.Throughput)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@OutputTimeUnit(TimeUnit.SECONDS)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@State(Scope.Thread)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class LoopUnrollingCounter {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static Final int MAX = 1_000_000;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private long[] data = new long[MAX];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Setup</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void createData() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    java.util.Random random = new java.util.Random();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; MAX; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      data[i] = random.nextLong();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Benchmark</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public long intStride1() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    long sum = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; MAX; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sum += data[i];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return sum;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Benchmark</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public long longStride1() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    long sum = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (long l = 0; l &lt; MAX; l++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      sum += data[(int) l];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return sum;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>벤치마크 결과</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score</th><th>Error</th><th>Unites</th></tr></thead><tbody><tr><td>UnitsLoopUnrollingCounter.intStride1</td><td>thrpt</td><td>200</td><td>2423.818 ±</td><td>2.547</td><td>ops/s</td></tr><tr><td>LoopUnrollingCounter.longStride1</td><td>thrpt</td><td>200</td><td>1469.833 ±</td><td>0.721</td><td>ops/s</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="루프-펼치기-정리"></a>루프 펼치기 정리<a class="hash-link" href="#루프-펼치기-정리" title="Direct link to heading">#</a></h3><p>핫스팟은 다양한 최적화 기법으로 루프 펼치기를 합니다.</p><ul><li>카운터가 int, short, char 형일 경우 루프를 최적화합니다.</li><li>루프 바디를 펼치고 세이프포인트 폴을 제거합니다.</li><li>루프를 펼치면 백 브랜치 횟수가 줄고, 그만큼 분기 예측 비용이 적게 듭니다.</li><li>세이프포인트 폴을 제거하면 루프를 순회할 때마다 하는 일이 줄어듭니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="탈출-분석"></a>탈출 분석<a class="hash-link" href="#탈출-분석" title="Direct link to heading">#</a></h2><p>핫스팟은 어떤 메서드가 내부에서 수행한 작업을 그 메서드 경계 밖에서도 볼 수 있는지, 또는 부수 효과를 유발하지 않는지 범위 기반 분석을 통해서 판별합니다. 이러한 기법을 <strong>탈출 분석</strong>이라고 하며 메서드 내부에서 할당된 객체를 메서드 범위 밖에서 바라볼 수 있는지를 알아보는 용도로 사용됩니다.</p><p>일반적으로 세가지 유형으로 분류됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c++"><div tabindex="0" class="prism-code language-c++ codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">typedef enum {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 객체가 메서드/스레드를 탈출하지 않고</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 호출 인수로 전달되지 않으며,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 스칼라로 대체 가능하다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  NoEscape = 1,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 객체가 메서드/스레드를 탈출하지 않지만</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 호출 인수로 전달되거나 레퍼런스로 참조되며,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 호출 도중에는 탈출하지 않는다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ArgEscape = 2,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 객체가 메서드/스레드를 탈출한다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  GlobalEscape = 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="힙-할당-제거"></a>힙 할당 제거<a class="hash-link" href="#힙-할당-제거" title="Direct link to heading">#</a></h3><p>핫스팟의 탈출 분석 최적화는 개발자가 객체 할당률을 신경 쓰지 않고도 자바 코드를 자연스레 작성할 수 있도록 설계되었습니다.</p><p>스칼라 치환(scalar replacement)이라는 최적화를 적용해 객체 필드를 마치 처음부터 객체 필드가 아닌 지역 변수였던 것처럼 스칼라 값으로 바꿉니다. 그 후 레지스터 할당기(register allocator)라는 핫스팟 컴포넌트에 의해 CPU 레지스터 속으로 배치합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="락과-탈출-분석"></a>락과 탈출 분석<a class="hash-link" href="#락과-탈출-분석" title="Direct link to heading">#</a></h3><p>핫스팟은 탈출 분석 및 관련 기법을 통해서 락 성능도 최적화합니다.</p><ul><li>비탈출 객체에 있는 락은 제거합니다. (락 생략)</li><li>같은 락을 공유한, 락이 걸린 연속된 영역은 병합합니다. (락 확장)</li><li>락을 해제하지 않고 같은 락을 반복 획득한 블록을 찾아냅니다. (중첩 락)</li></ul><p>상세 내용 : <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.14" target="_blank" rel="noopener noreferrer">JVM 명세서</a></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="탈출-분석의-한계"></a>탈출 분석의 한계<a class="hash-link" href="#탈출-분석의-한계" title="Direct link to heading">#</a></h3><p>탈출 분석 역시 다른 최적화 기법들처럼 트레이드오프가 있습니다. 힙이 아니라도 다른 어딘가에는 할당을 해야 하는데, CPU 레지스터나 스택 공간은 상대적으로 희소한 리소스입니다. 또 기본적으로 원소가 64개 이상인 배열은 핫스팟에서 탈출 분석의 혜택을 볼 수 없습니다. 이 개수 제한은 다음 VM 스위치로 조정합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단형성-디스패치"></a>단형성 디스패치<a class="hash-link" href="#단형성-디스패치" title="Direct link to heading">#</a></h2><p>핫스팟 C2 컴파일러가 수행하는 추측성 최적화는 대부분 경험적 연구 결과를 토대로 합니다. <strong>단형성 디스패치 기법</strong>도 그런 부류 중 하나입니다.</p><p>즉, 어떤 객체에 있는 메서드를 호출할 때, 그 메서드를 최초로 호출한 객체의 런타임 타입을 알아내면 그 이후의 모든 호출도 동일한 타입일 가능성이 큽니다. 이 추측을 통해서 호출부의 메서드 호출을 최적화할 수 있습니다.</p><p>일반 애플리케이션에서는 대부분이 단형적 호출입니다. 다만. <strong>이형성 디스패치</strong>나 <strong>다형성</strong>도 지원합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인트린직"></a>인트린직<a class="hash-link" href="#인트린직" title="Direct link to heading">#</a></h2><p>인트린직(intrinsics)은 JIT 서브시스템이 동적 생성하기 이전에 JVM이 이미 알고 있는 고도로 튜닝된 네이티브 메서드 구현체를 가리키는 용어입니다. 주로 OS나 CPU 아키텍처의 특정 기능을 응용하는, 성능이 필수적인 코어 메서드에서 쓰입니다. 따라서, 플랫폼에 따라 지원되는 경우도 있고 안되는 경우도 있습니다.</p><p>아래는 많이 쓰이는 인트린직입니다.</p><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>java.lang.System.arraycopy()</code></td><td>CPU의 벡터 지원으로 배열을 빠르게 복사합니다.</td></tr><tr><td><code>java.lang.System.currentTimeMillis()</code></td><td>대부분 OS가 제공하는 구현체가 빠릅니다.</td></tr><tr><td><code>java.lang.Math.min</code></td><td>일부 CPU에서 분기 없이 연산 가능합니다.</td></tr><tr><td><code>기타 java.lang.Math 메서드</code></td><td>일부 CPU에서 직접 명령어를 지원합니다.</td></tr><tr><td><code>암호화 함수(Ex. AES)</code></td><td>하드웨어로 가속하면 성능이 매우 좋아집니다.</td></tr></tbody></table><p>OpenJDK 핫스팟 소스 코드에서 확장자가 <code>.ad</code>(architecture dependent)인 파일이 바로 인트린직 템플릿입니다.</p><p>인트린직의 핵심 중 하나는 정말 <strong>자주 쓰이는 작업에 한해서만 성능에 큰 영향</strong>을 미칠 수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="온-스택-치환"></a>온-스택 치환<a class="hash-link" href="#온-스택-치환" title="Direct link to heading">#</a></h2><p>컴파일을 일으킬 정도로 호출 빈도가 높지는 않지만 메서드 내부에 핫 루프가 포함된 경우가 있습니다. 대표적인 예시로 <code>main()</code> 메서드입니다.</p><p>핫스팟은 이런 코드를 <strong>온-스택 치환(OSR)</strong>을 이용해서 최적화합니다. 인터프리터가 루프 백 브랜치 횟수를 세어보고 특정 한계치를 초과하면 루프를 컴파일한 후 치촨해서 실행합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="세이프포인트-복습"></a>세이프포인트 복습<a class="hash-link" href="#세이프포인트-복습" title="Direct link to heading">#</a></h2><p>JVM에 세이프포인트가 걸리는 조건을 종합 정리해보면 다음과 같습니다.</p><ul><li>메서드를 역최적화</li><li>힙 덤프를 생성</li><li>바이어스 락을 취소</li><li>클래스를 재정의</li></ul><p>핫스팟에서는 다음 지점에 세이프포인트 체크 코드를 넣습니다.</p><ul><li>루프 백 브랜치 지점</li><li>메서드 반환 지점</li></ul><p>따라서 경우에 따라 스레드가 세이프포인터에 도달하려면 어느 정도 시간이 소요될 수 있습니다. 또한 컴파일러는 세이프포인트를 폴링하면서 체크하는 비용을 감수할지, 다른 스레드도 모두 세이프포인테 닿을 때까지 대기하는 긴 세이프포인트를 회피할 지에 대해 고민하게 됩니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="코어-라이브러리-메서드"></a>코어 라이브러리 메서드<a class="hash-link" href="#코어-라이브러리-메서드" title="Direct link to heading">#</a></h2><p>JDK 코어 라이브러리 크기가 JIT 컴파일에 어떤 영향을 주는지 살펴봐야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="인라이닝하기-적합한-메서드-크기-상한"></a>인라이닝하기 적합한 메서드 크기 상한<a class="hash-link" href="#인라이닝하기-적합한-메서드-크기-상한" title="Direct link to heading">#</a></h3><p>인라이닝 여부는 메서드의 바이트 코드 크기로 결정되므로, 클래스 파일을 정적 분석하면 인라이닝을 하기에 지나치게 큰 메서드를 솎아낼 수 있습니다.</p><ul><li>도메인에 특정한 메서드로 성능 개선합니다.</li><li>메서드를 작게하는 것도 인라이닝 가짓수를 늘여서 장점을 가집니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컴파일하기-적합한-메서드-크기-상한"></a>컴파일하기 적합한 메서드 크기 상한<a class="hash-link" href="#컴파일하기-적합한-메서드-크기-상한" title="Direct link to heading">#</a></h3><p>핫스팟은 메서드 크기가 어느 이상 초과하면 컴파일되지 않는 한계치(8000바이트)가 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="마무리"></a>마무리<a class="hash-link" href="#마무리" title="Direct link to heading">#</a></h2><p><code>-XX:+PrintCompilation</code> 플래그와 9장에서 소개한 기법들을 잘 활용하면 개별 메서드마다 정말 최적화됐는지 여부를 확인할 수 있습니다.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/optimizing-java/ch10.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-10-23T12:03:49.000Z" class="lastUpdatedDate_1WI_">10/23/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch9"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 9. JVM의 코드 실행</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch11"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">11. 자바 언어의 성능 향상 기법 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#jitwatch" class="table-of-contents__link">JITWatch</a><ul><li><a href="#디버그-jvm과-hsdis" class="table-of-contents__link">디버그 JVM과 hsdis</a></li></ul></li><li><a href="#jit-컴파일-개요" class="table-of-contents__link">JIT 컴파일 개요</a></li><li><a href="#인라이닝" class="table-of-contents__link">인라이닝</a><ul><li><a href="#인라이닝-제어" class="table-of-contents__link">인라이닝 제어</a></li><li><a href="#인라이닝-서브시스템-튜닝" class="table-of-contents__link">인라이닝 서브시스템 튜닝</a></li></ul></li><li><a href="#루프-펼치기" class="table-of-contents__link">루프 펼치기</a><ul><li><a href="#루프-펼치기-정리" class="table-of-contents__link">루프 펼치기 정리</a></li></ul></li><li><a href="#탈출-분석" class="table-of-contents__link">탈출 분석</a><ul><li><a href="#힙-할당-제거" class="table-of-contents__link">힙 할당 제거</a></li><li><a href="#락과-탈출-분석" class="table-of-contents__link">락과 탈출 분석</a></li><li><a href="#탈출-분석의-한계" class="table-of-contents__link">탈출 분석의 한계</a></li></ul></li><li><a href="#단형성-디스패치" class="table-of-contents__link">단형성 디스패치</a></li><li><a href="#인트린직" class="table-of-contents__link">인트린직</a></li><li><a href="#온-스택-치환" class="table-of-contents__link">온-스택 치환</a></li><li><a href="#세이프포인트-복습" class="table-of-contents__link">세이프포인트 복습</a></li><li><a href="#코어-라이브러리-메서드" class="table-of-contents__link">코어 라이브러리 메서드</a><ul><li><a href="#인라이닝하기-적합한-메서드-크기-상한" class="table-of-contents__link">인라이닝하기 적합한 메서드 크기 상한</a></li><li><a href="#컴파일하기-적합한-메서드-크기-상한" class="table-of-contents__link">컴파일하기 적합한 메서드 크기 상한</a></li></ul></li><li><a href="#마무리" class="table-of-contents__link">마무리</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.814d06c1.js"></script>
<script src="/til/assets/js/main.0e2ed3d1.js"></script>
</body>
</html>