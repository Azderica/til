<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">3. 하드웨어와 운영체제 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/optimizing-java/ch3"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="3. 하드웨어와 운영체제 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="자바 성능을 진지하게 높일려면, 자바 플랫폼의 근간 원리와 기술에 대해 알아야합니다."><meta data-react-helmet="true" property="og:description" content="자바 성능을 진지하게 높일려면, 자바 플랫폼의 근간 원리와 기술에 대해 알아야합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch3"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch3" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch3" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.e312a594.js" as="script">
<link rel="preload" href="/til/assets/js/main.a50accfc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">3. 하드웨어와 운영체제</h1></header><div class="markdown"><p>자바 성능을 진지하게 높일려면, 자바 플랫폼의 근간 원리와 기술에 대해 알아야합니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메모리"></a>메모리<a class="hash-link" href="#메모리" title="Direct link to heading">#</a></h2><p>무어의 법칙에 따라 개수가 급증한 트랜지스터는 처음에는 클론 속도를 높이는데 쓰였습니다. 그러나 클론 속도가 증가하다 보니 프로세스 코어의 데이터 수요를 메인 메모리가 맞추기 힘들어졌습니다. 즉, 클론 속도가 올라가도 데이터가 도착할 때까지 CPU가 기다리게 됩니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메모리-캐시"></a>메모리 캐시<a class="hash-link" href="#메모리-캐시" title="Direct link to heading">#</a></h3><p>이를 위해서 CPU 캐시가 등장했습니다. 레지스터보다 빠르고 메인 메모리보다 빠르며, 자주 액세스하는 메모리 위치는 CPU 캐시에 보관하자는 아이디어로 등장했습니다. 일반적으로 CPU와 가까운 캐시 순으로 L1, L2, L3 등이 있으며 L1과 L2는 전용 프라이빗 캐시입니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/119114712-5a080080-ba61-11eb-8582-56e9cccdf254.png" alt="image"></p><p>이를 통해서 프로세서 처리율이 높아졌으나, 캐시한 데이터를 어떻게 메모리에 다시 써야 할지 결정해야합니다. 이 문제를 해결하기 위해서 <code>캐시 일관성 프로토콜(cache consistency protocol)</code> 라는 방법으로 해결합니다.</p><p>프로세서의 가장 저수준에서 MESI 프로토콜을 사용하는데 이 MESI 프로토콜은 캐시 라인 상태를 네가지로 정리합니다.</p><ul><li>Modified(수정): 데이터가 수정된 상태</li><li>Exclusive(배타): 이 캐시에만 존재하고 메인 메모리 내용과 동일한 상태</li><li>Shared(공유): 둘 이상의 캐시에 데이터가 들어 있고 메모리 내용과 동일한 상태</li><li>Invalid(무효): 다른 프로세스가 데이터를 수정하여 무효한 상태</li></ul><p>정리하자면, 멀리 프로세서는 동시에 공유 상태로 존재할 수 있습니다. 하지만 어느 한 프로세서가 배타나 수정 상태로 바뀌면 다른 프로세서는 강제로 무효상태가 됩니다.</p><p>이러한 캐시 스킬을 통해서, 데이터를 신속하게 메모리에서 쓰고 읽을 수 있게 되었습니다.</p><p>캐시 하드웨어의 작동 원리 코드를 살펴볼 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Caching {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Final int ARR_SIZE = 2 * 1024 * 1024;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Final int[] testData = new int[ARR_SIZE];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void run() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.err.println(&quot;Start: &quot;+ System.currentTimeMillis());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; 15_000; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      touchEveryLine();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      touchEveryItem();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.err.println(&quot;Warmup Finished: &quot;+ System.currentTimeMillis());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.err.println(&quot;Item Line&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; 100; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      long t0 = System.nanoTime();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      touchEveryLine();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      long t1 = System.nanoTime();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      touchEveryItem();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      long t2 = System.nanoTime();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      long elItem = t2 - t1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      long elLine = t1 - t0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      double diff = elItem - elLine;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      System.err.println(elItem + &quot; &quot; + elLine +&quot; &quot;+ (100 \* diff / elLine));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void touchEveryItem() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; testData.length; i++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      testData[i]++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void touchEveryLine() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; testData.length; i += 16)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      testData[i]++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Caching c = new Caching();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    c.run();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위 코드를 실행하면, <code>touchEveryItem()</code> 메서드가 <code>touchEveryLine()</code> 메서드보다 더 많은 일을 할 것 같지만, 소요시간은 비슷합니다. 그 이유는 메모리 버스를 예열시키는 부분이 가장 큰 영향이 미쳐서 그렇습니다.</p><p>즉, 자바 성능을 논할 때는 객체 할당률에 따른 애플리케이션 민감도가 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="최신-프로세서의-특성"></a>최신 프로세서의 특성<a class="hash-link" href="#최신-프로세서의-특성" title="Direct link to heading">#</a></h2><p>메모리 캐시가 트랜지스터를 활용하는 가장 큰 분야이지만 이외에도 여러 기술들이 나왔습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="변환-색인-버퍼tlb"></a>변환 색인 버퍼(TLB)<a class="hash-link" href="#변환-색인-버퍼tlb" title="Direct link to heading">#</a></h3><p>여러 캐시에서 중요하게 사용하는 장치입니다. <strong>가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 수행</strong>합니다. 이 덕분에 가상 주소를 참조해 물리 주소에 액세스하는 빈번한 작업 속도가 매우 빨라집니다. 현재의 칩에서는 TLB는 거의 필수입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="분기-예윽과-추측-실행"></a>분기 예윽과 추측 실행<a class="hash-link" href="#분기-예윽과-추측-실행" title="Direct link to heading">#</a></h3><p>분기 예측은 최신 프로세서의 고급 기법 중 하나이며 <strong>프로세서가 조건 분기하는 기준 값을 평가하느라 대기하는 현상을 방지합니다.</strong> 요즘의 프로세서는 다단계 명령 파이프라인을 통해서 1사이클을 여러 개발 단계로 나누어 실행합니다.</p><p>조건문을 다 평가하기 전까지 분기 이후 명령을 알수 없는 것이 문제가 되는데, 프로게세서는 잉여 트랜지스터를 사용해 발생 가능성이 큰 브랜치를 미리 결정하는 휴리스틱을 형성합니다. 추측이 맞을 때는 CPU는 다음 작업을 진행하고, 틀리면 부분적으로 실행한 명령을 모두 폐기하느 방식으로 갑니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="하드웨어-메모리-모델"></a>하드웨어 메모리 모델<a class="hash-link" href="#하드웨어-메모리-모델" title="Direct link to heading">#</a></h3><p>서로 다른 CPU가 일관되게 동일한 메모리 주소를 액세스 할 수 있을까라는 질문을 해결하기 위해서 나왔습니다.</p><p>단계를 최적화하기 위해 코드 조건에 따라 순서를 바꿀 수 있습니다. JVM은 프로세서 타입별로 상이한 메모리 액세스 일관성을 고려해서 명시적인 약한 모델로 설계되었습니다. 따라서 코드가 제대로 작동하기 위해서는 락과 volatile을 정확하게 알고 사용해야합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="운영체제"></a>운영체제<a class="hash-link" href="#운영체제" title="Direct link to heading">#</a></h2><p>OS의 주 임무는 여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 일입니다. 한정된 리소스를 골고루 나눠줄 기능이 있어야합니다.</p><p>메모리 관리 유닛(MMU, Memory Management Unit)을 통해 가상 주소 방식과 페이지 테이블은 메모리 액세스 제어의 핵심으로 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손하지 못하게 합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스케줄러"></a>스케줄러<a class="hash-link" href="#스케줄러" title="Direct link to heading">#</a></h3><p>프로세스 스케줄러는 실행 큐를 통해서 CPU 액세스를 통제합니다. 스케줄러는 인터럽트에 응답하고 CPU 코어 액세스를 관리합니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/119247274-0f9e9500-bbc3-11eb-98c6-f305b369d35f.png" alt="스레드 생명주기"></p><p>스케줄러의 움직임을 확인하는 가장 쉬운 방법은 OS가 스케줄링 과정에서 발생시킨 오버헤드를 관측하는 것입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">long start = System.currentTimeMillis();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (int i = 0; i &lt; 1_000; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Thread.sleep(1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">long end = System.currentTimeMillis();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(&quot;Millis elapsed: &quot; + (end - start) / 4000.0);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이 코드는 OS마다 결과가 다릅니다. Mac OS 제 pc 기준으로는 0.3075 밀리초가 나옵니다.</p><p>타이밍은 성능 측정, 프로세스 스케줄링, 기타 애플리케이션 스택의 다양한 파트에서 아주 중요ㅕ합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="시간-문제"></a>시간 문제<a class="hash-link" href="#시간-문제" title="Direct link to heading">#</a></h3><p>OS는 저마다 다르게 동작합니다. 그래서 <code>System.currentTimeMillis()</code> 와 같은 메서드도 OS가 제공하는 기능에 의존하기 때문에 다릅니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="컨텍스트-교환"></a>컨텍스트 교환<a class="hash-link" href="#컨텍스트-교환" title="Direct link to heading">#</a></h3><p>컨첵스트 교환은 OS 스케줄러가 현재 실행 중인 스레드/테스크를 없애고 대기 중인 다른 스레드/테스크로 대체하는 프로세스입니다. 다만 이 경우에 유저 모드에서 커널 모드로 바뀌기 때문(<code>mode switch</code>)에 비싼작업입니다. 특히 커널공간와 유저공간이 바뀌게 된다면, 다른 캐시를 어쩔 수 없이 강제로 비워야합니다.커널 모드로 컨텍스트가 교환되면 TLB를 비롯한 다른 캐시까지도 무효화가 됩니다.</p><p>이러한 문제를 해결하기 위해서 리눅스는 가상 동적 공유 객체(vDSO, virtual Dynamically Shared Object)라는 장치를 제공합니다. 이는 커널의 권한이 필요 없는 시스템 콜의 속도를 높이려고 쓰는 유저 공간의 메모리 영역입니다. 이 경우에는 컨텍스트 교환이 일어나지 않기 때문에 빠릅니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단순-시스템-모델"></a>단순 시스템 모델<a class="hash-link" href="#단순-시스템-모델" title="Direct link to heading">#</a></h2><p>자바 애플리케이션의 단순 개념으로 기본 컴포넌트로 구성됩니다.</p><ul><li>애플리케이션이 실행되는 하드웨어와 OS</li><li>애플리케이션이 실행되는 JVM/컨테이너</li><li>애플리케이션 코드 자체</li><li>애플리케이션이 호출되는 외부 시스템</li><li>애플리케이션으로 유입되는 트래픽</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/119248554-e420a800-bbcc-11eb-8428-75cf269b5ee7.png" alt="image"></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="기본-감지-전략"></a>기본 감지 전략<a class="hash-link" href="#기본-감지-전략" title="Direct link to heading">#</a></h2><p>애플리케이션이 잘돌아가는 것은 CPU 사용량, 메모리, 네트워크, I/O 대역폭 등 시스템 리소스를 효율적으로 잘 이용하고 있습니다.</p><p>성능 진단의 첫 단계는 어느 리소스가 한계에 달했는지 확인하는 일입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cpu-사용률"></a>CPU 사용률<a class="hash-link" href="#cpu-사용률" title="Direct link to heading">#</a></h3><p>CPU 사용률은 애플리케이션 성능을 나타내는 핵심 지표입니다. 부하가 집중될때는 사용률이 가능한 100%에 가까워지는 것이 좋습니다.</p><p>일반적으로는 기본 툴 2가지 <code>vmstat</code>와 <code>iostat</code> 정도는 쓸 줄 알아야합니다. 특히 대다수 <code>vmstat</code>은 컨텍스트 교환 발생 횟수를 나타내는데, CPU 사용률이 100% 근처도 못갔는데 컨텍스트 교환 비율이 높으면 I/O에서 블로킹이 일어났거나 스레드 락 경합이 발생했을 확률 이 높습니다.</p><p>다만 <code>vmstat</code> 출력 결과를 봐서는 여러가지 경우의 수를 확인하기 어렵기 때문에 <code>VisualVM</code>을 사용하는 것이 좋습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="가비지-수집"></a>가비지 수집<a class="hash-link" href="#가비지-수집" title="Direct link to heading">#</a></h3><p>핫스팟 JVM은 시작 시메모리를 유저 공간에 할당/관리합니다. 그래서 메모리를 할당하느라 시스템 콜을 할 필요가 없습니다. 즉, 가비지 수집을 하려고 커널 교환을 할 일이 없습니다.</p><p>일반적으로 CPU 사용률이 아주 높다면 GC 문제는 아니지만, JVM 프로세스가 유저 공간에 CPU를 100% 사용하고 있다면 GC를 의심해야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="입출력"></a>입출력<a class="hash-link" href="#입출력" title="Direct link to heading">#</a></h3><p>파일 I/O는 예부터 전체 시스템 성능에 암적인 존재였습니다. 그렇기에 대부분의 자바 프로그램은 단순한 I/O만 처리합니다. 일반적으로 I/O가 집중되는 애플리케이션이 하나만 있는 경우, <code>iostat</code> 같은 툴은 기초 진단에 좋아집니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커널-바이패스-io"></a>커널 바이패스 I/O<a class="hash-link" href="#커널-바이패스-io" title="Direct link to heading">#</a></h4><p>커널을 통해 데이터를 복사해 유저 공간에 넣는 작업은 비싼 작업입니다. 그래서 이를 대신 매핑해주는 전용 HW/SW를 사용합니다. 이를 통해서 컨텍스트 교환이나 이중 복사를 막을 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/119249009-4d55ea80-bbd0-11eb-9932-f40c3ddb66e1.png" alt="image"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="기계-공감"></a>기계 공감<a class="hash-link" href="#기계-공감" title="Direct link to heading">#</a></h3><p>기계 공감은 성능을 조금이라도 더 높여야하는 상황이라면, 공감할 수 있는 능력이 필요합니다. 톡히 고성능, 저지연이 필수인 분야에서 개발자가 자바/VJM을 효과적으로 활용하려면 JVM이 무엇이고 하드웨어와 어떻게 상화작용하는 지 이해해야합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="가상화"></a>가상화<a class="hash-link" href="#가상화" title="Direct link to heading">#</a></h2><p>가상화의 특징은 다음과 같습니다.</p><ul><li>가상화 OS에서 실행하는 프로그램은 비가상화 OS에서 실행할 때와 동일하게 작동해야합니다.</li><li>하이퍼바이저는 모든 하드웨어 리소스 액세스를 조정해야합니다.</li><li>가상화 오버헤드는 가급적 작아야 하며 실행 시간의 상당 부분을 차지해서는 안됩니다.</li></ul><p>가상화 시스템에서는 비가상화 시스템처럼 게스트 OS가 하드웨어에 직접 액세스 할 수 없습니다. 따라서 대부분의 커널 명령어를 unpriviledged 명령어로 고쳐서 사용해야합니다. 또 과한 TLB가 일어나지 않도록 일부 OS 커널의 자료 구조는 섀도 해야합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="jvm과-운영체제"></a>JVM과 운영체제<a class="hash-link" href="#jvm과-운영체제" title="Direct link to heading">#</a></h2><p>JVM은 자바 코드에 공용 인터페이스르를 제공해서 OS에 독립적인 실행 환경을 제공합니다. 하지만 스레드 스케줄링과 같은 기본적인 서비스조차 하부 OS에 반드시 액세스해야하며 이런 기능은 natvie 키워드를 붙인 네ㅌ이티브 메서드로 구현합니다. 이작업을 대행하는 공통 인터페이스를 자바 네이티브 인터페이스(JNI, Java Native Interface)라고 합니다.</p><p>이러한 핫스팟 호출을 확인하면 다음처럼 확인할 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/119251437-76cb4200-bbe1-11eb-8182-a3f1dec40500.png" alt="image"></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/optimizing-java/ch3.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-25T10:02:47.000Z" class="lastUpdatedDate_1WI_">7/25/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 2. JVM 이야기</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch4"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">4. 성능 테스트 패턴 및 안티패턴 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#메모리" class="table-of-contents__link">메모리</a><ul><li><a href="#메모리-캐시" class="table-of-contents__link">메모리 캐시</a></li></ul></li><li><a href="#최신-프로세서의-특성" class="table-of-contents__link">최신 프로세서의 특성</a><ul><li><a href="#변환-색인-버퍼tlb" class="table-of-contents__link">변환 색인 버퍼(TLB)</a></li><li><a href="#분기-예윽과-추측-실행" class="table-of-contents__link">분기 예윽과 추측 실행</a></li><li><a href="#하드웨어-메모리-모델" class="table-of-contents__link">하드웨어 메모리 모델</a></li></ul></li><li><a href="#운영체제" class="table-of-contents__link">운영체제</a><ul><li><a href="#스케줄러" class="table-of-contents__link">스케줄러</a></li><li><a href="#시간-문제" class="table-of-contents__link">시간 문제</a></li><li><a href="#컨텍스트-교환" class="table-of-contents__link">컨텍스트 교환</a></li></ul></li><li><a href="#단순-시스템-모델" class="table-of-contents__link">단순 시스템 모델</a></li><li><a href="#기본-감지-전략" class="table-of-contents__link">기본 감지 전략</a><ul><li><a href="#cpu-사용률" class="table-of-contents__link">CPU 사용률</a></li><li><a href="#가비지-수집" class="table-of-contents__link">가비지 수집</a></li><li><a href="#입출력" class="table-of-contents__link">입출력</a></li><li><a href="#기계-공감" class="table-of-contents__link">기계 공감</a></li></ul></li><li><a href="#가상화" class="table-of-contents__link">가상화</a></li><li><a href="#jvm과-운영체제" class="table-of-contents__link">JVM과 운영체제</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.e312a594.js"></script>
<script src="/til/assets/js/main.a50accfc.js"></script>
</body>
</html>