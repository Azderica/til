<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">6. 가비지 수집 기초 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/optimizing-java/ch6"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="6. 가비지 수집 기초 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하고 쓸모없는 객체를 알아서 제거하는 것입니다. 이렇게 자동 회수한 메모리는 께끗이 비우고 재활용할 수 있습니다."><meta data-react-helmet="true" property="og:description" content="가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하고 쓸모없는 객체를 알아서 제거하는 것입니다. 이렇게 자동 회수한 메모리는 께끗이 비우고 재활용할 수 있습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch6"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch6" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/optimizing-java/ch6" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.a55e9a0e.js" as="script">
<link rel="preload" href="/til/assets/js/main.d2c683bf.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">6. 가비지 수집 기초</h1></header><div class="markdown"><p>가비지 수집의 요체는 시스템에 있는 모든 객체의 수명을 정확히 몰라도 런타임이 대신 객체를 추적하고 쓸모없는 객체를 알아서 제거하는 것입니다. 이렇게 자동 회수한 메모리는 께끗이 비우고 재활용할 수 있습니다.</p><p>가비지 수집 구현체는 다음 두 가지 기본 원칙을 준수해야합니다.</p><ul><li>알고리즘은 반드시 모든 가비지를 수집해야합니다.</li><li><strong>살아있는 객체는 절대로 수집하면 안됩니다.</strong></li></ul><p>사용중인 객체를 수집하면 세그먼테이션 결함이 발생합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="마크-앤-스위프"></a>마크 앤 스위프<a class="hash-link" href="#마크-앤-스위프" title="Direct link to heading">#</a></h2><blockquote><p>마크 앤 스위프, 표지하고 쓸어담기</p></blockquote><p>전체적인 GC 알고리즘</p><ul><li>할당 리스트를 순회하면서 마크 비트를 지웁니다.</li><li>GC 루트부터 살아 있는 객체를 찾습니다.</li><li>이렇게 찾은 객체마다 마크 비트를 세팅합니다.</li><li>할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾습니다.<ul><li>힙에서 메모리를 회수해 프리 리스트에 되돌립니다.</li><li>할당 리스트에서 객체를 삭제합니다.</li></ul></li></ul><p>보통 살아 있는 객체는 대부분 DFS로 찾습니다. 이렇게 해서 생성된 <strong>객체 그래프를 라이브 객체 그래프</strong>라고하며 접근 가능한 객체의 전이 폐쇄라고 합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="가비지-수집-용어"></a>가비지 수집 용어<a class="hash-link" href="#가비지-수집-용어" title="Direct link to heading">#</a></h3><ul><li>STW<ul><li>GC 사이클이 발생해서 가비지를 수집하는 동안에 모든 애플리케이션 스레드가 중단되는 상황</li></ul></li><li>동시<ul><li>GC 스레드는 애플리케이션 스레드와 동시 실행될 수 있습니다.</li></ul></li><li>병렬<ul><li>여러 스레드를 동원해서 가비지 수집을 합니다.</li></ul></li><li>정확<ul><li>정확한 GC 스킵은 전체 가비지를 한방에 수집할 수 있게 힙 상태에 관한 충분한 타입 정보를 가지고 있습니다.</li></ul></li><li>보수<ul><li>리소스를 낭비하는 일이 많고 근본적으로 타입 체계를 무시하므로 비효율적입니다.</li></ul></li><li>이동<ul><li>이동 수집기에서 객체는 메모리를 오갈 수 있습니다.</li><li>객체 주소가 고정된 게 아닙니다.</li></ul></li><li>압착<ul><li>할당된 메모리는 GC 사이클 마지막에 연속된 단일 영역으로 배열되며 배열됩니다.</li><li>이는 <code>memory fragmentation</code>을 방지합니다.</li></ul></li><li>방출<ul><li>수집 사이클 마지막에 할당된 영역을 완전히 비우고 살아남은 객체는 모두 다른 메모리 영역으로 방출합니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핫스팟-런타임-개요"></a>핫스팟 런타임 개요<a class="hash-link" href="#핫스팟-런타임-개요" title="Direct link to heading">#</a></h2><p>자바에서는 두가지 값만 사용함</p><ul><li>기본형(byte, int 등)</li><li>객체 레퍼런스</li></ul><p>자바는 C++와 달리 <strong>주소를 역참조(dereference)하는 일반적인 메커니즘이 없고 오직 오프셋 연산자나 객체 레퍼런스의 메서드를 호출</strong>할 수 있습니다. 또한 자바는 값으로 호출(<code>callByValue</code>)하는 방식으로만 <strong>메서드를 호출</strong>합니다. 객체 레퍼런스의 경우, 복사된 값은 힙에 있는 객체의 주소입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="객체를-런타임에-표현하는-방법"></a>객체를 런타임에 표현하는 방법<a class="hash-link" href="#객체를-런타임에-표현하는-방법" title="Direct link to heading">#</a></h3><p>핫스팟은 런타임에 oop(ordinary object pointer, 평범한 객체 포인터)라는 구조체로 자바 객체를 나타냅니다. (C의 포인터와 비슷합니다.) oop는 참조형 지역 변수 안에 위치하며 메서드의 스택 프레임으로부터 자바 힙을 구성하는 메모리 영역 내부를 가리킵니다.</p><p>oop를 구성하는 자료 구조는 여러가지가 있습니다. 그중 <code>instanceOop</code>는 자바 클래스의 인스턴스를 나타냅니다.</p><p>이는 크게 두개의 기계어 워드 2개로 구성됩니다.</p><ul><li><code>Mark</code> 워드(인스턴스 관련 메타데이터를 가리키는 포인터)</li><li><code>Klass</code> 워드(클래스 메타데이터를 가리키는 포인터)</li></ul><p>자바 8이후로는 기존과 달리 Klass 워드가 자바 힙 밖을 가리키므로 객체 헤더가 필요없습니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120794204-e1319a00-c572-11eb-99ad-01812d930ac8.png" alt="image"></p><p>배열또한 이러한 객체입니다. 그렇기 때문에 Klass 워드 다음에 배열 길이를 나타내는 Length워드가 붙어있어서 C++처럼 길이를 주지 않아도 됩니다.</p><p>JVM 환경에서 자바 레퍼런스는 <code>instanceOop</code>를 제외한 어떤 것도 가리킬 수 없습니다.</p><ul><li>자바 값은 기본형 값 또는 <code>instanceOop</code> 주소(레퍼런스)에 대응되는 비트 패턴입니다.</li><li>모든 자바 레퍼런스는 자바 힙의 주 영역에 있는 주소를 가리키는 포인터입니다.</li><li>자바 레퍼런스가 가리키는 주소에는 <code>Mark</code> 워드와 <code>Klass</code> 워드가 들어있습니다.</li><li><code>klassOop</code>와 <code>Class&lt;?&gt;</code> 의 인스턴스는 다르며 <code>klassOop</code>(힙의 메타데이터 영역에 있음)을 자바 변수에 넣을 수 없습니다.</li></ul><p>핫스팟의 oop 체계를 까보면 다음과 같습니다. (hotspot/src/share/vm/oops
)</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">oop (추상 베이스)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> instanceOop (인스턴스 객체)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> methodOop (메서드 표현형)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> arrayOop (배열 추상 베이스)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> symbolOop (내부 심볼 / 스트링 클래스)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> klassOop (Klass 헤더) (자바 7 이전만 해당)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> markOop</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="gc-루트-및-아레나"></a>GC 루트 및 아레나<a class="hash-link" href="#gc-루트-및-아레나" title="Direct link to heading">#</a></h3><p><strong>GC 루트</strong>는 <strong>메모리의 고정점(앵커 포인트, anchor point)으로 메모리 풀 외부에서 내부를 가리키는 포인터</strong>입니다. 즉, 메모리 풀 내부에서 같은 메모리 풀 내부의 다른 메모리 위치를 가리키는 <code>내부 포인터(internal pointer)</code>와 정반대인 외부 포인터입니다.</p><p>다음과 같은 종류가 있습니다.</p><ul><li>스택 프레임(stack frame)</li><li>JNI</li><li>레지스터(호이스트된 변수)</li><li>코드 루트</li><li>전역 객체</li><li>로드된 클래스의 메타데이터</li></ul><p>핫스팟 GC는 <code>아레나</code>라는 메모리 영역에서 작동합니다. 핫스팟은 자바 힙을 관리할 때 시스템 콜을 하지 않습니다.</p><p>자바/JVM 워크로드의 <strong>가비지 수집을 일으키는 두 가지 주요 특성</strong>에 대해 살펴보면 다음과 같습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="할당과-수명"></a>할당과 수명<a class="hash-link" href="#할당과-수명" title="Direct link to heading">#</a></h2><p>자바 애플리케이션에서 가비지 수집이 일어나는 주된 원인은 다음 두가지입니다.</p><ul><li>할당률<ul><li>일종 기간 동안 새로 생성된 객체가 사용한 메모리량</li><li>비교적 쉽게 측정이 가능하고 센섬 같은 툴을 통해서 구할 수 있습니다.</li></ul></li><li>객체 수명<ul><li>측정하기가 어렵습니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="약한-세대별-가설"></a>약한 세대별 가설<a class="hash-link" href="#약한-세대별-가설" title="Direct link to heading">#</a></h3><p>소프트웨어 시스템의 런타임 작용을 관찰한 결과 알게 된 경험 지식이며, JVM 메모리 관리의 이론적 근간을 형성합니다.</p><ul><li>JVM 및 유사 소프트웨어 시스템에서 객체 수명은 이원적 분포 양상을 보입니다. 거의 대부분의 객체는 아주 짧은 시장만 살아 있지만, 나머지 객체는 기대 수명이 큽니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/120880087-15ed3200-c603-11eb-8d82-eb76e7c1c465.png" alt="image"></p><p>핫스팟은 <strong>카드 테이블</strong>이라는 자료 구조에 늙은 객체가 젊은 객체를 참조하는 정보를 기록합니다.</p><p>자바 수집기는 힙을 영/올드 영역으로 나누어서 관리합니다. (현재는 조금 달라졌습니다.)</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="핫스팟의-가비지-수집"></a>핫스팟의 가비지 수집<a class="hash-link" href="#핫스팟의-가비지-수집" title="Direct link to heading">#</a></h2><p>자바는 C/C++와 달리 OS를 이용해 동적으로 메모리를 관리하지 않습니다. 대신, 일단 프로세스가 시작하면 JVM은 메모리를 할당하고 유저 공간에서 연속된 단일 메모리 풀을 관리합니다.</p><p>이 메모리 풀은 각자의 목적에 따라 서로 다른 영역으로 구성되며 객체는 보통 에덴 영역에 생성됩니다. 수집기는 객체를 이동시키는데 객체가 차지한 주소는 대부분 시간이 흐르면서 아주 빈번하게 바뀝니다. 이처럼 객체를 이동시키는 것은 &#x27;방출&#x27;이라고 하며, 핫스팟 수집기는 대부분 방출 수집기입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스레드-로컬-할당"></a>스레드 로컬 할당<a class="hash-link" href="#스레드-로컬-할당" title="Direct link to heading">#</a></h3><p>JVM은 성능을 강화해서 에덴을 관리하며, 에덴은 대부분의 객체가 탄생하는 장소입니다. 특히 수명이 짧은 객체는 다른 곳에는 위치할 수 없으므로 특별히 관리를 잘해야합니다.</p><p>JVM은 에덴을 여러 버퍼로 나누어 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포합니다. 이 때 이 구역을 스레드 로컬 할당 버퍼(TLAB, Thread-Local Allocation Buffer)라고 합니다.</p><p><img src="https://user-images.githubusercontent.com/42582516/120988103-33fc9300-c7b9-11eb-9a98-0998e843aee1.png" alt="image"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="반구형-수집"></a>반구형 수집<a class="hash-link" href="#반구형-수집" title="Direct link to heading">#</a></h3><p>반구형 수집기는 두 공간을 사용하는 독특한 방출 수집기입니다. 즉, 오래 살지 못한 객체를 임시 수용소에 담아 두는 아이디어입니다. 이 공간은 두가지의 기본 특징을 가집니다.</p><ul><li>수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜 옮기고 수집된 반구는 비워서 재사용합니다.</li><li>절반의 공간은 항상 완전히 비웁니다.</li></ul><p>핫스팟은 이 반구형 기법과 에덴 공간을 접목시켜서 영 세대 수집을 합니다. 핫스팟에서는 영 힙의 반구부를 서바이버(survivor) 공간이라고 합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="병렬-수집기"></a>병렬 수집기<a class="hash-link" href="#병렬-수집기" title="Direct link to heading">#</a></h2><p>자바 병렬 수집기도 여러개가 있습니다.</p><ul><li>Parallel GC<ul><li>가장 단순한 영 세대용 병렬 수집기</li></ul></li><li>ParNew GC<ul><li>CMS 수집기와 함께 사용할 수 있게 Parallel GC를 조금 변형한 것입니다.</li></ul></li><li>ParallelOld GC<ul><li>올드 세대용 병렬 수집기입니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="영-세대-병렬-수집"></a>영 세대 병렬 수집<a class="hash-link" href="#영-세대-병렬-수집" title="Direct link to heading">#</a></h3><p>영세대 수집은 가장 흔한 가비지 수집 형태입니다. 스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간은 부족하고 JVM은 새 TLAB을 할당할 수 없을 때 영 세대 수집이 발생합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="올드-세대-병렬-수집"></a>올드 세대 병렬 수집<a class="hash-link" href="#올드-세대-병렬-수집" title="Direct link to heading">#</a></h3><p>올드 세대에 더 이상 방출할 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치해서 늙은 객체가 죽고 빠져 버려진 공간을 회수하려고 합니다.</p><p>올드 공간은 크게 눈에 띄는 변화가 없습니다. 때때로 큰 객체가 테뉴어드 세대에 직접 생성되는 경우도 있지만, 그 외에는 영 세대 객체가 승격되거나 올드/풀 수집이 일어나 객체를 재탐색 후 다시 패치하는 등의 수집이 일어날 때만 변합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="병렬-수집기의-한계"></a>병렬 수집기의 한계<a class="hash-link" href="#병렬-수집기의-한계" title="Direct link to heading">#</a></h3><p>뱡랼 수집기는 세대 전체 콘텐츠를 대상으로 한번에 가능한 한 효율적으로 가비지를 수집합니다. 다만 이러한 설계에도 단점은 있습니다.</p><ul><li>풀 STW<ul><li>힙 크기가 커질수록 느려집니다.</li></ul></li><li>영역 내 살아 있는 객체 수만큼 마킹 시간이 늘어납니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="할당의-역할"></a>할당의 역할<a class="hash-link" href="#할당의-역할" title="Direct link to heading">#</a></h2><p>자바의 가비지 수집 프로세스는 보통 유입된 메모리 할당 요청을 수용하기에 메모리가 부족할 때 작동하여 필요한 만큼 메모리를 공급합니다. 즉, GC 사이클은 어떤 고정된 예측 가능한 일정에 맞춰 발생하는 것이 아니라 순전히 필요로 할 때 발생합니다. (즉, <strong>불확정적 + 불규칙적</strong>입니다.)</p><p>GC가 발생하면 모든 애플리케이션 스레드가 멈춥니다. (객체를 생성할 수 없으므로 오래 실행될 자바 코드가 없습니다.) JVM은 모든 코어를 총동원해 가비지를 수집하고 메모리를 회수한 후, 애플리케이션 스레드를 재개합니다.</p><p>앞서 이야기한 것처럼 가비지 수집은 일정한 주기마다 실행되는 것이 아니라 필요에 따라 그때마다 실행됩니다. 할당률이 높을수록 GC는 더 자주 발생합니다. 할당률이 너무 높은 경우에는 테뉴어드로 곧장 승격이 되는데 이를 <strong>조기 승격</strong>이라고 합니다.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/optimizing-java/ch6.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-25T10:02:47.000Z" class="lastUpdatedDate_1WI_">7/25/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch5"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 5. 마이크로벤치마킹과 통계</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch7"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">7. 가비지 수집 고급 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#마크-앤-스위프" class="table-of-contents__link">마크 앤 스위프</a><ul><li><a href="#가비지-수집-용어" class="table-of-contents__link">가비지 수집 용어</a></li></ul></li><li><a href="#핫스팟-런타임-개요" class="table-of-contents__link">핫스팟 런타임 개요</a><ul><li><a href="#객체를-런타임에-표현하는-방법" class="table-of-contents__link">객체를 런타임에 표현하는 방법</a></li><li><a href="#gc-루트-및-아레나" class="table-of-contents__link">GC 루트 및 아레나</a></li></ul></li><li><a href="#할당과-수명" class="table-of-contents__link">할당과 수명</a><ul><li><a href="#약한-세대별-가설" class="table-of-contents__link">약한 세대별 가설</a></li></ul></li><li><a href="#핫스팟의-가비지-수집" class="table-of-contents__link">핫스팟의 가비지 수집</a><ul><li><a href="#스레드-로컬-할당" class="table-of-contents__link">스레드 로컬 할당</a></li><li><a href="#반구형-수집" class="table-of-contents__link">반구형 수집</a></li></ul></li><li><a href="#병렬-수집기" class="table-of-contents__link">병렬 수집기</a><ul><li><a href="#영-세대-병렬-수집" class="table-of-contents__link">영 세대 병렬 수집</a></li><li><a href="#올드-세대-병렬-수집" class="table-of-contents__link">올드 세대 병렬 수집</a></li><li><a href="#병렬-수집기의-한계" class="table-of-contents__link">병렬 수집기의 한계</a></li></ul></li><li><a href="#할당의-역할" class="table-of-contents__link">할당의 역할</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.a55e9a0e.js"></script>
<script src="/til/assets/js/main.d2c683bf.js"></script>
</body>
</html>