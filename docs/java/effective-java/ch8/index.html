<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">8. 메소드 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/effective-java/ch8"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="8. 메소드 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="이 챔터에서는 메서드 디자인의 여러 측면에 대해 이야기합니다. (어떻게 파라미터를 처리하고, 값을 리턴하는지, 메서드 서명을 어떻게 디자인하는 지, 메서드를 어떻게 문서화하는지) 이러한 대부분의 자료들은 생성자와 메서드에에 적용됩니다. 특히, 유용성, 견고성 및 유연성에 중점을 둡니다."><meta data-react-helmet="true" property="og:description" content="이 챔터에서는 메서드 디자인의 여러 측면에 대해 이야기합니다. (어떻게 파라미터를 처리하고, 값을 리턴하는지, 메서드 서명을 어떻게 디자인하는 지, 메서드를 어떻게 문서화하는지) 이러한 대부분의 자료들은 생성자와 메서드에에 적용됩니다. 특히, 유용성, 견고성 및 유연성에 중점을 둡니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/effective-java/ch8"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch8" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch8" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.43dc5b53.js" as="script">
<link rel="preload" href="/til/assets/js/main.980de010.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">8. 메소드</h1></header><div class="markdown"><p>이 챔터에서는 메서드 디자인의 여러 측면에 대해 이야기합니다. (어떻게 파라미터를 처리하고, 값을 리턴하는지, 메서드 서명을 어떻게 디자인하는 지, 메서드를 어떻게 문서화하는지) 이러한 대부분의 자료들은 생성자와 메서드에에 적용됩니다. 특히, 유용성, 견고성 및 유연성에 중점을 둡니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-49-매개-변수의-유효성을-확인합니다"></a>Item 49. 매개 변수의 유효성을 확인합니다.<a class="hash-link" href="#item-49-매개-변수의-유효성을-확인합니다" title="Direct link to heading">#</a></h2><p>대부분의 메서드와 생성자는 매개 변수에 전달할 수 있는 값에 대한 몇가지 제한이 있습니다. 그렇기 때문에, 특정 실패에 대해 예외처리를 해줘야합니다.</p><p>그러나 Java 7에서 추가된 <code>Object.requireNonNull</code>처럼, 유연하고 편리한 방법을 통해서 null 검사 등을 수동으로 할 필요가 없게 되었습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Java의 null 검사 기능 인라인 사용</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">this.strategy = Objects.requireNonNull (strategy, &quot;strategy&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그 이후로, Java 9에서는 범위 검사 기능이 <code>java.util.Objects</code>에 추가되었으며, 이러한 방법은 checkFromIndexSize, checkFromToIndex, checkIndex 등을 사용할 수 있습니다.</p><p>nonpublic method는 <code>assertions</code>을 사용해서 매개변수를 확인할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 재귀 적 정렬을 위한 private helper function</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private static void sort(long a[], int offset, int length) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert a != null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert offset &gt;= 0 &amp;&amp; offset &lt;= a.length;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  assert length &gt;= 0 &amp;&amp; length &lt;= a.length - offset;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do the computation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><code>assert</code>의 기본 원리는 패키지가 클라이언트에 의해 사용되는 방식에 관계없이 asserted condition이 true라는 주장으로 진행됩니다. 그렇기 때문에, 일반 유효성 검사와 달리 assertions은 만약 실패할시, <code>AssertionError</code>가 발생합니다.</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/assert.html" target="_blank" rel="noopener noreferrer">Assertions 공식 문서</a></li></ul><p>이외에도 여러 조건에 따라 확인할 수 있는 부분이 있고, 확인할 수 없는 부분이 있습니다.</p><p>결론적으로는 <strong>메소드나 생성자를 작성할 때마다, 매개 변수에 어떤 제한이 있는지를 생각</strong>해야합니다. 이러한 제한 사항을 문서화하여야하며, method body의 시작 부분에 명시적인 검사를 적용해야하며, 이러한 습관을 가지고 있어야합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-50-필요할-때-방어적-사본을-생성합니다"></a>Item 50. 필요할 때, 방어적 사본을 생성합니다.<a class="hash-link" href="#item-50-필요할-때-방어적-사본을-생성합니다" title="Direct link to heading">#</a></h2><p>Java의 장점 중 하나는, safe language입니다. 이는 메모리 손상 오류에 영향을 받지않음을 의미하며, 이를 통해서 어떤 일이 일어나도 불변성이 유지될 것이라 확신하고 진행할 수 있습니다.</p><p>다만, 이 경우에도 코드를 개판... 으로 짜면 문제가 발생할 수 있습니다. 따라서 <strong>클래스의 클라이언트가 위험하게 구성될 수 있다는 가정하에, 방어적으로 프로그래밍해야합니다.</strong></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Broken &quot;immutable&quot; time period class</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public final class Period {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final Date start;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final Date end;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Period(Date start, Date end) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (start.compareTo(end) &gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      throw new IllegalArgumentException(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    start + &quot; after &quot; + end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.start = start;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.end   = end;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Date start() { return start; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Date end() {   return end;   }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...    // Remainder omitted</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Period 인스턴스의 내부를 공격한 경우.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Date start = new Date();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Date end = new Date();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Period p = new Period(start, end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end.setYear(78); // p 내부가 수정됩니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 경우처럼, Date가 더이상 사용되지 않으면 이를 새로운 코드에서 사용하면 안됩니다. 따라서 이러한 문제에서 인스턴스 내부를 보호하려면, <strong>생성자에 대한 각 변경 가능한 매개 변수의 방어적 복사본을 만드는 것이 중요합니다.</strong></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 변경된 생성자, 매개 변수의 방어적 복사본을 만듭니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Period (Date start, Date end) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.start = new Date (start.getTime ());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.end = new Date (end.getTime ());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (this.start.compareTo (this.end)&gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new IllegalArgumentException (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  this.start + &quot;after&quot;+ this.end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이렇게 사용하면 위의 문제를 해결할 수 있습니다. 그러나 아래처럼, 데이터를 바꿀 수 도 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Date start = new Date ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Date end = new Date ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Period p = new Period(start, end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">p.end().setYear(78); // p의 내부를 수정합니다!</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 해결할려면 다음처럼 또 할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 수리 된 접근 자-내부 필드의 방어용 복사본 만들기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Date start () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return new Date (start.getTime ());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Date end () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return new Date (end.getTime ());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같이 새로운 생성자와 새로운 접근자를 사용함을 통해서 방어적 코딩을 할 수 있습니다.</p><p><strong>클라이언트에서 클래스를 가져오거나, 반환하는 경우에 변경 가능한 요소가 있는 경우에는 클래스는 구성 요소를 방어적으로 복사해야합니다. 복사를 할 수 없는 환경이면, 사용하는 클라이언트를 신뢰하는 구조로 가야하면서, 이를 수정하지 않도록 문서화시켜야합니다.</strong></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-51-메서드-이름을-신중하게-설계합니다"></a>Item 51. 메서드 이름을 신중하게 설계합니다.<a class="hash-link" href="#item-51-메서드-이름을-신중하게-설계합니다" title="Direct link to heading">#</a></h2><p>아래의 규칙을 지켜야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메서드-이름을-신중하게-선택해야합니다"></a>메서드 이름을 신중하게 선택해야합니다.<a class="hash-link" href="#메서드-이름을-신중하게-선택해야합니다" title="Direct link to heading">#</a></h3><ul><li>이해하기 동일한 패키지의 다른 이름과 일치하는 이름을 선택합니다.</li><li>광범위한 합의와 일치하는 이름을 선택하는 것이 좋습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="편리한-방법을-제공하는데-너무-과하게-사용하면-안됩니다"></a>편리한 방법을 제공하는데 너무 과하게 사용하면 안됩니다.<a class="hash-link" href="#편리한-방법을-제공하는데-너무-과하게-사용하면-안됩니다" title="Direct link to heading">#</a></h3><ul><li>너무 많아지면 이를 사용하고 문서화하고 테스트, 유지하는데 어려워집니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="너무-긴-매개변수는-피합니다"></a>너무 긴 매개변수는 피합니다.<a class="hash-link" href="#너무-긴-매개변수는-피합니다" title="Direct link to heading">#</a></h3><ul><li>4개 이하의 매개변수를 사용하는 것이 좋습니다.</li><li>동일한 형식의 매개 변수 시퀀스가 길면 안좋습니다.</li></ul><p>이를 해결하는 방법은 다음과 같습니다.</p><ul><li>메서드를 여러 메서드로 나눕니다.</li><li>매개 변수 그룹을 보유하는 <code>helper class</code>를 만듭니다.</li><li>메서도 호출까지 Builder 패턴을 적용합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="매개변수-유형의-경우-클래스보다-인터페이스를-선호합니다"></a>매개변수 유형의 경우, 클래스보다 인터페이스를 선호합니다.<a class="hash-link" href="#매개변수-유형의-경우-클래스보다-인터페이스를-선호합니다" title="Direct link to heading">#</a></h3><p>매개 변수를 정의하는데 적합한 인터페이스가 있는 경우, 인터페이스를 구현하는 클래스를 대신 사용하는 것이 좋습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="boolean의-의미가-메서드-이름에서-명확하지-않으면boolean-매개-변수-보다는-요소가-두개인-enum-형을-쓰는-것이-중요합니다"></a>boolean의 의미가 메서드 이름에서 명확하지 않으면,boolean 매개 변수 보다는 요소가 두개인 Enum 형을 쓰는 것이 중요합니다.<a class="hash-link" href="#boolean의-의미가-메서드-이름에서-명확하지-않으면boolean-매개-변수-보다는-요소가-두개인-enum-형을-쓰는-것이-중요합니다" title="Direct link to heading">#</a></h3><p>열거형을 통해서 코드를 더 쉽게 읽고 쓸 수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-52-오버로딩을-신중하게-사용합니다"></a>Item 52. 오버로딩을 신중하게 사용합니다.<a class="hash-link" href="#item-52-오버로딩을-신중하게-사용합니다" title="Direct link to heading">#</a></h2><p>아래는 집합, 목록, 또는 다른 종류의 컬렉션인지에 따라 컬렉션을 분류하는 의도로 된 목적으로 된 코드입니다. 그러나 잘못된 코드입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class CollectionClassifier {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static String classify(Set&lt;?&gt; s) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return &quot;Set&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static String classify(List&lt;?&gt; lst) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return &quot;List&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static String classify(Collection&lt;?&gt; c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return &quot;Unknown Collection&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Collection&lt;?&gt;[] collections = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      new HashSet&lt;String&gt;(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      new ArrayList&lt;BigInteger&gt;(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      new HashMap&lt;String, String&gt;().values()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (Collection&lt;?&gt; c : collections)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(classify(c));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/* Output</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * : Unknown Collection</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * : Unknown Collection</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * : Unknown Collection</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음과 같이 발생하는 원인은, <code>classify</code> 메서드가 overload되고 호출할 overload가 컴파일 타임에 선택되기 때문입니다.</p><p>오버로드된 메서드 중에서 선택이 static이고, 재정의된 메서드 중에서 선택이 <code>dynamic</code>이기 때문에 직관적이지 않습니다. 즉, 오버로딩된 메서드의 올바른 버전은 런타임에 선택되고, 메서드가 호출되는 개체의 런타임 유형을 기반으로 합니다.</p><p>즉, 상위 클래스의 메서드 선언과 동일한 시그니처가 있는 메서드 선언이 하위 클래스에 포함되어 있으면 메서드가 재정의 됩니다. 이를 잘표현 코드는 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Wine {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String name() { return &quot;wine&quot;; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SparklingWine extends Wine {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override String name() { return &quot;sparkling wine&quot;; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Champagne extends SparklingWine {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override String name() { return &quot;champagne&quot;; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Overriding {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    List&lt;Wine&gt; wineList = List.of(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      new Wine(), new SparklingWine(), new Champagne());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (Wine wine : wineList)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(wine.name());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">/* Output</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * : wine</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * : sparkling wine</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * : champagne</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>또 다른 방법으로 아래처럼 <code>instanceof</code>를 사용할 수도 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static String classify(Collection&lt;?&gt; c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return c instanceof Set ? &quot;Set&quot; :</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    c instanceof List ? &quot;List&quot; : &quot;Unknown Collection&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>오버라이딩(overriding)은 표준이고, 오버로딩(overloading)이기 때문에, 오버라이딩(overriding, 재정의)는 메서드 호출의 동작에 대해 사람들의 예상을 설정할 수 있습니다. 그러나 오버로딩(overloading)은 여러 expectations에 혼란을 줄 수 있습니다.</p><p>이러한 잘못된 오버로딩의 사용은, 어떠한 것이 호출되는지 모르기 때문에 어려움을 겪을 수 있습니다. 따라서 <strong>혼란스러운 오버로딩 사용을 피해야합니다.</strong></p><p>여러 오버로딩을 잘사용하는 방법은 이야기가 많지만, <strong>안전하고 보수적인 정책은 동일한 수의 매개 변수로 두 개의 오버로딩을 내보내지 않는 것입니다.</strong> 이러한 제한을 통해서 메서드를 오버로드하는 대신 항상 다른 이름을 지정할 수 있습니다.</p><p>예를 들면, write 메서드 대신에, writeBoolean, writeInt, writeLong 등이 있으며 이를 통해서 대응하는 메서드를 바로 확인할 수 있다는 점입니다.</p><p>오버로딩을 애매하게 사용하는 부분은 Java 5 이전부터 존재했으며, Java 8에서 람다가 나오고 나서 더 헷갈리게 되었습니다. 또한 동일한 인수 위치에서 서로 다른 기능적 인터페이스를 사용하는 메서드 또는 생성자를 오버로딩하면 혼란을 만듭니다. <strong>동일한 인수 위치에서 다른 기능 인터페이스를 사용하기 위해 메서드를 오버로드하면 안됩니다.</strong></p><p>결론적으로는, 메서드를 오버로드할 수 있다고 꼭 할 필요가 없습니다. 일반적으로 동일한 수의 매개 변수를 가진 여러 시그니처가 있는 메서드를 오버로드하지 않는 곳이 좋습니다. 일부 생성자와 관련되어 이가 힘들 수도 있지만, 캐스트를 통해서 동일한 매개 변수가 다른 오버로딩에 전달되는 것은 막아야합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-53-varargs를-신중하게-사용합니다"></a>Item 53. Varargs를 신중하게 사용합니다.<a class="hash-link" href="#item-53-varargs를-신중하게-사용합니다" title="Direct link to heading">#</a></h2><p><code>variable arity</code> 메서드로 알려진 Varargs 메서드는 지정된 유형의 0개 이상의 이상의 인수를 허용합니다. varargs 기능은 먼저 arguments 배열을 만들고, 다음 argument 값을 배열에 넣고, 마지막으로 배열을 메서드에 전달하는 방식으로 작동합니다.</p><p>아래는 대표적인 예시입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 간단한 varargs 사용</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int sum(int... args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int sum = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for(int arg : args)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sum += arg;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sume;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그러나 때로는 0 개 이상의 인수가 아닌 특정 유형의 하나 이상의 인수 가 필요한 메서드를 작성하는 것이 적절합니다</p><p>아래는 잘못된 코드입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int min(int... args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (args.length == 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new IllegalArgumentException(&quot;Too few arguments&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int min = args[0];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int i = 1; i &lt; args.length; i++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (args[i] &lt; min)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      min = args[i];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return min;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위의 문제는 클라이언트가 인수없이 메서드를 호출하면 컴파일 에러가 아닌 런타임 에러가 발생합니다. 이를 해결하기 위해서는 두개의 매개 변수를 사용할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// The right way to use varargs to pass one or more arguments</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int min(int firstArg, int... remainingArgs) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int min = firstArg;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int arg : remainingArgs)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (arg &lt; min)  min = arg;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return min;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>성능이 중요한 상황에서 varargs를 사용할 때는 주의해서 사용해야합니다. varargs 메서드를 호출할 때 마다 배열 할당 및 초기화가 발생합니다. 이러한 경우 성능적인 이슈를 해결하기 위해서는 다음과 같은 패턴을 사용할 수도 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public void foo() { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public void foo(int a1) { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public void foo(int a1, int a2) { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public void foo(int a1, int a2, int a3) { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public void foo(int a1, int a2, int a3, int... rest) { }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이는 일반적으로 적절하지않지만, 일부 경우에서 적용될 수 있습니다.</p><p>즉, varargs는 가변 개수의 인수로 메서드를 정의해야할 때 매우 유용합니다. varargs 매개 변수 앞에 필수 매개 변수를 추가하고 varargs 의 성능에 대해 유의해야합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-54-null이-아닌-빈-컬렉션이나-배열을-반환합니다"></a>Item 54. Null이 아닌 빈 컬렉션이나 배열을 반환합니다.<a class="hash-link" href="#item-54-null이-아닌-빈-컬렉션이나-배열을-반환합니다" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 빈 컬렉션을 나타 내기 위해 null을 반환합니다. -&gt; 좋지 않습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private final List&lt;Cheese&gt; cheesesInStock = ...;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public List&lt;Cheese&gt; getCheeses() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cheesesInStock.isEmpty() ? null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    : new ArrayList&lt;&gt;(cheesesInStock);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 경우, 클라이언트 측에서는 null을 처리하기 위해서 추가 코드가 필요합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">List&lt;Cheese&gt; cheeses = shop.getCheeses();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (cheeses != null &amp;&amp; cheeses.contains(Cheese.STILTON))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(&quot;Jolly good, just the thing.&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이런 처리가 필요없게 하기 위해서는 다음과 같이 작성하는 것이 좋습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">List&lt;Cheese&gt; cheeses = shop.getCheeses();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (cheeses != null &amp;&amp; cheeses.contains(Cheese.STILTON))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(&quot;Jolly good, just the thing.&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 더 최적화하면 아래처럼 표현할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 최적화-빈 컬렉션 할당 방지</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public List &lt;Cheese&gt; getCheeses () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cheesesInStock.isEmpty ()? Collections.emptyList ()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    : new ArrayList &lt;&gt; (cheesesInStock);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>배열도 비슷한 방식으로 처리할 수 있으며, 최적화할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 최적화-빈 배열 할당 방지</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private static final Cheese [] EMPTY_CHEESE_ARRAY = new Cheese [0];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Cheese [] getCheeses () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return cheesesInStock.toArray (EMPTY_CHEESE_ARRAY);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 요약하면, <strong>빈 배열이나 컬렉션 대신에 null을 반환하면 안됩니다.</strong></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-55-optionals를-신중하게-반환합니다"></a>Item 55. Optionals를 신중하게 반환합니다.<a class="hash-link" href="#item-55-optionals를-신중하게-반환합니다" title="Direct link to heading">#</a></h2><p>Java 8 이전에는 특정 상황에서 값을 반환 할 수 없는 메서드를 작성할 때, 취할 수 있는 두 가지 접근 방식이 있습니다. 보통 예외를 throw 하거나 반환할 수 있습니다. 하지만 디 두 접근 방식 모두 완벽하지는 않습니다.</p><p>Java 8에는 값을 반환 할 수 없는 메서드를 작성하는 세번 째 접근 방식이 있습니다. (<code>Optional&lt;T&gt;</code>)</p><p><code>Optional&lt;T&gt;</code>는 개념적으로 T를 반환하지만 그렇게 할 수 없는 경우에는 대신에 <code>Optional&lt;T&gt;</code>를 반환합니다. <code>Optional</code>의 반환 값은 예외를 던지거나, null을 던지는 거보다 유연하고 쉽습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션에서 최대 밧 반환, 비어있는 경우 예외 발생</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static &lt;E extends Comparable&lt;E&gt;&gt; E max(Collection&lt;E&gt; c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (c.isEmpty())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new IllegalArgumentException(&quot;Empty collection&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  E  9result = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (E e : c)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (result == null || e.compareTo(result) &gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      result = Objects.requireNonNull(e);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 <code>Optional</code>릍 통해서 수정할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static &lt;E extends Comparable&lt;E&gt;&gt; Optional&lt;E&gt; max(Collection&lt;E&gt; c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (c.isEmpty())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Optional.empty();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  E result = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (E e : c)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (result == null || e.compareTo(result) &gt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      result = Objects.requireNonNull(e);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return Optional.of(result);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다만, <code>Optional-returning</code> 메서드에서 null 값을 반환하면 안됩니다. 이는 <code>Optional</code>의 목적을 무시하는 것입니다. 또한 <code>Optional</code>을 통해서 다른 메서드에서도 사용할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션의 최대 값을 Optional &lt;E&gt;로 반환-스트림을 사용</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static &lt;E extends Comparable &lt;E &gt;&gt; Optional &lt;E&gt; max (Collection &lt;E&gt; c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return c.stream().max(Comparator.naturalOrder());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 선택 사항을 사용하여 선택한 기본값 제공</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">String lastWordInLexicon = max(words).orElse( &quot;No words ...&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 선택 사항을 사용하여 선택한 예외 발생</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Toy myToy = max (toys).orElseThrow(TemperTantrumException::new);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 반환 값이 있다는 것을 알고있을 때 선택 사항 사용</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Element lastNobleGas = max(Elements.NOBLE_GASES).get() ;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위의 이러한 방법들을 통해서 적절한 해결책을 찾지 못한 경우에는 <code>Optional</code>의 <code>isPresent().true</code>를 사용하는 것도 나쁘지 않습니다. 또한 snippset을 사용하는 것도 좋습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// snippset 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Optional&lt;ProcessHandle&gt; parentProcess = ph.parent();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(&quot;Parent PID: &quot; + (parentProcess.isPresent() ?</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String.valueOf(parentProcess.get().pid()) : &quot;N/A&quot;));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Optional의 map 기능을 사용한 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">System.out.println(&quot;Parent PID: &quot; +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ph.parent().map(h -&gt; String.valueOf(h.pid())).orElse(&quot;N/A&quot;));</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>자바의 Stream을 사용하는 경우, 아래처럼 <code>Optional</code>을 적용할 수 있습니다. (Java9에서는 스트림에 <code>Optional</code>이 추가되었습니다.)</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Java 8</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">streamOfOptionals</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .filter(Optional::isPresent)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .map(Optional::get)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Java 9</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">streamOfOptionals</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  .flatMap(Optional::stream)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그러나 모든 반환 유형에서 적용되는 것은 아닙니다. <code>Collections</code>, <code>Maps</code>, <code>Streams</code>, <code>Arrays</code>, <code>Optionals</code> 을 포함하는 컨테이너 유형은 옵션으로 래핑해서는 안됩니다. 이 경우에는 <code>Optional&lt;List&lt;T&gt;&gt;</code>를 반환하는 것 보다는 <code>List&lt;T&gt;</code>를 반환하는 것이 좋습니다.</p><p>결과를 반환 할 수 없는 경우, <code>Optional&lt;T&gt;</code>를 반환하는 메서드를 선언해야하며, 결과가 반환되지 않으면 클라이언트가 특별한 처리를 수행해야합니다.</p><p>boxed primitive type을 포함하는 옵셔널을 반환하는 것은, 비용이 매우 큽니다. 따라서 <code>Boolean</code>, <code>Byte</code>, <code>Character</code>, <code>Short</code>, <code>Float</code> 형을 제외하고는 <code>boxed primitive type</code>을 Optional로 반환하면 안됩니다.</p><p>앞서 Optional 을 반환하고, 치를 처리하는 방법에 대해 설명했습니다. 이를 다른 가능한 사용에 대해 이야기 하지 않은 이유는, 이를 잘 못 사용하면, 불필요한 복잡성을 만들기 때문입니다. Collection이나 array의 key, value, element 로 Optional을 사용하는 것은 적절하지 않습니다.</p><p>이를 정리하면, <strong>항상 값을 반환할 수 없는 메서드를 작성하고 메서드 사용자가 호출 할 때마다, 이 가능성을 고려하는 것을 중요하다고 생각하면 <code>Optional</code>을 사용하는 것이 좋습니다.</strong> 그러나, 이 경우 성능에 대한 부분을 고려해야합니다. 성능이 중요한 메서드의 경우에는 null을 반환하거나, throw하는 것이 더 좋을 수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-56-노출된-모든-api-요소에-대한-문서-주석을-작성합니다"></a>Item 56. 노출된 모든 API 요소에 대한 문서 주석을 작성합니다.<a class="hash-link" href="#item-56-노출된-모든-api-요소에-대한-문서-주석을-작성합니다" title="Direct link to heading">#</a></h2><p>API를 사용할 수 있으려면 문서화해야합니다. 전통적으로 API 문서는 수동으로 생성되었으며 코드와 동기화를 유지하는 어려운 일입니다.</p><p>문서 주석 규칙은 공식적으로 언어의 일부는 아니지만 모든 Java 프로그래머가 알아야하는 사실상의 API를 구성합니다. 대표적인 문서 태그로 Java 9의 <code>{@index}</code>, Java 8의 <code>{@implSpec}</code>, Java 5의 <code>{@literal}</code>, <code>{@code}</code> 등이 있습니다.</p><p>API를 올바르게 문서화하려면 내보낸 모든 클래스, 인터페이스, 생성자, 메소드 및 필드 선언 앞에 주석을 붙여야합니다. 또한 메서드에 대한 문서 주석은 메서드와 클라이언트 간의 계약을 간결하게 설명해야합니다.</p><p>이를 표현한 코드는 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// ({@code index &lt; 0 || index &gt;= this.size()})</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">E get(int index);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> /* 이 컬렉션이 비어 있으면 true를 반환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * @implSpec</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * 이 구현은 {@code this.size () == 0}을 반환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * @return true if this collection is empty</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public boolean isEmpty () {...}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><strong>문서 주석은 소스 코드와 생성된 문서 모두에서 읽을 수 있어야합니다.</strong> 또한, 클래스 또는 인터페이스의 두 멤버 또는 생성자는 동일한 요약 설명을 가져서는 안됩니다.</p><p>이를 사용한 예제 코드는 아래와 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">/**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> * A suspect, such as Colonel Mustard or {@literal Mrs. Peacock}.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public enum Suspect { ... }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">* This method complies with the {@index IEEE 754} standard.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> /** 키를 값에 매핑하는 객체. 맵은 중복 키를 포함 할 수 없습니다</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * 각 키는 최대 하나의 값에 매핑 할 수 있습니다. (나머지는 생략 됨)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * @param &lt;K&gt;이 맵에서 관리하는 키 유형</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * @param &lt;V&gt; 매핑 된 값 유형</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public interface Map&lt;K, V&gt; { ... }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Enum 형을 문서화할 때는 상수와, 유형 및 공용 메서드를 문서화해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> /**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * 심포니 오케스트라의 악기 섹션.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public enum OrchestraSection {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /** 플루트, 클라리넷, 오보에와 같은 목 관악기. */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  WOODWIND,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /** 프렌치 호른 및 트럼펫과 같은 금관 악기. */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BRASS,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /** 팀파니 및 심벌즈와 같은 타악기. */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PERCUSSION,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /** 바이올린과 첼로와 같은 현악기. */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  STRING;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain"> /**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * 주석이 달린 메서드가 통과하려면 지정된 예외를 throw해야하는 테스트 메서드임을 나타냅니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@Retention (RetentionPolicy.RUNTIME)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@Target (ElementType.METHOD)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public @interface ExceptionTest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> /**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * 통과하기 위해 주석이 달린 테스트 메서드가 throw해야하는 예외입니다 .</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  * (테스트는 이 클래스 객체가 설명하는 유형의 하위 유형을 던질 수 있습니다.)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Class &lt;? Throwable&gt; value ();를 확장합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>또한 API의 두가지 측면은 스레드 안전성고 직렬화 가능성입니다. 또한 <strong>클래스 또는 정적 메서드가 스레드로부터 안전한지 여부에 관계없이, 스레드 안전성을 문서화</strong>해야합니다. 이를 문서화 해야지, 이후에 관리를 하기 편합니다.</p><p>이를 요약하면 문서 주석은 API를 문서화하는 가장 효과적인 방법입니다. <strong>내보낸 모든 API 요소에 대한 사용은 필수로 간주해야합니다. 따라서 표준 규칙을 준수하는 일관된 스타일을 채택해야합니다.</strong></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/effective-java/ch8.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-09-18T22:10:08.000Z" class="lastUpdatedDate_1WI_">9/18/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch7"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 7. 람다와 스트림</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch9"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">9. 일반적인 프로그래밍 원칙 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-49-매개-변수의-유효성을-확인합니다" class="table-of-contents__link">Item 49. 매개 변수의 유효성을 확인합니다.</a></li><li><a href="#item-50-필요할-때-방어적-사본을-생성합니다" class="table-of-contents__link">Item 50. 필요할 때, 방어적 사본을 생성합니다.</a></li><li><a href="#item-51-메서드-이름을-신중하게-설계합니다" class="table-of-contents__link">Item 51. 메서드 이름을 신중하게 설계합니다.</a><ul><li><a href="#메서드-이름을-신중하게-선택해야합니다" class="table-of-contents__link">메서드 이름을 신중하게 선택해야합니다.</a></li><li><a href="#편리한-방법을-제공하는데-너무-과하게-사용하면-안됩니다" class="table-of-contents__link">편리한 방법을 제공하는데 너무 과하게 사용하면 안됩니다.</a></li><li><a href="#너무-긴-매개변수는-피합니다" class="table-of-contents__link">너무 긴 매개변수는 피합니다.</a></li><li><a href="#매개변수-유형의-경우-클래스보다-인터페이스를-선호합니다" class="table-of-contents__link">매개변수 유형의 경우, 클래스보다 인터페이스를 선호합니다.</a></li><li><a href="#boolean의-의미가-메서드-이름에서-명확하지-않으면boolean-매개-변수-보다는-요소가-두개인-enum-형을-쓰는-것이-중요합니다" class="table-of-contents__link">boolean의 의미가 메서드 이름에서 명확하지 않으면,boolean 매개 변수 보다는 요소가 두개인 Enum 형을 쓰는 것이 중요합니다.</a></li></ul></li><li><a href="#item-52-오버로딩을-신중하게-사용합니다" class="table-of-contents__link">Item 52. 오버로딩을 신중하게 사용합니다.</a></li><li><a href="#item-53-varargs를-신중하게-사용합니다" class="table-of-contents__link">Item 53. Varargs를 신중하게 사용합니다.</a></li><li><a href="#item-54-null이-아닌-빈-컬렉션이나-배열을-반환합니다" class="table-of-contents__link">Item 54. Null이 아닌 빈 컬렉션이나 배열을 반환합니다.</a></li><li><a href="#item-55-optionals를-신중하게-반환합니다" class="table-of-contents__link">Item 55. Optionals를 신중하게 반환합니다.</a></li><li><a href="#item-56-노출된-모든-api-요소에-대한-문서-주석을-작성합니다" class="table-of-contents__link">Item 56. 노출된 모든 API 요소에 대한 문서 주석을 작성합니다.</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.43dc5b53.js"></script>
<script src="/til/assets/js/main.980de010.js"></script>
</body>
</html>