<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">12. 직렬화, Serialization | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/effective-java/ch12"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="12. 직렬화, Serialization | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="아래에서는 자바 직렬화의 위험성과 이를 최소화하는 방법을 중점으로 합니다."><meta data-react-helmet="true" property="og:description" content="아래에서는 자바 직렬화의 위험성과 이를 최소화하는 방법을 중점으로 합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/effective-java/ch12"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch12" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch12" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.1efdb204.js" as="script">
<link rel="preload" href="/til/assets/js/main.1611beab.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch11">11. 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch12">12. 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch13">13. 서브클래싱과 서브타이핑</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">12. 직렬화, Serialization</h1></header><div class="markdown"><p>아래에서는 자바 직렬화의 위험성과 이를 최소화하는 방법을 중점으로 합니다.</p><ul><li><a href="https://azderica.github.io/java-serialize/" target="_blank" rel="noopener noreferrer">자바 직렬화란</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-85-자바-직렬화의-대안을-찾습니다"></a>Item 85. 자바 직렬화의 대안을 찾습니다.<a class="hash-link" href="#item-85-자바-직렬화의-대안을-찾습니다" title="Direct link to heading">#</a></h2><p>최초의 자바에 직렬화가 추가되었을 때는 다소 위험한 것으로 알려졌습니다. 이는 보이지 않는 생성자였고 API와 구현 사이의 경계가 흐려졌습니다. 또한 정확성, 성능, 보안 및 유지 관리 문제가 발생할 가능성이 있어서입니다.</p><p>그러나 근본적인 자바 직렬화의 위험은 아래와 같습니다.</p><ul><li>공격 범위가 너무 넓습니다.</li><li>지속적으로도 더 넓어져서 방어하기도 어렵습니다.</li></ul><p>이러한 문제들의 원인은 <code>OutputInputStream</code>의 <code>readObject</code> 메서드가 호출되면서 객체 그래프가 역직렬화(deserialization)가 되기 때문입니다.</p><p>바이트 스트림을 역직렬화하는 과정에서 <code>readObject</code> 메서드는 그 타입들 안의 모드 코드를 수행할 수 있습니다. (즉, 타입들의 코드 전체가 악의적인 공격 범위에 들어갑니다.)</p><p><strong>역직렬화 과정에서 호출되어 잠재적인 위험한 동작을 수행하는 메서드</strong>를 <strong>가젯(gadget)</strong> 이라고 합니다. 하나의 가젯이 여러개의 가젯이 마음대로 코드를 수행할 수 있기 때문에 아주 신중하게 제작된 바이트 스트림만 역직렬화를 해야합니다.</p><p>역직렬화에 시간이 오래걸리는 짧은 스트림을 <strong>역직렬화 폭탄(deserialization bomb)</strong> 이라고 합니다. 아래는 그 예시입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static byte[] bomb() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Set&lt;Object&gt; root = new HashSet&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Set&lt;Object&gt; s1 = root;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Set&lt;Object&gt; s2 = new HashSet&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int i = 0; i &lt; 100; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Set&lt;Object&gt; t1 = new HashSet&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Set&lt;Object&gt; t2 = new HashSet&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    t1.add(&quot;foo&quot;); // Make t1 unequal to t2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    s1.add(t1);  s1.add(t2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    s2.add(t1);  s2.add(t2);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    s1 = t1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    s2 = t2;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return serialize(root); // Method omitted for brevity</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 호출해버리면, 깊이가 100단계까지 호출됩니다. 이를 역직렬화 하려면 2^100 번 넘게 호출해야합니다.</p><p>이 문제를 해결하기 위해서는 자바 직렬화 대신 <strong>크로스-플랫폼 구조화된 데이터 표현 방법</strong> 을 사용하는 것이 좋습니다. 예로는 JSON, protocol buffer 등이 있습니다. 프로토콜 버퍼는 이진 표현이라 효율이 훨씬 더 높으며, JSON은 텍스트 기반이라 사람이 읽을 수 있는 장점이 있습니다.</p><p>직렬화를 대체할 수 없다면, 반드시 <strong>신뢰할 수 있는 데이터만 역직렬화</strong> 해야합니다. 직렬화를 피할 수 없고, 역직렬화한 데이터가 안전하지 확실할 수 없다면 객체 역직렬화 필터링을 사용하면 됩니다.</p><p>다만, 직렬화는 위험 요소가 많습니다. 시간과 노력을 쓰더라도, JSON 등으로 마이그레이션하는 것을 추천합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-86-serializable을-구현할지에-대해-신중히-결정합니다"></a>Item 86. <code>Serializable</code>을 구현할지에 대해 신중히 결정합니다.<a class="hash-link" href="#item-86-serializable을-구현할지에-대해-신중히-결정합니다" title="Direct link to heading">#</a></h2><p>직렬화 가능한 클래스는 <code>Serializable</code>을 구현하면 됩니다. 이를 구현하는 것은 싶지만, 구현을 했을 때의 대가는 매우 비쌉니다. 구현한 순간부터 많은 위험성을 가지게 되고, 확장성을 잃게 됩니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬화-클래스의-단점"></a>직렬화 클래스의 단점<a class="hash-link" href="#직렬화-클래스의-단점" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-릴리즈가-된-이후-유연성을-감소합니다"></a>1. 릴리즈가 된 이후, 유연성을 감소합니다.<a class="hash-link" href="#1-릴리즈가-된-이후-유연성을-감소합니다" title="Direct link to heading">#</a></h4><p><code>Serializable</code>을 구현하면 직렬화 형태도 하나의 공개 API가 됩니다. 직렬화 형태는 적용 당시 클래스의 내부 구현 방식에 종속적입니다. 또한 클래스의 private과 package 인스턴스 필드마저 API로 공개되기 때문에 캡슐화도 깨집니다.</p><p>클래스의 내부 구현을 수정할 시, 원래의 직렬화 형태와 달라집니다. 구버전의 인스턴스를 직렬화한 후 신버전 클래스로 역직렬화를 시도하면 오류가 발생합니다.</p><p>한편 수정을 어렵게 만드는 요소로 <code>SerialVersionUID</code>를 뽑을 수 있습니다. 모든 직렬화된 클래스는 고유 식별 번호를 부여받으며, 클래스 내부에 직접 명시하지 않는 경우에 시스템이 런타임에 자동으로 생성됩니다. <code>SUID</code>를 생성할 때는 클래스의 이름, 구현하도록 선언한 인터페이스 등이 고려됩니다. 따라서 나중에 수정한다면 <code>SUID</code> 값도 변하게 됩니다. 이러한 자동으로 생성된 값은 호환성이 쉽게 깨집니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-버그와-보안에-취약합니다"></a>2. 버그와 보안에 취약합니다.<a class="hash-link" href="#2-버그와-보안에-취약합니다" title="Direct link to heading">#</a></h4><p>자바에서는 객체를 생성자를 통해서 만듭니다. 그러나 직렬화는 이러한 언어의 기본 방식을 우회하면서 객체를 생성합니다. 역직렬화는 일반 생성자의 문제가 발생하는 숨은 생성자입니다. 역직렬화를 사용하면 불변식이 깨질 수 있으며 허가되지 않은 접근에 쉽게 노출될 수 있습니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-테스트-부담-요소가-증가합니다"></a>3. 테스트 부담 요소가 증가합니다.<a class="hash-link" href="#3-테스트-부담-요소가-증가합니다" title="Direct link to heading">#</a></h4><p>직렬화 가능한 클래스가 수정되면, 새로운 버전의 인스턴스를 직렬화 한후에 구버전으로 역직렬화가 가능한지 테스트해야합니다. 물론 그 반대 경우도 테스트 해야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="serializable-구현"></a><code>Serializable</code> 구현<a class="hash-link" href="#serializable-구현" title="Direct link to heading">#</a></h3><p><code>Serializable</code> 구현 여부는 쉽게 결정할 것이 아닙니다. 클래스를 설계할 때마다 따르는 이득과 비용을 잘 고려해야합니다. 에를 들어 <code>BigInteger</code>과 <code>Instant</code> 같은 값 클래스와 컬렉션 클래스는 <code>Serializable</code>을 구현하였으며 스레드 풀처럼 동작하는 객체를 표현한 클래스는 대부분 구현하지 않았습니다.</p><p>따라서 <code>Serializable</code>을 구현할 때는 매우 신중하게 해야합니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상속-목적으로-설계된-클래스와-대부분의-인터페이스는-serializable을-구현하면-안됩니다"></a>상속 목적으로 설계된 클래스와 대부분의 인터페이스는 <code>Serializable</code>을 구현하면 안됩니다.<a class="hash-link" href="#상속-목적으로-설계된-클래스와-대부분의-인터페이스는-serializable을-구현하면-안됩니다" title="Direct link to heading">#</a></h4><p>클래스를 확장하거나 인터페이스를 구현하는 대상에게 위험성을 제공합니다. 하지면 <code>Serializable</code>를 구현한 클래스만 지원하는 프레임워크를 사용해야한다면 어쩔 수 없습니다. 직렬화와 확장이 모두 가능한 클래스를 만들어야한다면 하위 클래스에서 <code>finalize</code> 메서드를 재정의를 방지해야합니다. 일반적으로는 재정의하고 <code>final</code> 키워드를 붙이면 되며, 인스턴스 필드 중 기본값으로 초기화되어서 위배되는 불변식이 있는 경우에는 아래와 같은 메서드를 추가합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private void readObjectNoData() throws InvalidObjectException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  throw new InvalidObjectException(&quot;Stream data required&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="내부-클래스는-직렬화를-구현하면-안됩니다"></a>내부 클래스는 직렬화를 구현하면 안됩니다.<a class="hash-link" href="#내부-클래스는-직렬화를-구현하면-안됩니다" title="Direct link to heading">#</a></h4><p>내부 클래스는 바깥 인스턴스의 참조와 유효 범위에 속한 지역변수를 저장하기 위한 필드가 필요합니다. 그렇기에 기본 직렬화 형태가 명확하지 않습니다. 이 필드들은 컴파일러가 자동으로 추가를 하는데, 이 필드들이 어떻게 추가될 지 모릅니다. (정적 멤버 클래스는 다릅니다.)</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-87-커스텀-직렬화-형태를-고려합니다"></a>Item 87. 커스텀 직렬화 형태를 고려합니다.<a class="hash-link" href="#item-87-커스텀-직렬화-형태를-고려합니다" title="Direct link to heading">#</a></h2><p>클래스가 <code>Serializable</code> 을 구현하고 기본 직렬화 형태를 사용한다면 현재의 구현에 종속적이게 됩니다. 즉, 기본 직렬화 형태를 버릴 수 없게 됩니다. 따라서 유연성, 성능, 정확성과 같은 측면을 고민한 후에 합당하다고 생각되는 경우에 한해 기본 직렬화 형태를 사용해야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="이상적인-직렬화-형태"></a>이상적인 직렬화 형태<a class="hash-link" href="#이상적인-직렬화-형태" title="Direct link to heading">#</a></h3><p>기본 직렬화 형태는 객체가 포함한 데이터 뿐만 아니라, 그 객체를 시작으로 접근할 수 있는 모든 객체와 객체들의 연결된 정보까지 나타냅니다. 이상적인 직렬화의 형태는 물리적인 모습과 독립된 논리적인 모습만을 표현해야합니다. 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태를 선택해도 무방합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Name implements Serializable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @serial</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final String lastName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @serial</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final String firstName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @serial</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final String middleName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이름은 논리적으로 성, 이름, 중간 이름으로 3개의 문자열로 구성되는데 위 클래스의 인스턴스 필드들은 논리적인 구성 요소를 정확하게 반영합니다.</p><p>기본 직렬화 형태가 적합해도 불변식 보장과 보안을 위해서 <code>readObject</code> 메서드를 제공해야하는 경우가 많습니다. 앞에 있는 코드의 경우, lastName과 firstName 필드는 null이 아님을 <code>readObject</code> 메서드가 보장해야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="부적절한-직렬화-형태"></a>부적절한 직렬화 형태<a class="hash-link" href="#부적절한-직렬화-형태" title="Direct link to heading">#</a></h3><p>객체의 물리적 표현과 논리적 내용이 같은 경우, 기본 직렬화 형태를 선택해도 됩니다. 그러나 적절하지 않는 경우도 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public final class StringList implements Serializable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int size = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Entry head = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static class Entry implements Serializable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    String data;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Entry next;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Entry previous;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ... 생략</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위의 클래스 경우에는 여러 문제점이 있습니다. 논리적으로 문자열을 표현했고 물리적으로는 문자열들을 이중 연결 리스트로 표현했습니다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드에 연결된 노드들까지 모두 표현하기 때문에 다음과 같은 문제가 발생합니다.</p><ul><li>공개 API가 현재의 내부 표현 방식에 종속적이게 됩니다.<ul><li>향후 버전에서 연결 리스트를 사용하지 않더라도, 관련 처리가 필요해집니다.</li><li>코드를 제거할 수가 없습니다.</li></ul></li><li>사이즈가 큽니다<ul><li>기본 직렬화를 사용할 때 각 노드의 연결 정보까지 모두 포함될 것입니다.</li><li>이는 내부 구현이며 직렬화 형태에 가치가 없으며 네트워크 전송 속도를 느리게 합니다.</li></ul></li><li>시간이 많이 걸립니다.<ul><li>직렬화 로직은 객체 그래프의 위상에 관한 정보를 알 수 없으니, 직접 순회할 수 밖에 없습니다.</li></ul></li><li>스택 오버플로를 발생시킵니다.<ul><li>기본 직렬화 형태는 객체 그래프를 재귀 순회하며, 호출 정도가 많아지면 스택이 감당을 하지 못합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="합리적인-직렬화-형태"></a>합리적인 직렬화 형태<a class="hash-link" href="#합리적인-직렬화-형태" title="Direct link to heading">#</a></h3><p>이를 수정해서 합리적인 직렬화 형태는 다음과 같습니다. 단순히 리스트가 포함한 문자열의 개수와 문자열만 있는 것이 좋습니다. 위의 부적절한 코드를 개선한 형태입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public final class StringList implements Serializable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private transient int size = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private transient Entry head = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static class Entry {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    String data;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Entry next;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Entry previous;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public final void add(String s) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void writeObject(ObjectOutputStream stream) throws IOException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    stream.defaultWriteObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    stream.writeInt(size);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (Entry e = head; e != null; e = e.next) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      s.writeObject(e.data);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    stream.defaultReadObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int numElements = stream.readInt();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for (int i = 0; i &lt; numElements; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      add((String) stream.readObject());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // ... 생략</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위 코드에서 특별한 키워드인 <code>transient</code>를 확인할 수 있습니다. <code>transient</code> 키워드가 붙은 필드는 기본 직렬화 형태에 포함되지 않습니다. 클래스의 모든 필드가 <code>transient</code>로 선언되어 있더라도 <code>writeObject</code> 와 <code>readObject</code> 메서드는 <code>defaultWriteObject</code>와 <code>defaultReadObject</code> 메서드를 호출합니다. 직렬화 명세에서는 이 과정을 무조건 진행할 것을 요구합니다. 이렇게 함으로써 향후 릴리즈에서 <code>transient</code>가 아닌 필드가 추가되더라도 상위와 하위 모두 호환이 가능하기 때문입니다.</p><p>신버전의 인스턴스를 직렬화하고 구버전으로 역직렬화할시, 새로 추가된 필드는 무시됩니다. 그리고 구버전의 <code>readObject</code> 메서드에서 <code>defaultReadObject</code>를 호출하지 않는다면 역직렬화 과정에서 <code>StreamCorruptedException</code>이 발생합니다.</p><p>기본 직렬화 여부에 관계없이 <code>defaultWriteObject</code> 메서들 호출하면 <code>transient</code>로 선언하지 않은 모든 필드는 직렬화됩니다. 따라서, <code>transient</code> 키워드를 선언해도 되는 필드라면 붙이는 것이 좋습니다. 즉, 논리적 상태와 무관한 필드라고 판단될 때 생략하는 것이 좋습니다.</p><p>기본 직렬화를 사용한다면, 역직렬화를 할 때는 <code>transient</code> 필드는 기본 값으로 초기화됩니다. 기본 값을 변경해야 하는 경우에는 <code>readObject</code> 메서드에서 <code>defaultReadObject</code> 메서드를 호출한 다음 원하는 값으로 지정하면 됩니다. 아니면 값을 처음 사용할 때 초기화해도 됩니다.</p><p>기본 직렬화 사용 여부와 상관없이 직렬화에도 동기화 규칙을 적용해야합니다. 예를 들어 모든 메서드를 <code>synchronized</code> 로 선언하여 스레드에 안전하게 만든 객체에 기본 직렬화를 사용한다면 <code>writeObject</code> 도 아래처럼 수정해야 합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private synchronized void writeObject(ObjectOutputStream stream) throws IOExceptions {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  stream.defaultWriteObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>어떤 직렬화 형태를 선택하더라도, 직렬화가 가능한 클래스에는 <code>SerialVersionUID(SUID)</code> 를 명시적으로 선언해야 합니다. 물론 선언하지 않더라도 자동 생성되지만 런타임에 이 값을 생성하느라 복잡한 연산을 수행해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 무작위로 고른 long 값</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private static final long serialVersionUID = 0204L;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다만, SUID가 꼭 유니크할 필요가 없습니다. 다만 이 값이 변경되면 기존 버전 클래스와의 호환을 끊게 됩니다. 따라서 호환성을 끊는 경우가 아니라면 SUID 값을 변경해서는 안됩니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-88-readobject-메서드는-방어적으로-작성합니다"></a>Item 88. <code>readObject</code> 메서드는 방어적으로 작성합니다.<a class="hash-link" href="#item-88-readobject-메서드는-방어적으로-작성합니다" title="Direct link to heading">#</a></h2><p>지난 Item 50에서는 적시에 방어적 복사본을 만들라는 규칙이 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public final class Period {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final Date start;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final Date end;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  /**</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   * @param  start the beginning of the period</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   * @param  end the end of the period; must not precede start</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   * @throws IllegalArgumentException if start is after end</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   * @throws NullPointerException if start or end is null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">   */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Period(Date start, Date end) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.start = new Date(start.getTime());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.end   = new Date(end.getTime());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (this.start.compareTo(this.end) &gt; 0) throw new IllegalArgumentException(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      start + &quot; after &quot; + end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Date start () { return new Date(start.getTime()); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Date end () { return new Date(end.getTime()); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public String toString() { return start + &quot; - &quot; + end; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Remainder omitted</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>물리적 표현과 논리적 표현이 같기 때문에 기본 직렬화 형태를 사용해도 된다고 판단됩니다. 따라서 <code>Serializable</code>만 구현하면 될 것 같습니다. 하지만 <code>readObject</code>가 새로운 public 생성자이기 때문에 불변식을 보장할 수 없습니다.</p><p><code>readObject</code> 메서드도 생성자와 같은 수준으로 주의해야합니다. 인수가 유효한지 검사하고, 매개변수를 방어적으로 복사해야합니다. 그렇지 않으면 불변식을 깨뜨리는 공격에 취약합니다.</p><p><code>readObject</code> 메서드는 매개변수로 바이트 스트림을 받는 생성자로 볼 수 있습니다. 일반적으로 보통 바이트 스트림은 정상적으로 생성된 인스턴스를 직렬화해서 만들어집니다. 하지만, 불변을 깨트릴 목표로 만들어진 바이트 스트림을 받으면 문제가 발생합니다. 이러한 경우는 정상적으로 만들어 낼 수 없는 객체를 생성합니다.</p><p>아래는 그 잘못된 코드입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class BogusPeriod {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Byte stream couldn&#x27;t have come from a real Period instance!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static final byte[] serializedForm = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    0x2b, 0x4f, 0x46, (byte)0xc0, (byte)0xf4, 0x02, 0x00, 0x02,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Period p = (Period) deserialize(serializedForm);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 바이트 스트림으로부터 객체를 만들어 변환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static Object deserialize(byte[] sf) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return new ObjectInputStream(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        new ByteArrayInputStream(sf)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ).readObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    } catch (IOException | ClassNotFoundException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      throw new IllegalArgumentException(e);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>해당 코드를 실행하면, 불변식이 깨지는 객체가 만들어집니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 방어하기 위해서는 <code>readObject</code> 메서드가 <code>defaultReadObject</code>를 호출하게 한 후 역직렬화된 객체가 유효한지 검사해야합니다. 여기서 유효성 검사에 실패한다면 <code>InvalidObjectException</code>을 던져 잘못된 역직렬화가 발생하는 것을 막아야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 불변식을 만족하는지 검사한다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (start.compareTo(end) &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new InvalidObjectException(start + &quot;after&quot; + end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>그러나 이러한 코드에서도 바이트 스트림 끝에 <code>private Date</code> 필드로의 참조를 추가하면 가변적인 Period 인스턴스를 만들어 낼 수 있습니다. 공격자가 역직렬화를 통해서 바이트 스트림 끝의 참조 값을 읽으면 Period의 내부 정보를 얻을 수 있습니다. 이 참조를 이용해서 인스턴스를 수정할 수 있기 때문에 불변이 아닙니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class MutablePeriod {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public final Period period;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public final Date start;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public final Date end;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public MutablePeriod() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ByteArrayOutputStream bos = new ByteArrayOutputStream();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ObjectOutputStream out = new ObjectOutputStream(bos);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      out.writeObject(new Period(new Date(), new Date()));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      /*</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       * 악의적인 &#x27;이전 객체 참조&#x27;, 즉 내부 Date 필드로의 참조를 추가한다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       * 상세 내용은 자바 객체 직렬화 명세의 6.4절 참조.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">       */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      byte[] ref = { 0x71, 0, 0x7e, 0, 5 };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bos.write(ref); // 시작(start) 필드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ref[4] = 4; // 참조 #4</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      bos.write(ref); // 종료(end) 필드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      period = (Period) in.readObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      start = (Date) in.readObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      end = (Date) in.readObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    } catch (IOException | ClassNotFoundException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      throw new AssertionError(e);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    MutablePeriod mp = new MutablePeriod();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Period p = mp.period;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Date pEnd = mp.end;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 시간을 되돌린다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    pEnd.setYear(78);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 60년대로 돌아간다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    pEnd.setYear(69);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(p);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Wed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>해당 원인은 <code>Period</code>의 <code>readObject</code> 메서드가 방어적 복사를 하지 않음에 있습니다. <strong>역직렬화를 할 때는 클라이언트가 접근해서는 안되는 객체 참조를 갖는 필드는 모두 방어적으로 복사를 해야합니다.</strong></p><p><code>Period</code>를 공격으로부터 보호하기 위해 방어적 복사를 유효성 검사보다 먼저 수행해야합니다. 또한 Date의 <code>clone</code> 메서드는 사용되지 않습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  s.defaultReadObject();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 가변 요소들을 방어적으로 복사한다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  start = new Date(start.getTime());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  end = new Date(end.getTime());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 불변식을 만족하는지 검사한다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if (start.compareto(end) &gt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new InvalidObjectException(start + &quot; after &quot; + end);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Fri May 31 01:01:06 KST 2019 - Fri May 31 01:01:06 KST 2019</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Fri May 31 01:01:06 KST 2019 - Fri May 31 01:01:06 KST 2019</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>한편 <code>final</code> 필드는 방어적 복사가 불가능하니 주의해야합니다. 따라서 start와 end 필드에서 <code>final</code> 키워드를 제거해야합니다. 공격을 받는 것보다는 더 나은 방향입니다.</p><p><code>transient</code> 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사를 없이도 필드에 대입하는 public 생성자를 추가해도 괜찮다고 판단되면 기본 <code>readObject</code>를 사용해도 됩니다. 아닌 경우에는 직접 <code>readObject</code> 메서드를 정의해서 생성자에서 수행했어야 할 모든 유효성 검사와 방어적 복사를 수행해야합니다. 이때 가장 추천되는 것은 <code>직렬화 프록시 패턴</code>을 사용하는 것입니다. 이는 역직렬화를 안전하게 만드는데 필요한 노력을 줄여줍니다,</p><p><code>final</code>이 아닌 직렬화 가능 클래스라면 생성자처럼 <code>readObject</code> 메서드도 재정의(Overriding) 가능한 메서드를 호출해서는 안됩니다. 하위 클래스의 상태가 완전히 직렬화되기 전에 하위 클래스에서 재정의된 메서드가 실행되기 때문입니다.</p><p>결론적으로 다음과 같이 요약할 수 있습니다.</p><ul><li><code>readObject</code> 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임합니다.</li><li><code>readObject</code> 메서드는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어야합니다.<ul><li>이 바이트 스트림이 항상 직렬화된 인스턴스라고 믿으면 안됩니다.</li></ul></li><li>안전한 <code>readObject</code> 메서드를 작성하기 위해서는 아래를 준수합니다.<ul><li><code>private</code> 여야 하는 객체 참조 필드는 각 필드가 가리키는 객체를 방어적으로 복사합니다.</li><li>모든 불변식을 검사하고 어긋난다면, <code>InvalidObjectException</code>을 던집니다.</li><li>역직렬화 이후에 객체 그래프 전체의 유효성을 검사해야 한다면 <code>ObjectInputValidation</code>을 던집니다.</li><li>오버라이딩이 가능한 메서드는 호출하지 않는 것이 좋습니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-89-인스턴스-수를-통제해야한다면-readresolve보다는-enum-타입을-사용합니다"></a>Item 89. 인스턴스 수를 통제해야한다면 <code>readResolve</code>보다는 enum 타입을 사용합니다.<a class="hash-link" href="#item-89-인스턴스-수를-통제해야한다면-readresolve보다는-enum-타입을-사용합니다" title="Direct link to heading">#</a></h2><p>앞에서 싱글톤 패턴의 예저를 보았는데 이 방법은 <code>public static final</code> 필드를 사용하는 방식입니다. 생성자는 <code>private</code> 접근 지정자로 선언하여 외부로부터 감추고, <code>INSTANCE</code>를 초기화할 때 한 번만 호출됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private class Elvis {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static final Elvis INSTANCE = new Elvis();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Elvis() { }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>하지만, 이 클래스는 <code>Serializable</code>을 구현하게 되는 순간 싱글턴이 아닙니다. 기본 직렬화를 쓰지 않거나 명시적인 <code>readObject</code> 메서드를 제공해도 소용이 없습니다. 어떤 <code>readObject</code> 메서드를 사용해도 초기화될 때 만들어진 인스턴스와 다른 인스턴스를 반환하게 됩니다.</p><p>이때 <code>readResolve</code> 메서드를 사용하면, <code>readObject</code> 메서드가 만든 인스턴스를 다른 것으로 대체할 수 있습니다. 이때 <code>readObject</code>가 만들어낸 인스턴스는 가비지 컬렉터의 대상이 됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private Object readResolve() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return INSTANCE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>한편 여기서 나온 <code>Elvis</code> 인스턴스의 직렬화 형태는 아무런 실 데이터를 가질 필요가 없으니 모든 인스턴스 필드는 <code>transient</code>로 선언해야합니다. 그러므로 <code>readResolve</code> 메서드를 인스턴스의 통제 목적으로 이용한다면 모든 필드는 <code>transient</code>로 선언하는 것이 좋습니다. 그렇지 않으면 역직렬화 과정에서 역직렬화된 인스턴스를 가져와서 싱글턴이 깨지게 됩니다.</p><p>이를 해결하는 방법은 <code>enum</code>입니다. 자바가 선언한 상수 외에 다른 객체가 없음을 보장해주기 때문입니다. 물론 <code>AccessibleObject.setAccessible</code> 메서드와 같은 리플렉션을 사용하는 경우는 예외입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public enum Elvis {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSTANCE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>물론 인스턴스 통제를 위해 <code>readResolve</code> 메서드를 사용하는 것이 중요할 때도 있습니다. 직렬화 가능 인스턴스 통제 클래스를 작성해야 할 때, 컴파일 타임에는 어떤 인스턴스들이 있는지 모를 수 있습니다. 이때는 <code>Enum</code> 타입으로 표현하는 것이 불가능하기 때문에 <code>readResolve</code> 메서드를 사용할 수 밖에 없습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토합니다"></a>Item 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토합니다.<a class="hash-link" href="#item-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토합니다" title="Direct link to heading">#</a></h2><p><code>Serializable</code>을 <code>implements</code> 하게 되면, 정상적인 인스턴스 생성 방법인 생성자 이외의 방법이 생기게 됩니다. 버그와 보안 문제가 생길 가능성이 커진다는 것입니다. 하지만 <strong>직렬화 프록시 패턴</strong>을 사용하면 이를 크게 줄일 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬화-프록시-패턴"></a>직렬화 프록시 패턴<a class="hash-link" href="#직렬화-프록시-패턴" title="Direct link to heading">#</a></h3><p>바깥 클래스의 논리적 상태를 표현하는 중첩 클래스를 설계해서 <code>private static</code>으로 선언합니다. 여기서 중첩 클래스가 <strong>직렬화 프록시</strong> 입니다. 중첩 클래스의 생성자는 단 하나여야하며, 바깥 클래스를 매개변수로 받아야합니다. 단순히 인수로 넘어온 인스턴스의 데이터를 복사해야합니다. 일관성 검사 또는 방어적 복사도 필료가 없습니다. 아만, 바깥 클래스와 직렬화 프록시 모두 <code>Serializable</code>을 구현해야합니다.</p><p>이러한 직렬화 프록시 패턴의 장점은 아래와 같습니다.</p><ul><li>멤버 필드를 <code>final</code>로 선언할 수 있기 때문에 진정한 불변으로 만들 수 있습니다.</li><li>역직렬화한 인스턴스와 원래의 직렬화된 클래스가 달라도 정상적으로 동작합니다.</li></ul><p>다만 직렬화 프록시 패턴에도 한계가 있습니다.</p><ul><li>클라이언트가 마음대로 확장할 수 있는 클래스에는 적용할 수 없습니다.</li><li>객체가 서로 참조하는 경우(순환이 있는 경우)에는 적용할 수 없습니다.</li><li>방어적 복사보다 상대적으로 속도가 느립니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/effective-java/ch12.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-12-22T13:19:05.000Z" class="lastUpdatedDate_1WI_">12/22/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch11"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 11. 동시성, Concurrency</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/optimizing-java/ch1"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">1. 성능과 최적화 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-85-자바-직렬화의-대안을-찾습니다" class="table-of-contents__link">Item 85. 자바 직렬화의 대안을 찾습니다.</a></li><li><a href="#item-86-serializable을-구현할지에-대해-신중히-결정합니다" class="table-of-contents__link">Item 86. <code>Serializable</code>을 구현할지에 대해 신중히 결정합니다.</a><ul><li><a href="#직렬화-클래스의-단점" class="table-of-contents__link">직렬화 클래스의 단점</a></li><li><a href="#serializable-구현" class="table-of-contents__link"><code>Serializable</code> 구현</a></li></ul></li><li><a href="#item-87-커스텀-직렬화-형태를-고려합니다" class="table-of-contents__link">Item 87. 커스텀 직렬화 형태를 고려합니다.</a><ul><li><a href="#이상적인-직렬화-형태" class="table-of-contents__link">이상적인 직렬화 형태</a></li><li><a href="#부적절한-직렬화-형태" class="table-of-contents__link">부적절한 직렬화 형태</a></li><li><a href="#합리적인-직렬화-형태" class="table-of-contents__link">합리적인 직렬화 형태</a></li></ul></li><li><a href="#item-88-readobject-메서드는-방어적으로-작성합니다" class="table-of-contents__link">Item 88. <code>readObject</code> 메서드는 방어적으로 작성합니다.</a></li><li><a href="#item-89-인스턴스-수를-통제해야한다면-readresolve보다는-enum-타입을-사용합니다" class="table-of-contents__link">Item 89. 인스턴스 수를 통제해야한다면 <code>readResolve</code>보다는 enum 타입을 사용합니다.</a></li><li><a href="#item-90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토합니다" class="table-of-contents__link">Item 90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토합니다.</a><ul><li><a href="#직렬화-프록시-패턴" class="table-of-contents__link">직렬화 프록시 패턴</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.1efdb204.js"></script>
<script src="/til/assets/js/main.1611beab.js"></script>
</body>
</html>