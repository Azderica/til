<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">9. 일반적인 프로그래밍 원칙 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/effective-java/ch9"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="9. 일반적인 프로그래밍 원칙 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="이번 챕터는 언어의 이론이나 관념이 아닌 실제적인 사실들에 대해 정리합니다. 지역 변수, 제어 구조, 라이브러리, 데이터 유형 및 두가지의 언어 외 기능(reflection와 native method)에 대해 설명합니다. 그리고 최적화 및 명명 규칙에 대해 정리합니다."><meta data-react-helmet="true" property="og:description" content="이번 챕터는 언어의 이론이나 관념이 아닌 실제적인 사실들에 대해 정리합니다. 지역 변수, 제어 구조, 라이브러리, 데이터 유형 및 두가지의 언어 외 기능(reflection와 native method)에 대해 설명합니다. 그리고 최적화 및 명명 규칙에 대해 정리합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/effective-java/ch9"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch9" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch9" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.c06c351d.js" as="script">
<link rel="preload" href="/til/assets/js/main.be511d64.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">아파치 카프카 애플리케이션 프로그래밍 with 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch1">1. 들어가며</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch2">2. 카프카 빠르게 시작해보기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch3">3. 카프카 기본 개념 설명</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch11">11. 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch12">12. 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch13">13. 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch14">14. 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch15">15. 디자인 패턴과 프레임 워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch16">부록 A. 계약에 의한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch17">부록 B. 타입 계층의 구현</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch18">부록 C. 동적인 협력, 정적인 코드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">react</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">따라하며 배우는 리액트 A-Z</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch1">따라하는 리액트, 리액트란?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch2">간단한 To-Do 앱 만들며 리액트 익히기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch3">To-Do 앱 최적화하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch4">4. Netflix 앱 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch5">5. 넷플릭스 앱 모달 및 이미지 불러오기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">9. 일반적인 프로그래밍 원칙</h1></header><div class="markdown"><p>이번 챕터는 언어의 이론이나 관념이 아닌 실제적인 사실들에 대해 정리합니다. 지역 변수, 제어 구조, 라이브러리, 데이터 유형 및 두가지의 언어 외 기능(<code>reflection</code>와 <code>native method</code>)에 대해 설명합니다. 그리고 최적화 및 명명 규칙에 대해 정리합니다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-57-지역-변수의-범위를-최소화합니다"></a>Item 57. 지역 변수의 범위를 최소화합니다.<a class="hash-link" href="#item-57-지역-변수의-범위를-최소화합니다" title="Direct link to heading">#</a></h2><p><a href="https://azderica.github.io/til/docs/java/effective-java/ch3" target="_blank" rel="noopener noreferrer">클래스 및 멤버의 접근성 최소화</a>의 내용과 비슷하며, 지역 변수의 점위를 최소화함으로써 <strong>코드의 가독성과 유지 관리성을 높이고 오류 가능성을 줄일 수 있습니다.</strong></p><ul><li>지역 변수의 범위를 최소화하는 가장 강력한 기술은 처음 사용되는 위치에 선언하는 것입니다. 변수를 사용하기 전에 선언하면 프로그램이 무엇을 하려는지 어려워집니다.</li><li>지역 변수는 선언과 동시에 초기화 해야합니다. 그렇지 않으면 선언할 때까지 선언을 연기해야합니다.</li></ul><p>대표적으로 루프는 변수의 범위를 최소화할 수 있는 기능을 제공합니다. 또한 while 루프 보다는 for 루프를 사용하는 것이 좋습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션 또는 배열을 반복하는 데 선호되는 관용구</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Element e : c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do Something with e</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 반복자가 필요한 경우</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Iterator &lt;Element&gt; i = c.iterator (); i.hasNext ();) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Element e = i.next ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do something with e and i</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>일반적으로 for 루프를 선호하는 이유는 while 루프를 잘 못 사용하면 버그가 발생하기 쉽기 때문입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 잘못된 결과를 만들기 쉬움</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Iterator&lt;Element&gt; i = c.iterator();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">while (i.hasNext()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  doSomething(i.next());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Iterator&lt;Element&gt; i2 = c2.iterator();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">while (i.hasNext()) { // BUG!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  doSomethingElse(i2.next());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컴파일시, 에러가 바로 나오게 됩니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Element e = i.next();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do something with e and i</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Compile-time error - cannot find symbol i</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Iterator&lt;Element&gt; i2 = c2.iterator(); i.hasNext(); ) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Element e2 = i2.next();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do something with e2 and i2</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이렇기 때문에 for loop를 좀 더 선호하는 것이 좋습니다.</p><p>또는, 아채처럼 지역 변수의 범위를 최소화할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (int i = 0, n = expensiveComputation(); i &lt; n; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do something with i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이는, i와 n 모두가 loop 내에서만 범위를 가지고 있습니다.</p><p>마지막 기술은, 지역변수의 범위를 최소화하는 마지막 기술은 메서드를 작고 집중적으로 유지하는 것이 좋습니다. 동일한 방법으로 여러 동작을 수행하면 지역변수가 다른 코드 범위에 있을 수 있기 때문에 이러한 일이 발생하지 않도록 하는 것이 좋습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-58-전통적인-for-루프-보다는-for-each-루프를-더-선호합니다"></a>Item 58. 전통적인 <code>FOR</code> 루프 보다는 <code>FOR-EACH</code> 루프를 더 선호합니다.<a class="hash-link" href="#item-58-전통적인-for-루프-보다는-for-each-루프를-더-선호합니다" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션을 반복하는 것이 가장 좋은 방법은 아닙니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Element e = i.next();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do something with e</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>기존의 for loop 문도, while 문 보다는 낫지만 완벽하지 않습니다. 요소만 필요한 경우, 이는 복잡할 뿐입니다.</p><p>for-each 루프는 이러한 문제를 해결합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션 및 배열을 반복하는 데 선호되는 관용구</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Element e : elements) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Do something with e</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 for-each 문은 중첩된 반복문에서 좀 더 도움이 됩니다. 아래는 for문에서 발생하기 쉬운 버그입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Collection &lt;Face&gt; faces = EnumSet.allOf (Face.class);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Iterator &lt;Face&gt; i = faces.iterator (); i.hasNext ();)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (Iterator &lt;Face&gt; j = faces.iterator (); j.hasNext ();)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println (i. next () + &quot;&quot;+ j.next ());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Expected Output : {ONE, ONE}, {ONE, TWO}, ..., {SIX, SIX}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Real Output : {ONE, ONE}, {TWO, TWO}, ..., {SIX, SIX}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 생각하는 값을 나오게 하기 위해서는 아래처럼 구성하면 됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션 및 배열에 중첩 된 반복에 대한 기본 관용구</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for (Suit suit : suits)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (Rank rank : ranks)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    deck.add(new Card(suit, rank));</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다만 for-each 문을 사용할 수 없는 경우는 세가지 상황이 있습니다.</p><ul><li>Destructive filtering(파괴적 필터링)<ul><li>선택한 요소를 제거하는 컬렉션을 탐색해야하는 경우, <code>remove</code> 메서드를 호출할 수 잇도록 명시적 반복자를 사용해야합니다.</li><li>Java 8에 추가된 Collection의 removeIf 메서드를 사용하여 명시적 순회를 피할 수 있습니다.</li></ul></li><li>Transforming(변형)<ul><li>목록 또는 배열을 탐색하고 해당 요소 값의 일부 또는 전체를 교체해야하는 경우, 요소 값을 바꾸기 위해서 list iterator 또는 array index가 필요합니다.</li></ul></li><li>Parallel iteration(병렬 반복)<ul><li>여러 컬렉션을 병렬로 트래버스해야하는 경우, 모든 반보기 또는 인덱스 변수를 잠금 단계로 진행할 수 있도록 iterator 또는 인덱스 변수를 명시적으로 제어해야합니다.</li></ul></li></ul><p>for-each 루프를 사용하면, 컬렉션과 배열을 반복할 수 있을 뿐만 아니라, 단일 메서드로 구성된 Iterable 인터페이스를 구현하는 모든 개체를 발복할 수 있습니다. 인터페이스의 모습은 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public interface Iterable &lt;E&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  //이 반복 가능한 요소에 대한 iterator를 반환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Iterator &lt;E&gt; iterator ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이렇게 하면, 사용자가 for-each 루프를 사용해서 type을 iterator할 수 있습니다. 즉, <strong>for-each 루프는 for 성능 저하없이 명확성, 유연성 및 버그 방지 측면에서 기존 루프에 비해 강력한 이점을 제공합니다.</strong> 가능한 for-each 루프문을 사용하는 것이 좋습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-59-라이브러리를-알고-사용해야합니다"></a>Item 59. 라이브러리를 알고 사용해야합니다.<a class="hash-link" href="#item-59-라이브러리를-알고-사용해야합니다" title="Direct link to heading">#</a></h2><p>예를 들어, random 을 사용해야할 때 직접 random을 개발해 사용하는 것은 여러 버그가 발생할 수 있습니다. 이러한 경우, 여러 결점이 존재하기 때문에 기존에 있는 라이브러리를 사용하는 것이 좋습니다.</p><p>대표적인 예시로 자바 7의, ThreadLocalRandom이 있습니다. 이를 사용하면, 높은 품질의 난수를 빠르게 생성할 수 있습니다.</p><p>표준 라이브러리 사용은 다음의 장점을 가집니다.</p><ul><li><strong>표준 라이브러리를 사용하면, 이를 작성한 전문가의 지식과 이전에 사용했던 경험을 활용할 수 있습니다.</strong></li><li>업무와 관련 없는 부분에 시간을 낭비할 필요가 없습니다.</li><li>시간이 지남에 따라 성능이 향상되는 경향이 있습니다.</li><li>시간이 지남에 따라 얻는 경향이 있습니다. (누락된 기능이 후속 추가될 수 있습니다.)</li></ul><p>예를 들어 다음과 같이 보여줄 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Java 9에 추가 된 transferTo를 사용하여 URL의 내용을 인쇄합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main (String [] args) throws IOException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try (InputStream in = new URL (args [0]). openStream ()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    in. transferTo (System.out);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 라이브러리는 문서들을 공부하기에는 너무 많습니다. 그러나, 모든 프로그래머들은 <code>java.lang</code>, <code>java.util</code>, <code>java.io</code>와 서브패키지의 기본 사항에 대해 잘 알고 있어야합니다.</p><p>이를 요약하면 다음과 같습니다. <strong>라이브러리가 있는 경우 사용해야하고 모르는 경우에는 라이브러리가 있는지 확인해야합니다.</strong> 일반적으로 라이브러리 코드는 사용자가 직접 작성하는 코드보다 좋으며 시간이 지남에 따라 개선 될 가능성이 높습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-60-정확한-답변이-필요한-경우-float와-double을-피합니다"></a>Item 60. 정확한 답변이 필요한 경우, <code>FLOAT</code>와 <code>DOUBLE</code>을 피합니다.<a class="hash-link" href="#item-60-정확한-답변이-필요한-경우-float와-double을-피합니다" title="Direct link to heading">#</a></h2><p><code>float</code>와 <code>double</code> 유형은 과학 및 공학 계산을 위해서 설게되었습니다. 그렇기 때문에 정확한 근사치를 신속하게 제공하기 위해서 설계된 구조입니다. 따라서, 정확한 결과에 제공하면 안되며 정확한 결과가 필요한 곳에서는 사용하면 안됩니다. (Ex. 금전 계산 등)</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Broken - 화폐 계산에 부동 소수점을 사용합니다!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 사용하면 안됩니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double funds = 1.00;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int itemsBought = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (double price = 0.10; funds &gt;= price; price += 0.10) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    funds -= price;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    itemsBought++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(itemsBought + &quot; items bought.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(&quot;Change: $&quot; + funds);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// output : 0.3999999... (잘못된 값)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>따라서, 아래처럼 수정해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final BigDecimal TEN_CENTS = new BigDecimal(&quot;.10&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  int itemsBought = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  BigDecimal funds = new BigDecimal(&quot;1.00&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (BigDecimal price = TEN_CENTS;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        funds.compareTo(price) &gt;= 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        price = price.add(TEN_CENTS)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    funds = funds.subtract(price);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    itemsBought++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(itemsBought + &quot; items bought.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(&quot;Money left over: $&quot; + funds);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이 경우, BigDecimal을 사용하게 되면 정확한 결과를 만들 수 있습니다. (다만, 원시적인 값에 비해 조금 더 느려집니다.)</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-61-boxed-primitive-보다-primitive-type을-선호합니다"></a>Item 61. Boxed Primitive 보다 Primitive type을 선호합니다.<a class="hash-link" href="#item-61-boxed-primitive-보다-primitive-type을-선호합니다" title="Direct link to heading">#</a></h2><p>자바는 <code>int</code>, <code>double</code>, <code>boolean과</code> 같은 기본(Primitive) 요소와 <code>String</code>이나 <code>List</code>와 같은 참조(Reference) 유형으로 구성되어 있습니다. 또한 모든 기본 유형(Primitive Type)에는 Boxed Primitive라고 하는 참조 유형이 있습니다. 이것이 바로, <code>int</code>, <code>double</code>, <code>boolean</code>에 해당하는 <code>Integer</code>, <code>Double</code>, <code>Boolean</code> 입니다.</p><p>Primitive와 Boxed Primitive 사이에는 세 가지 주요 차이점이 있습니다.</p><ul><li>Primitive는 값만 가지고 있는 반면에, Boxed Primitive는 값과 구별되는 ID를 가지고 있습니다.</li><li>Primitive는 기본 값만 존재하는 반면에, Boxed Primitive는 null과 같이 비 기능적 값이 있습니다.</li><li>Primitive는 Boxed Primitive보다 시간과 공간 효율적입니다.</li></ul><p>이러한 차이를 참고해서 만들어야 합니다.</p><p>즉, 아래의 코드는 잘못된 코드입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Comparator &lt;Integer&gt; naturalOrder = (i, j)-&gt; (i &lt;j)? -1 : (i == j? 0 : 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">naturalOrder.compare(new Integer(42), new Integer(42))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// output : 1 -&gt; error</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같은 문제로, boxed primitives에는 <code>==</code> 연산자를 적용하는 것은 거의 대부분 잘못된 것입니다. 따라서 비교를 할때는 primitive를 사용하는 것이 더 좋습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Unbelievable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static Integer i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main (String [] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (i == 42)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println ( &quot;Unbelievable&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다만, 위의 코드처럼 사용하는 것도 좋지 않습니다. primitive와 boxed primitive를 혼합해서 사용하는 경우, boxed primitive 타입이 박스 해제가 되는 문제가 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 매우 느린 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main (String [] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Long sum = 0L;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (long i = 0; i &lt;Integer.MAX_VALUE; i ++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sum + = i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println (sum);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위 코드는 지역 변수 sum을 기본(Primitive) 타입이 아닌, Boxed Primitive 타입을 사용했기 때문에 반복적으로 boxing되고 unboxed 되는 문제가 존재합니다.</p><p>요약하자면, 선택권이 있는 경우에는 Boxed primitive 보다는 primitive를 사용하는 것이 좋습니다. Boxed Primitive를 사용해야하는 상황이면 조심히 사용해야합니다. <strong>Auto boxing은 boxed primitives를 사용하는 위험은 아니지만, 자세한 정도를 줄입니다.</strong></p><p>프로그램이 boxed 및 unboxed primitive 를 포함하는 혼합 계산을 할때는 unboxing을 수행되고, 프로그램이 unboxing을 수행할 때는 <code>NullPointerException</code>을 throw할 필요가 있습니다. 프로그램이 Primitive 타입을 Boxed Primitive에 넣으면 비용이 많이 들고 불필요한 개체 생성이 발생할 수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-62-다른-유형이-적절하다면-문자열-사용을-피합니다"></a>Item 62. 다른 유형이 적절하다면 문자열 사용을 피합니다.<a class="hash-link" href="#item-62-다른-유형이-적절하다면-문자열-사용을-피합니다" title="Direct link to heading">#</a></h2><p>문자열은 텍스트를 위해 설계되었습니다. 따라서 문자열로 몇가지를 하면 안되는 경우가 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="문자열은-다른-값-타입을-대체하지-못합니다"></a>문자열은 다른 값 타입을 대체하지 못합니다.<a class="hash-link" href="#문자열은-다른-값-타입을-대체하지-못합니다" title="Direct link to heading">#</a></h3><ul><li>입력에서 문자열로 받는 경우가 있지만, 숫자인 경우에는 int, float, BigInteger로 변환해야하고 참/거짓의 경우에는 Enum 또는 boolean으로 처리해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="문자열은-enum-형을-대체하지-못합니다"></a>문자열은 Enum 형을 대체하지 못합니다.<a class="hash-link" href="#문자열은-enum-형을-대체하지-못합니다" title="Direct link to heading">#</a></h3><ul><li>Enum은 문자열보다, Enum형 상수를 사용하는 것이 중요합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="문자열은-aggregate-타입을-대체하지-못합니다"></a>문자열은 aggregate 타입을 대체하지 못합니다.<a class="hash-link" href="#문자열은-aggregate-타입을-대체하지-못합니다" title="Direct link to heading">#</a></h3><ul><li>Entity에 여러 구성이 있는 경우, 사용하지 않는 것이 좋습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="문자열은-capabilities를-대체하지-못합니다"></a>문자열은 capabilities를 대체하지 못합니다.<a class="hash-link" href="#문자열은-capabilities를-대체하지-못합니다" title="Direct link to heading">#</a></h3><ul><li>때때로 문자열은 일부 기능에 대한 액세스 권한을 부여하기위해 사용하는데, 스레드 로컬 변수를 사용할 때 문제가 생길 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Broken - 문자열을 기능으로 부적절하게 사용했습니다!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 두 클라이언트가 독립적으로 스레드 로컬을 사용하기로 결정하면 의도하지않게 변수를 공유하므로 여러 문제가 발생가능합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class ThreadLocal {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private ThreadLocal() { } // Noninstantiable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 명명 된 변수에 대한 현재 스레드의 값을 설정합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void set(String key, Object value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 명명 된 변수에 대한 현재 스레드의 값을 반환합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static Object get(String key);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 해결하는 코드는 아래와 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public final class ThreadLocal&lt;T&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public ThreadLocal();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void set(T value);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public T get();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 요약하면, 더 나인 데이터 유형이 존재하거나 쓸 수 있을 때 객체를 문자열로 나타내는 자연스러운 경향을 피해야합니다. 부적절하게 사용되는 문자열은 다른 유형보다 번거롭고 유연성이 떨어지며 느리고, 오류가 발생하기 쉽습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-63-문자열-연결의-성능에-주의합니다"></a>Item 63. 문자열 연결의 성능에 주의합니다.<a class="hash-link" href="#item-63-문자열-연결의-성능에-주의합니다" title="Direct link to heading">#</a></h2><p>문자열 연결 연산자, <code>+</code>는 몇개의 문자열을 하나로 결합하는 편리하고 좋은 방법입니다. 작은 범위에서는 좋을 수 있지만, 문자열 연결 연산자를 사용해서 n개의 문자열을 연결하는 경우, n 타임이 걸리게 됩니다.</p><p>즉, 아래는 잘못된 사용 코드입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 부적절한 문자열 연결 사용-성능이 좋지 않습니다!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public String statement() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  String result = &quot;&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int i = 0; i &lt; numItems(); i++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    result += lineForItem(i);  // String concatenation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이를 해결하기 위해서는 <code>StringBuilder</code>를 사용하는 것이 좋습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public String statement () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  StringBuilder b = new StringBuilder (numItems () * LINE_WIDTH);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (int i = 0; i &lt;numItems (); i ++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    b.append (lineForItem (i));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return b.toString ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>자바 6이후로, 문자열 연결 속도를 높였으나 아직까지는 <code>StringBuilder</code>를 사용하는 것이 좋습니다.</p><p>즉, 성능이 관련이 없는 경우가 아니면, 문자열 연결 연산자(<code>+</code>)를 사용해서 몇개의 문자열을 결합하지 않는 것이 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-64-인터페이스로-객체를-참조합니다"></a>Item 64. 인터페이스로 객체를 참조합니다.<a class="hash-link" href="#item-64-인터페이스로-객체를-참조합니다" title="Direct link to heading">#</a></h2><p>객체를 참조하려면 클래스보다 인터페이스를 사용을 선호해야합니다. <strong>적절한 인터페이스 유형이 있는 경우, 매개 변수, 반환 값, 변수 및 필드는 모두 인터페이스 유형을 사용하여 선언해야합니다.</strong></p><p>즉, 아래처럼 작성하는 것이 중요합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Good Case - 인터페이스를 유형으로 사용</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Set&lt;Son&gt; sonSet = new LinkedHashSet&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Bad Case - 클래스를 유형으로 사용한 것</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">LinkedHashSet&lt;Son&gt; sonSet = new LinkedHashSet&lt;&gt;();</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>인터페이스를 유형으로 사용하게 되면 프로그램이 좀 더 <strong>유연</strong>해집니다. 다만, 적절한 인터페이스가 없는 경우에는 인터페이스가 아닌 클래스에서 객체를 참조하는 것이 전적으로 중요합니다.</p><p>따라서, 인터페이스를 사용할 수 있다면 인터페이스를 사용해서 객체를 참조시켜 프로그램이 더 유연하고 세련되게 구성합니다. 적절한 인터페이스가 없으면 필요한 기능을 제공하는 클래스 계층 구조에서 가장 덜 구체적인 클래스를 사용하는 것이 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-65-리플렉션보다-인터페이스를-선호합니다"></a>Item 65. 리플렉션보다 인터페이스를 선호합니다.<a class="hash-link" href="#item-65-리플렉션보다-인터페이스를-선호합니다" title="Direct link to heading">#</a></h2><ul><li><a href="https://velog.io/@ptm0304/Java-%EC%9E%90%EB%B0%94-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98" target="_blank" rel="noopener noreferrer">Reflection ?</a></li></ul><p>핵심 리플렉션 기능인 <code>java.lang.reflect</code>는 임의의 클래스에 대한 프로그래밍 방식 액세스를 제공합니다. Class 객체가 주어지면, Class 인스턴스가 나타내는 생성자, 메서드 및 필드를 나타내는 Constructor, Method, Field 인스턴스를 얻을 수 있습니다.</p><p>그러나 리플렉션을 사용하게 되면, 아래의 단점을 가지게 됩니다.</p><ul><li>예외 검사를 포함하여 컴파일 타임 유형 검사의 모든 이점을 잃게됩니다.</li><li>반사 액세스를 수행하는 데 필요한 코든느 서투르고 장황합니다.</li><li>성능이 저하됩니다.</li></ul><p>일반적으로는 리플렉션을 사용하는 것은 거의 안좋습니다.</p><p>리플렉션은 매우 제한된 형태로만 사용함으로써 비용을 거의 발생시키지 않으면서 리플렉션의 많은 이점을 얻을 수 있습니다. 컴파일 타임에 사용할 수 없는 클래스를 사용해야하는 많은 프로그램의 경우, 컴파일 타임에 클래스를 참조할 적절한 인터페이스 또는 수퍼 클래스가 있습니다. 이 경우, Reflective 인스턴스로 생성하고 해당 interface나 super 클래스를 통해서 정상적으로 액세스 가능합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 인터페이스 액세스를 통한 Reflective instantiation</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static void main(String[] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 클래스 이름을 클래스 객체로 변환</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Class&lt;? extends Set&lt;String&gt;&gt; cl = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cl = (Class&lt;? extends Set&lt;String&gt;&gt;)  // Unchecked cast!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      Class.forName(args[0]);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (ClassNotFoundException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fatalError(&quot;Class not found.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Get the constructor</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Constructor&lt;? extends Set&lt;String&gt;&gt; cons = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    cons = cl.getDeclaredConstructor();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (NoSuchMethodException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fatalError(&quot;No parameterless constructor&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Instantiate the set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Set&lt;String&gt; s = null;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    s = cons.newInstance();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (IllegalAccessException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fatalError(&quot;Constructor not accessible&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (InstantiationException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fatalError(&quot;Class not instantiable.&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (InvocationTargetException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fatalError(&quot;Constructor threw &quot; + e.getCause());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (ClassCastException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fatalError(&quot;Class doesn&#x27;t implement Set&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Exercise the set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  s.addAll(Arrays.asList(args).subList(1, args.length));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.out.println(s);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private static void fatalError(String msg) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.err.println(msg);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  System.exit(1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위의 코드처럼 리플렉션은 강력함을 가지고 있습니다. <code>&lt;? extends Set&lt;String&gt;&gt;</code>을 통해서, <code>service provider framework</code>등을 구현하는데 도움이 됩니다.</p><p>그러나, reflection의 단점 또한 잘 보입니다.</p><ul><li>런타임에 여러 에러가 발생할 수 있는 가능성이 있습니다.</li><li>클래스에서 인스턴스를 생성하기 위해서는 긴 코드가 필요합니다.</li></ul><p>또한 위 프로그램을 컴파일하면 확인되지 않은 캐스트 경고가 발생합니다.</p><p>드물지만, 합법적인 리플렉션 사용법 중 하나는 런타임에 없을 수 있는 다른 클래스, 메서드, 필드에 대한 클래스의 종속성을 관리하는 것입니다.</p><p>이를 정리하자면, <strong>리플렉션은 정교한 특정 시스템 프로그래밍 작업에는 필요한 기능이지만 많은 단점이 있습니다.</strong> 컴파일 타입에 알려지지 않은 클래스로 작업해야하는 프로그램을 작성하는 경우, 가능하면 리플렉션을 사용해서 개체를 인스턴스화하고 컴파일 타임에 알려진 일부 인터페이서 또는 슈퍼클래스를 사용해서 개체에 액세스 하는 것이 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-66-네이티브-메서드를-신중하게-사용합니다"></a>Item 66. 네이티브 메서드를 신중하게 사용합니다.<a class="hash-link" href="#item-66-네이티브-메서드를-신중하게-사용합니다" title="Direct link to heading">#</a></h2><p>JNI(Java Native Interface)를 사용하면, Java Program이 C. C++와 같은 <code>native programming language</code>로 작성된 메소드인 <code>native method</code>를 호출할 수 있습니다. 일반적으로 <code>native method</code>의 용도는 3가지입니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="네이티브-메서드의-목적"></a>네이티브 메서드의 목적<a class="hash-link" href="#네이티브-메서드의-목적" title="Direct link to heading">#</a></h3><ul><li>레지스토리와 같은 플랫폼 별 기능에 대한 액세스를 제공합니다.</li><li>레거시 데이터에 대한 액세스를 제공하는 레거시 라이브러리를 포함하여 네이티브 코드의 기존 라이브러리에 대한 액세스를 제공합니다.</li><li>네이티브 메서드는 성능 향상을 위해 애플리케이션의 성능에 중요한 부분을 네이티브 언어로 작성하는데 사용합니다.</li></ul><p>그러나 현재 시점에서는 거의 사용하지 않는 것이 좋습니다. 기본 메서드를 통해서 레지스토리와 같은 플랫폼에 액세스하는 것도 거의 필요하지 않고, <strong>성능향상을 위해 native method를 사용하는 것도 거의 권장하지 않습니다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="네이티브-메서드의-단점"></a>네이티브 메서드의 단점<a class="hash-link" href="#네이티브-메서드의-단점" title="Direct link to heading">#</a></h3><ul><li>안전하기 않기 때문에 메모리 손상 등 여러 문제가 발생하기 쉽습니다.</li><li>이식성이 떨어집니다.</li><li>디버그하기 어렵습니다.</li><li>가비지컬렉터도 추적하기 힙듭니다.</li><li>성능을 저하시킬 수 있습니다.</li><li>가독성이 매우 부족합니다.</li></ul><p>즉, 네이티브 메서드를 사용할 수 있는 경우는 하위 수준 리소스나 native library에 액세스하는 경우에 한하며, 이 경우에도 최대한 버그를 피하도록 노력해야합니다.</p><p>JNI와 같은 것은 알기만 합시다... (자바 갓이 되려면 나쁘지 않을지도.)</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-67-신중하게-최적화합니다"></a>Item 67. 신중하게 최적화합니다.<a class="hash-link" href="#item-67-신중하게-최적화합니다" title="Direct link to heading">#</a></h2><p>최적화에 대한 세가지 격언이 있습니다.</p><ul><li>어리석음을 포함해서 다른 단일 이유보다 효율성이라는 이름으로 잘못된 문제를 일으키면 안됩니다.</li><li>97% 정도의 작은 효율성은 잊어야합니다. 조기 최적화는 모든 문제의 근원입니다.</li><li>최적화에 대해 두가지 규칙을 지켜야합니다.<ul><li>최적화하지 마세요.</li><li>완벽하고 최적화되지 않은 solution을 확보할때까지는 수행하지 않습니다.</li></ul></li></ul><p>이처럼, 최적하는 조심히해야하며 특히 조기 최적화는 문제가 생기기 쉽습니다.</p><p>성능을 위해 건전한 아키텍처 원칙을 희생하면 안됩니다. <strong>빠른 프로그램 보다는 좋은 프로그램을 작성하는 것이 중요합니다.</strong> 좋은프로그램이 빠르지 않는 경우에는 아키텍처를 통해서 최적화할 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="설계시-고려할-사항"></a>설계시 고려할 사항<a class="hash-link" href="#설계시-고려할-사항" title="Direct link to heading">#</a></h3><ul><li>설계 과정에서 성능을 고려하며, 개발도중에 변경에는 시스템이 잘못구성될 수 있습니다.</li><li>성능을 제한하는 설계 결정을 피하기 위해서 노력해야합니다.</li><li>API 설계 결정의 성능 결과를 고려해야합니다. 다만, 좋은 성능을 얻기 위해서 API를 왜곡하는 것은 매우 나쁩니다.</li><li>Java는 성능 모델이 약하기 때문에, C나 C++에 비해 최적화를 좀 더 잘할 필요가 있습니다.</li></ul><p>즉, 빠른 프로그램 보다는 좋은 프로그램을 작성하는 것이 중요합니다. 그렇게 되면 속도가 따라올 것입니다. 다만, 시스템을 설계하는 동안 성능에 대해 생각해야합니다. 그리고, 시스템을 개발 완료 후 에는 성능을 측정하고, 빠른지 확인하고 그렇지 않은 경우에는 프로파일러를 통해서 원인을 찾고 최적화하는 작업을 수행합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-68-일반적으로-허용되는-명명-규칙을-준수합니다"></a>Item 68. 일반적으로 허용되는 명명 규칙을 준수합니다.<a class="hash-link" href="#item-68-일반적으로-허용되는-명명-규칙을-준수합니다" title="Direct link to heading">#</a></h2><p>자바 플랫폼에서는 잘 정립된 naming conventions이 있으며, 대부분은 The Java Language Specification에 포함되어 있습니다.</p><p>패키지, 클래스, 인터페이스, 메서드, 필드 및 형식 변수를 포함하는 여러 naming conventions가 있으며, 이를 위반하면 안됩니다. 이러한 규칙을 위반하면 이후에 사용하기 어려울 수 있습니다.</p><ul><li>패키지 및 모듈은 마침표로 구분된 구성요소와 함께 계층적이며 소문자 알파벳 문자(가끔 숫자)로 구성되어야합니다.</li><li>열거 형 및 주석 유형 이름을 포함한 클래스느 및 인터페이스 이름은 하나 이상의 단어로 구성되어야하며, 각 단어의 앞은 대문자로 표시해야합니다.</li><li>메서드 및 필드 이름은 클래스나 인터페이스와 동일한 방식으로 naming conventions를 사용하지만, 첫 글자는 소문자로 구성해야합니다.</li><li>상수 필드의 경우 하나이상의 대문자와 밑줄 문자로 구성합니다. (EX. <code>COIN_VALUE</code>)</li><li>약어의 경우는, 좀 더 신중하게 선정해야합니다.</li></ul><p>이를 예시로 하면 다음과 같습니다.</p><table><thead><tr><th>식별자 유형</th><th>예</th></tr></thead><tbody><tr><td>Package, module</td><td><code>org.junit.jupiter.api, com.google.common.collect</code></td></tr><tr><td>Class, Interface</td><td><code>Stream, FutureTask, LinkedHashMap, HttpClient</code></td></tr><tr><td>Method, Field</td><td><code>remove, groupingBy, getCrc</code></td></tr><tr><td>Constant Field</td><td><code>MIN_VALUE, NEGATIVE_INFINITY</code></td></tr><tr><td>Local Variable</td><td><code>i, denom, houseNum</code></td></tr><tr><td>Type Parameter</td><td><code>T, E, K, V, X, R, U, V, T1, T2</code></td></tr></tbody></table><p>위와 같은 standard naming conventions를 내재회 하고, 그 다음 특성을을 사용하는 방법을 인지하는 것이 좋습니다. 일반적으로 grammatical conventions는 더 복잡하고 느슨합니다. <code>The Java Language Specification</code>에서 인용한 글은 &quot;오래 유지된 관습적 사용이 달라지는 경우, 이러한 관습을 과도하게 따라하면 안됩니다.&quot;라는 글입니다. 즉, 상식에 한해서 개발하는 것이 필요합니다.</p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/effective-java/ch9.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-06T11:46:25.000Z" class="lastUpdatedDate_1WI_">7/6/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch8"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 8. 메소드</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch10"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">10. 예외 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-57-지역-변수의-범위를-최소화합니다" class="table-of-contents__link">Item 57. 지역 변수의 범위를 최소화합니다.</a></li><li><a href="#item-58-전통적인-for-루프-보다는-for-each-루프를-더-선호합니다" class="table-of-contents__link">Item 58. 전통적인 <code>FOR</code> 루프 보다는 <code>FOR-EACH</code> 루프를 더 선호합니다.</a></li><li><a href="#item-59-라이브러리를-알고-사용해야합니다" class="table-of-contents__link">Item 59. 라이브러리를 알고 사용해야합니다.</a></li><li><a href="#item-60-정확한-답변이-필요한-경우-float와-double을-피합니다" class="table-of-contents__link">Item 60. 정확한 답변이 필요한 경우, <code>FLOAT</code>와 <code>DOUBLE</code>을 피합니다.</a></li><li><a href="#item-61-boxed-primitive-보다-primitive-type을-선호합니다" class="table-of-contents__link">Item 61. Boxed Primitive 보다 Primitive type을 선호합니다.</a></li><li><a href="#item-62-다른-유형이-적절하다면-문자열-사용을-피합니다" class="table-of-contents__link">Item 62. 다른 유형이 적절하다면 문자열 사용을 피합니다.</a><ul><li><a href="#문자열은-다른-값-타입을-대체하지-못합니다" class="table-of-contents__link">문자열은 다른 값 타입을 대체하지 못합니다.</a></li><li><a href="#문자열은-enum-형을-대체하지-못합니다" class="table-of-contents__link">문자열은 Enum 형을 대체하지 못합니다.</a></li><li><a href="#문자열은-aggregate-타입을-대체하지-못합니다" class="table-of-contents__link">문자열은 aggregate 타입을 대체하지 못합니다.</a></li><li><a href="#문자열은-capabilities를-대체하지-못합니다" class="table-of-contents__link">문자열은 capabilities를 대체하지 못합니다.</a></li></ul></li><li><a href="#item-63-문자열-연결의-성능에-주의합니다" class="table-of-contents__link">Item 63. 문자열 연결의 성능에 주의합니다.</a></li><li><a href="#item-64-인터페이스로-객체를-참조합니다" class="table-of-contents__link">Item 64. 인터페이스로 객체를 참조합니다.</a></li><li><a href="#item-65-리플렉션보다-인터페이스를-선호합니다" class="table-of-contents__link">Item 65. 리플렉션보다 인터페이스를 선호합니다.</a></li><li><a href="#item-66-네이티브-메서드를-신중하게-사용합니다" class="table-of-contents__link">Item 66. 네이티브 메서드를 신중하게 사용합니다.</a><ul><li><a href="#네이티브-메서드의-목적" class="table-of-contents__link">네이티브 메서드의 목적</a></li><li><a href="#네이티브-메서드의-단점" class="table-of-contents__link">네이티브 메서드의 단점</a></li></ul></li><li><a href="#item-67-신중하게-최적화합니다" class="table-of-contents__link">Item 67. 신중하게 최적화합니다.</a><ul><li><a href="#설계시-고려할-사항" class="table-of-contents__link">설계시 고려할 사항</a></li></ul></li><li><a href="#item-68-일반적으로-허용되는-명명-규칙을-준수합니다" class="table-of-contents__link">Item 68. 일반적으로 허용되는 명명 규칙을 준수합니다.</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.c06c351d.js"></script>
<script src="/til/assets/js/main.be511d64.js"></script>
</body>
</html>