<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">2. 객체 생성과 삭제 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/effective-java/ch2"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="2. 객체 생성과 삭제 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="Item 1. 생성자 대신 정적 팩토리 메서드 고려"><meta data-react-helmet="true" property="og:description" content="Item 1. 생성자 대신 정적 팩토리 메서드 고려"><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/effective-java/ch2"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch2" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.fd7fc677.js" as="script">
<link rel="preload" href="/til/assets/js/main.75e7f7dc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/README">Clean Architecture</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">JVM의 코드 실행</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">HTTP : 웹의 기초</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">2. 객체 생성과 삭제</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-1-생성자-대신-정적-팩토리-메서드-고려"></a>Item 1. 생성자 대신 정적 팩토리 메서드 고려<a class="hash-link" href="#item-1-생성자-대신-정적-팩토리-메서드-고려" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정적-팩토리-메서드의-장점"></a>정적 팩토리 메서드의 장점<a class="hash-link" href="#정적-팩토리-메서드의-장점" title="Direct link to heading">#</a></h3><p>다음과 같이 정적 팩토리 메서드를 통해 생성할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">StackWalker luke = StackWalker.getInstance(options);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-정적-팩토리-메서드의-한-가지-장점은-생성자와-달리-이름이-존재합니다"></a>1. 정적 팩토리 메서드의 한 가지 장점은 생성자와 달리 이름이 존재합니다.<a class="hash-link" href="#1-정적-팩토리-메서드의-한-가지-장점은-생성자와-달리-이름이-존재합니다" title="Direct link to heading">#</a></h4><ul><li>정적 팩토리가 사용하기 쉽고, 읽기 쉬운 클라이언트 코드를 제공합니다.</li><li>여러 생성자가 필요하다고 판단되면, 정적 팩토리 메서드를 사용하는 것이 좋습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-생성자와-달리-호출될-때마다-새-개체를-만들-필요가-없습니다"></a>2. 생성자와 달리 호출될 때마다 새 개체를 만들 필요가 없습니다.<a class="hash-link" href="#2-생성자와-달리-호출될-때마다-새-개체를-만들-필요가-없습니다" title="Direct link to heading">#</a></h4><ul><li>생성된 인스턴스를 캐시하고 불필요한 중복 객체 생성을 방지하고 반복적으로 분배 가능합니다.</li><li>반복 된 호출에서 동일한 객체를 반환하는 정적 팩토리 메서드의 기능을 통해 클래스는 언제든지 존재하는 인스턴스를 엄격하게 제어 할 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-생성자와-달리-반환-유형의-모든-하위-유형의-객체를-반환할-수-있습니다"></a>3. 생성자와 달리 반환 유형의 모든 하위 유형의 객체를 반환할 수 있습니다.<a class="hash-link" href="#3-생성자와-달리-반환-유형의-모든-하위-유형의-객체를-반환할-수-있습니다" title="Direct link to heading">#</a></h4><ul><li>이러한 유연함을 이용해 특정 응용 프로그램은 API가 클래스를 공개하지 않고도 객체를 반환 할 수 있습니다.</li><li>Java 8에서는 인터페이스에 정적 메서드를 포함 할 수 없다는 제한이 제거되었으므로 편하게 사용할 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-반환-된-개체의-클래스가-입력-매개-변수의-함수로-호출마다-다를-수-있다"></a>4. 반환 된 개체의 클래스가 입력 매개 변수의 함수로 호출마다 다를 수 있다.<a class="hash-link" href="#4-반환-된-개체의-클래스가-입력-매개-변수의-함수로-호출마다-다를-수-있다" title="Direct link to heading">#</a></h4><ul><li>구현 클래스의 존재는 클라이언트에 보이지 않기 때문에 RegularEnumSet과 같은 작은 열거 유형에 대한 성능적 이점이 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5-메서드를-포함하는-클래스가-작성될-때-반환-된-객체의-클래스가-존재할-필요가-없다"></a>5. 메서드를 포함하는 클래스가 작성될 때 반환 된 객체의 클래스가 존재할 필요가 없다.<a class="hash-link" href="#5-메서드를-포함하는-클래스가-작성될-때-반환-된-객체의-클래스가-존재할-필요가-없다" title="Direct link to heading">#</a></h4><ul><li>유연한 정적 팩토리 메소드는 JDBC (Java Database Connectivity API)와 같은 Service provider framework 기반을 형성합니다.</li><li>서비스 공급자 프레임워크는 세가지 필수 구성 요소가 존재합니다.<ul><li>구현을 나타내는 서비스 인터페이스 (<code>a service interface</code>)</li><li>공급자가 구현을 등록하느데 사용하는 공급자 등록 API (<code>a provider registration APi</code>)</li><li>클라이언트가가 서비스의 인스턴스를 얻기 위해 사용하느 서비스 액세스 API (<code>a service access API</code>)</li><li>(선택적 네 번째 구성 요소) 서비스 제공 업체 인터페이스 (<code>service provider interface</code>)</li></ul></li></ul><p>서비스 제공 업체 프레임 워크 패턴에는 다양한 변형이 존재합니다.</p><ul><li>서비스 액세스 API는 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에 반환 가능 (<code>Bridge 패턴</code>)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정적-팩토리-메서드의-단점"></a>정적 팩토리 메서드의 단점<a class="hash-link" href="#정적-팩토리-메서드의-단점" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-public-또는-protected-생성자가-없는-클래스는-하위-클래스화-할-수-없습니다"></a>1. public 또는 protected 생성자가 없는 클래스는 하위 클래스화 할 수 없습니다.<a class="hash-link" href="#1-public-또는-protected-생성자가-없는-클래스는-하위-클래스화-할-수-없습니다" title="Direct link to heading">#</a></h4><ul><li>Collections Framework에서 편의 구현 클래스를 하위 클래스로 만드는 것은 불가능합니다.</li><li>프로그래머가 상속(inheritance)보다 합성(composition) 를 사용하는 것을 장려하며, immutable types에 필요합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-프로그래머가-찾기-어렵습니다"></a>2. 프로그래머가 찾기 어렵습니다.<a class="hash-link" href="#2-프로그래머가-찾기-어렵습니다" title="Direct link to heading">#</a></h4><ul><li>API 문서에서 눈에 띄지 않습니다.</li><li>생성자가 수행하므로 생상자 대신 정적 팩토리 메서드를 제공하는 클래스를 인스턴스화 하는 방법을 파악하기 어렵습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="대표적-팩토리-메서드"></a>대표적 팩토리 메서드<a class="hash-link" href="#대표적-팩토리-메서드" title="Direct link to heading">#</a></h3><p>다음은 대표적인 일반적인 이름입니다.</p><ul><li><code>from</code><ul><li>단일 매개 변수를 취하고이 유형 의 해당 인스턴스를 반환하는 유형 변환 메소드</li><li><code>Date d = Date.from(instant)</code></li></ul></li><li><code>of</code><ul><li>여러 매개 변수를 사용하고이를 통합하는이 유형의 인스턴스를 반환하는 집계 메서드</li><li><code>Set &lt;Rank&gt; faceCards = EnumSet.of (JACK, QUEEN, KING);</code></li></ul></li><li><code>valueOf</code><ul><li>from및 of에 대한 보다 자세한 대안</li><li><code>BigInteger prime = BigInteger.valueOf (Integer.MAX_VALUE);</code></li></ul></li><li><code>instance</code> or <code>getInstance</code><ul><li>매개 변수 (있는 경우)로 설명되지만 같은 값을 가질 수없는 인스턴스를 반환</li><li><code>StackWalker luke = StackWalker.getInstance (옵션);</code></li></ul></li><li><code>create</code> or <code>newInstance</code><ul><li>instance또는 getInstance. 단, 메서드가 각 호출이 새 인스턴스를 반환하도록 보장한다는 점은 예외</li><li><code>Object newArray = Array.newInstance (classObject, arrayLen);</code></li></ul></li><li><code>getType</code><ul><li>getInstance비슷하지만 팩토리 메서드가 다른 클래스에있는 경우 사용</li><li><code>FileStore fs = Files.getFileStore (경로);</code></li></ul></li><li><code>newType</code><ul><li>newInstance비슷하지만 팩토리 메서드가 다른 클래스에있는 경우 사용</li><li><code>BufferedReader br = Files.newBufferedReader (경로);</code></li></ul></li><li><code>type</code><ul><li>get유형 과 new유형의 간결한 대안</li><li><code>List &lt;Complaint&gt; litany = Collections.list (legacyLitany);</code></li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-2-생성자-매개-변수가-많은-경우-빌더를-고려"></a>Item 2. 생성자 매개 변수가 많은 경우, 빌더를 고려<a class="hash-link" href="#item-2-생성자-매개-변수가-많은-경우-빌더를-고려" title="Direct link to heading">#</a></h2><p>Static factories 와 생성자는 제한을 고유하므로, 잘 확장되지 않습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="telescoping-constructor-패턴"></a>telescoping constructor 패턴<a class="hash-link" href="#telescoping-constructor-패턴" title="Direct link to heading">#</a></h3><ul><li>생성자에 필수 매개 변수만 제공하고, 다른 하나에는 단일 선택적 매개 변수, 다른 하나는 두 개의 선택적 맥개 변수가 있는 등의 방식으로 생성자를 제공하는 패턴입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public NutritionFacts (int servingSize, int servings) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public NutritionFacts (int servingSize, int servings, int calories) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public NutritionFacts (int servingSize, int servings, int calories, int fat) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public NutritionFacts (int servingSize, int servings, int calories, int fat, int sodium) { ... }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>텔레 스코핑 생성자 패턴은 작동하지만 매개 변수가 많으면 클라이언트 코드를 작성하기 어렵고 여전히 읽기가 어렵습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="javabeans-패턴"></a>JavaBeans 패턴<a class="hash-link" href="#javabeans-패턴" title="Direct link to heading">#</a></h3><p>이를 해결하는 방법은 setter 메소드 호출(<code>JavaBeans 패턴</code>)입니다. (이 경우는 텔레 스코핑 생성자 패턴을 해결하기에는 유리하나 <strong>불일치를 허용하고 가변성을 요구</strong>한다는 단점이 존재합니다.)</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">@Setter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">@Getter</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class NutritionFacts {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int servingSize = -1; // 필수; 기본값 없음</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int servings = -1; // 필수; 기본값 없음</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int calories = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int fat = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int sodium = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>JavaBeans 패턴은 구성이 여러 호출로 분할되기 때문에 JavaBean은 구성 과정에서 일관성없는 상태에 있을 수 있습니다.<ul><li>유효성을 확인하는 것으로 일관성을 유지할 수 있는 옵션이 따로 없습니다.</li><li>클래스를 불변으로 만들 가능성을 배제하고 스레드 안전성을 보장하기 위해 노력이 필요합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="builder-패턴"></a>Builder 패턴<a class="hash-link" href="#builder-패턴" title="Direct link to heading">#</a></h3><p>텔레 스코핑 생성자 패턴의 안전성 + JavaBeans 패턴의 가독성을 결합</p><ul><li>클라이언트는 필요한 모든 매개 변수를 사용하여 생성자 (또는 정적 팩토리)를 호출하고 빌더 객체를 가져옵니다.</li><li>그런 다음 클라이언트는 빌더 개체에서 setter와 유사한 메서드를 호출하여 관심있는 각 선택적 매개 변수를 설정합니다.</li><li>클라이언트는 매개 변수가없는 build메서드를 호출하여 일반적으로 변경할 수없는 개체를 생성합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class NutritionFacts {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final int servingSize;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static class Builder {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 필수 매개 변수</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private final int servingSize;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 선택적 매개 변수-기본값으로 초기화</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private int calories = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private int fat = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private int sodium = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    public Builder (int servingSize, int servings) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.servingSize = servingSize;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.servings = 서빙;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">NutritionFacts cocaCola = new NutritionFacts.Builder (240, 8)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        .calories (100) .sodium (35) .carbohydrate (27) .build ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>해당 코드는 작성하기 쉽고 읽기 쉽습니다.<ul><li>스프링은 <code>@Builder</code> 어노테이션이 있습니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 클래스 계층 구조를위한 빌더 패턴</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public abstract class Pizza {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final Set &lt;Topping&gt; toppings;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  abstract static class Builder &lt;T extends Builder &lt;T &gt;&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    EnumSet &lt;Topping&gt; toppings = EnumSet.noneOf (Topping.class);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    public T addTopping (Topping topping) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">     toppings.add (Objects.requireNonNull (topping));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return self ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    abstract Pizza build ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // Subclasses must override this method to return &quot;this&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    protected abstract T self ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Pizza(Builder&lt;?&gt; builder) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    toppings = builder.toppings.clone(); // See Item  50</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음과 같이 추상 self메서드 와 함께 메서드 체이닝이 캐스트 없이도 하위 클래스에서 제대로 작동합니다. 따라서 아래의 장점을 가집니다.</p><ul><li>빌더 패턴은 매우 유연합니다. (반복 사용을 통해 여러 개체를 빌드할 수 있음)</li></ul><p>다만, 이러한 단점이 있습니다.</p><ul><li>개체를 만들기 위해서는 작성기를 만들어야 하기 때문에, 만드는 비용 및 성능이 중요한 상황에서 문제가 될 수 있습니다. (처음부터 시작하는 경우에 빌더를 선택하면 좋습니다.)</li></ul><p>따라서 <strong>빌더 패턴은 생성자 또는 정적 팩토리에 소수 이상의 매개 변수가 있는 클래스를 디자인할 때 장점</strong>을 가집니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-3-private-생성자-또는-열거형을-통해-싱글-톤-속성을-적용"></a>Item 3. private 생성자 또는 열거형을 통해 싱글 톤 속성을 적용<a class="hash-link" href="#item-3-private-생성자-또는-열거형을-통해-싱글-톤-속성을-적용" title="Direct link to heading">#</a></h2><p>singleton은 정확하게 한번만 인스턴스화 되고, stateless 또는 unique한 시스템 컴포넌트입니다. <strong>클래스를 싱글톤으로 만들면, 클라이언트 테스트가 어려울 수 있습니다.</strong> 왜냐하면 해당 유형으로 사용되는 인터페이스를 구현하지 않는 이상에 싱글톤을 mock으로 구현할 수 없기 때문입니다.</p><p>일반적으로 싱글톤을 구현하는 방법에 따라 구분할 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-public-final-field를-통한-singleton-구현"></a>1. public final field를 통한 singleton 구현<a class="hash-link" href="#1-public-final-field를-통한-singleton-구현" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// public final field가 있는 singleton</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Elvis {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static final Elvis INSTANCE = new Elvis();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Elvis() {...}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void leaveTheBuilding() { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>private 생성자는 public static final 필드를 초기화하기 위해 한번만 호출되며, Elvis.INSTANCE는 public, protected 생성자가 없기 때문에 monoelvistic(단일성)이 보장됩니다.</li><li><code>public final field</code>는 해당 장점을 가집니다.<ul><li>API가 클래스가 싱글톤임을 명확하게 합니다.</li><li>퍼블릭 정적 필드는 최종이므로 항상 동일한 객체 참조를 포함합니다.</li><li>매우 간단합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-정적-팩토리를-통한-싱글톤"></a>2. 정적 팩토리를 통한 싱글톤<a class="hash-link" href="#2-정적-팩토리를-통한-싱글톤" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Singleton with static factory</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Elvis {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static final Elvis INSTANCE = new Elvis();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Elvis() { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    public static Elvis getInstance() { return INSTANCE; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void leaveTheBuilding() { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>Elvis.getInstance</code> 을 사용하는 모든 호출은 동일한 객체 참조를 반환하고, 다른 Elvis 인스턴스는 생성되지 않습니다.</li><li>정잭 팩토리의 장점은 아래와 같습니다.<ul><li>API를 변경하지 않고도 클래스가 싱글톤인지 여부에 대해 바꿀 수 있는 유연성을 제공합니다.</li><li>애플리케이션에서 필요한 경우, <code>genericwe singleton factory</code> 를 작성할 수 있습니다.</li><li><code>method reference(메소드 참조)</code> 를 supllier(공급자)로 사용할 수 있습니다.</li></ul></li></ul><p>그러나 1번이나 2번의 접근 방식은 싱글톤은 <code>serializabe(직렬화)</code> 하는 경우에는 <code>implements Serializable</code> 만으로는 충분하지 않기 때문에 모든 인스턴스 필드(<code>transient</code>)를 선언하고 <code>readResolve</code> 메소드를 제공해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 싱글톤 속성을 보존하는 readResolve 메서드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">private Object readResolve () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // true Elvis를 반환하고 가바지 커렉터가 Elvis의 복사품을 처리합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return INSTANCE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-단일-요소-열거-형-선언"></a>3. 단일 요소 열거 형 선언<a class="hash-link" href="#3-단일-요소-열거-형-선언" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Enum sigleton - the preferred approach</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public enum Elvis {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  INSTANCE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void leaveTheBuilding() { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>public field 접근 방식과 유사하지만 더 <strong>간결하고 직렬화를 제공</strong>합니다.</li><li>종종 singleton을 구현하는 가장 좋은 방법입니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-4-private-생성자를-통해-noninstantiability비인스턴스성을-적용합니다"></a>Item 4. private 생성자를 통해 noninstantiability(비인스턴스성)을 적용합니다.<a class="hash-link" href="#item-4-private-생성자를-통해-noninstantiability비인스턴스성을-적용합니다" title="Direct link to heading">#</a></h2><ul><li><p><code>java.lang.Math</code> 나 <code>java.util.Arrays</code>, <code>java.util.Colletions</code> 와 같은 유틸리티 클래스는 인스턴스화되도록 설계되어 있지 않습니다.</p></li><li><p>추상 클래스를 만들어서 noninstantiability를 적용하려는 것은 동작하지 않습니다.</p></li><li><p>다만 기본 생성자는 클래스에 명시적 생성자가 없는 경우에 생성되므로, private constructor을 포함함으로서 class를 noninstantiable 상태로 만들 수 있습니다.</p></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Noninstantiable utility class</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class UtilityClass {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Suppress default constructor for noninstantiability</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private UtilityClass () { throw new AssertionError(); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>explict constructor(명시적 생성자)는 private 이므로, 외부에서 접근할 수 없습니다.</li><li><code>AssertionError()</code> 는 생성자가 실수로 클래스 내에서 호출되는 경우에 보험을 제공합니다. 즉, 어떤 상황에서도 클래스가 인스턴스화 되지않음을 보장합니다.</li><li>다만, 이러한 방법은 클래스가 하위 클래스로 분류되는 것을 방지합니다. 즉, 서브 클래스에는 호출할 액세스 가능한 super class 생성자가 없습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-5-hardwiring-자원에-의존성-주입dependency-injection을-선호합니다"></a>Item 5. Hardwiring 자원에 의존성 주입(Dependency Injection)을 선호합니다.<a class="hash-link" href="#item-5-hardwiring-자원에-의존성-주입dependency-injection을-선호합니다" title="Direct link to heading">#</a></h2><p>많은 클래스가 하나 이상의 기본 리소스에 의존합니다.</p><p>부정적인 케이스는 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 유연하지 않고, 테스트할 수 없는 잘못 사용된 유틸리티</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class SpellChecker {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static final Lexicon dictionary = ...;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private SpellChecker () {} // Noninstantiable</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static boolean isValid (String word) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static List&lt;String&gt; suggests(String typo) {...}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>즉, Static utility classes 와 싱글톤은 기본 리스스에 의해 동작이 매개변수화 된 클래스에 적합하지 않습니다.</li><li>따라서 이를 해결하는 패턴은 <strong>새 인스턴스를 만들때, 생성자에 리소스를 전달하는 방법</strong>입니다. (DI, Dependency Injection)</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Dependency injection provides flexibility and testability</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class SpellCheker {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final Lexicon dictionary;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public SpellChecker(Lexicon dictionary) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.dictionary = Objects.requireNonNull(dictionary);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean isValid(String word) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public List&lt;String&gt; suggestions(String typo) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>Dependency Injection Pattern(의존성 주입 패턴)은 다음의 장점을 가집니다.</p><ul><li>immutabiliy(불변성)을 보존합니다.</li><li>resource factory를 전달함으로서 패턴을 변경할 수 있습니다. (<strong>Factory Method Pattern</strong>)<ul><li>자바8에 도입된 <code>Supplier&lt;T&gt;</code> 인터페이스는 Factories를 표현하는데 효과적입니다.</li><li><code>Supplier&lt;T&gt;</code> 메소드는 <code>bounded wildcard type(제한된 와일드카드 유형)</code> 을 사용해서 팩토리의 매개변수를 제한하여, 클라이언트가 지정된 유형의 하위 유형의 생성하는 팩토리를 전달해야합니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>결론적으로는 <strong>singleton 이나 static utility class를 사용하여 하나 이상의 기본 리소스에 의존하는 클래스를 구현하지 않고, 클래스가 이러한 리소스를 직접 생성하지 않도록 설정</strong>해야합니다. 대신에, Resource 또는 Factory를 통해서 생성자에 전달해야합니다. (또는 static factory 나 builder) <strong>DI를 통해서 클래스의 유연성과 재사용성, 테스트 기능을 향상</strong> 시킬 수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-6-불필요한-객체를-생성하는-것을-줄입니다"></a>Item 6. 불필요한 객체를 생성하는 것을 줄입니다.<a class="hash-link" href="#item-6-불필요한-객체를-생성하는-것을-줄입니다" title="Direct link to heading">#</a></h2><p>필요할때마다 기능적으로 동등한 새 객체를 만드는 것보다 단일 객체를 재사용하는 것이 적절합니다.</p><ul><li>나쁜 케이스 : <code>String s = new String(&quot;clothes&quot;)</code></li></ul><p>좀 더 개선하면 다음과 같습니다.</p><ul><li><code>String s = &quot;clothes&quot;</code></li></ul><p><code>static factory method</code> 를 사용하면, 불필요한 객체 생성을 피할 수 있습니다. 따라서 다음과 같이 작성하여 성능이 향상 가능합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 성능 향상 가능.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">static boolean isRomanNumeral (String s) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return s.matches(&quot;^(?=.)M*(C[MD]|D?C{0,3})&quot; + &quot;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>다만 문자열이 정규식과 일치하는지 확인하는 가장 쉬운 방법이지만 String.matches` 성능이 중요한 상황에서 반복적으로 사용하기에는 적합하지 않습니다. 이를 개선하면 아래처럼 바뀝니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 성능 향상을 위해 값 비싼 객체 재사용합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class RomanNumerals {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static final Pattern ROMAN = Pattern.compile (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    &quot;^ (? =.) M * (C [MD] | D? C {0,3})&quot; + &quot;( X [CL] | L? X {0,3}) (I [XV] | V? I {0,3}) $ &quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  );</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static boolean isRomanNumeral (String s) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return ROMAN.matcher (s) .matches ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>이러한 버전은 isRomanNumeral을 자주 호출할 경우 높은 성능을 얻으며, 명확성도 향상되었고 사용자가 보기 쉽습니다.</li></ul><p>Autoboxing는 애매하지만, primitive 와 boxed primitive types간의 구분을 없애버리지는 않습니다. 이러한 잘못된 사용은 속도를 느리게 만듭니다. 따라서, boxed primitives 보다, primitive를 선호하고 의도하지 않은 오토 박싱을 조심해야합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">private static long sum() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Long sum = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for(long i=0; i &lt;= Integer.MAX_VALUE; i++)    // 느리게 만들어버림.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    sum += i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return sum;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-7-사용하지-않는-개체의-참조를-제거합니다"></a>Item 7. 사용하지 않는 개체의 참조를 제거합니다.<a class="hash-link" href="#item-7-사용하지-않는-개체의-참조를-제거합니다" title="Direct link to heading">#</a></h2><p>흔히. 가비지컬렉터를 사용하는 언어의 경우에는 메모리 관리에 대해 생각할 필요가 없다고 생각을 하지만 그렇지 않습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메모리-낭비의-원인-1---미-참조"></a>메모리 낭비의 원인 1 - 미 참조<a class="hash-link" href="#메모리-낭비의-원인-1---미-참조" title="Direct link to heading">#</a></h3><p>다음은 간단하게 스택을 구성한 코드입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Stack {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private Object[] elements;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int size = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static final int DEFAULT_INITIAL_CAPACITY = 16;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Stack() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    elements = new Object[DEFAULT_INITIAL_CAPACITY];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void push(Object e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ensureCapacity();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    elements[size++] = e;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Object pop() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(size == 0) throw new EmptyStackException();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return elements[--size];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private void ensureCapacity() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(elements.length == size)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      elements = Arrays.copyOf(elements, 2 * size + 1);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음 코드에서 스택이 커졌다가 줄어든 경우, 프로그램에 더 이상 참조가 없더라고 스택에서 참조된 객체는 가비지 수집이 되지 않습니다.</p><p>이를 수정하는 방법은 참조가 쓸모 없게 되면 <strong>null out</strong> 참조를 하면 됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public Object pop () {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(size == 0) throw new EmptyStackException();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Object result = elements[--size];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  elements[size] = null;    // 사용하지 않는 참조</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return results;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>객체 참조를 무효화하는 것은 표준이 아니라 예외로 처리해야합니다.</li><li>클래스가 자체 메모리를 관리할 때마다 프로그래머는 메모리 누수에 대해 경고해야합니다. 해제시 개체 참조를 null로 처리해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메모리-낭비의-원인-2---캐시"></a>메모리 낭비의 원인 2 - 캐시<a class="hash-link" href="#메모리-낭비의-원인-2---캐시" title="Direct link to heading">#</a></h3><p>캐시에 넣어놓으면 참조가 있다는 사실을 이후에 잊고, 관련성이 없어진 이후에도 남아있을 확률이 높습니다. 대부분의 캐시에서 사용하는 데이터의 가치는 시간과 반비례하기 때문에 항목을 정리할 필요가 있습니다. <code>LinkedHashMap</code> 는 <code>removeEldestEntry</code> 방법을 통해서 이러한 낭비를 피하기 위해 노력합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메모리-낭비의-원인-3-리스너-및-기타-콜백"></a>메모리 낭비의 원인 3. 리스너 및 기타 콜백<a class="hash-link" href="#메모리-낭비의-원인-3-리스너-및-기타-콜백" title="Direct link to heading">#</a></h3><p>클라이언트가 콜백을 등록하지만, 명시적으로 취소하지 않으면 누적됩니다.</p><p>이러한 부분을 삭제하는 방법은 <code>.NET Framework</code> 의 <code>WeakHashMap</code> 과 같습니다.</p><p><strong>이렇듯이 메모리 낭비는 명백한 오류로 나타나지 않기 때문에, 미리 예상하고 예방하는 방법을 배우는 것이 매우 바람직합니다.</strong></p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-8-finalizers종료자와-cleaners클리너를-피합니다"></a>Item 8. Finalizers(종료자)와 Cleaners(클리너)를 피합니다.<a class="hash-link" href="#item-8-finalizers종료자와-cleaners클리너를-피합니다" title="Direct link to heading">#</a></h2><p><code>Finalizers</code> 는 얘측할 수 없고 종종 위험하고 일반적으로 불필요합니다.</p><ul><li>비정상적인 동작, 성능 저하, 이식성의 문제가 발생할 수 있습니다.</li></ul><p>Java 9부터는 Finalizers를 더이상 사용하지는 않지만, Cleaners를 사용합니다. 그러나, <code>Cleaner</code>는 <code>Finalizers</code> 보다 덜 위험하지만 그래도 예측할 수 없고, 느리고, 일반적으로 불필요합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizers와-cleaner의-단점-1---즉시-실행될-것이라는-보장이-없음"></a>Finalizers와 Cleaner의 단점 1 - 즉시 실행될 것이라는 보장이 없음<a class="hash-link" href="#finalizers와-cleaner의-단점-1---즉시-실행될-것이라는-보장이-없음" title="Direct link to heading">#</a></h3><p>종료자나 클리너가 실행되는 시간 사이에 임의의 시간이 걸릴 수 있습니다. 즉, <strong>종료자 또는 클리너에서 시간이 중요한 작업을 수행하면 안됩니다.</strong></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizers와-cleaner의-단점-2---종료-중에-발생한-예외는-무시됩니다"></a>Finalizers와 Cleaner의 단점 2 - 종료 중에 발생한 예외는 무시됩니다.<a class="hash-link" href="#finalizers와-cleaner의-단점-2---종료-중에-발생한-예외는-무시됩니다" title="Direct link to heading">#</a></h3><p>이러한 예외가 손상된 상태로 종료된 경우, 다른 스레드가 이를 사용할려고 하면 비 결정적인 동작이 발생할 수 있습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizers와-cleaner의-단점-3---심각한-성능-저하"></a>Finalizers와 Cleaner의 단점 3 - 심각한 성능 저하<a class="hash-link" href="#finalizers와-cleaner의-단점-3---심각한-성능-저하" title="Direct link to heading">#</a></h3><p><code>Try-with-resource</code>와 가비지 컬렉터를 쓰는 경우 12ns가 걸리는데 종료자를 사용하면 시간이 550ns가 발생합니다. Cleaner는 조금 더 빠르지만 66ns가 걸립니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizers와-cleaner의-단점-4---심각한-보안-문제-존재"></a>Finalizers와 Cleaner의 단점 4 - 심각한 보안 문제 존재<a class="hash-link" href="#finalizers와-cleaner의-단점-4---심각한-보안-문제-존재" title="Direct link to heading">#</a></h3><p><code>finalizer attacks(종료자 공격)</code>을 사용하는 경우, 문제가 발생합니다.</p><p>이를 막기 위해서는 생성자에서 예외를 던지는 경우, 객체가 존재하지 않도록 방지할 수 있으나 종료자가 이를 불가능하게 만듭니다. 이를 <strong>해결하기 위해서는 <code>finalize</code> 와 같은 최종 메서드를 사용</strong>해야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizers나-cleaner를-쓰지-않기-위해서"></a>Finalizers나 Cleaner를 쓰지 않기 위해서.<a class="hash-link" href="#finalizers나-cleaner를-쓰지-않기-위해서" title="Direct link to heading">#</a></h3><ul><li><code>AutoCloseable</code> 을 통해서 클래스를 구현합니다.</li><li><code>try-with-resource</code> 를 통해서 종료를 보장합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="finalizers나-cleaner의-합법적인-용도"></a>Finalizers나 Cleaner의 합법적인 용도<a class="hash-link" href="#finalizers나-cleaner의-합법적인-용도" title="Direct link to heading">#</a></h3><ul><li>리소스 소유자가 close method 호출을 무시할 경우, 안전막 역할을 하는 것입니다.<ul><li><code>FileInputStream</code>, <code>FileOutputStream</code>, <code>ThreadPoolExecutor</code> 등이 finalizers를 통해서 안전망 역할을 수행합니다.</li></ul></li><li><code>native peer</code>가 있는 객체와 관련된 경우에 사용합니다.<ul><li>이러한 객체는 일반 객체가 아니므로 가비지 컬렉터가 이에 대해 모르기 때문에, 회수할 수 엇습니다.</li><li>다만, 이렇게 사용을 하더라도 <code>close method</code>를 사용해야합니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 클리너를 안전망을 사용하는 경우.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Room implements AutoCloseable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static final Cleaner cleaner = Cleaner.create();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // cleaning이 필요합니다. Room을 참조하면 안됩니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static class State implements Runnable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    int numJunkPiles; // 이 방의 쓰레기 더미 수</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    State(int numJunkPiles) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      this.numJunkPiles = numJunkPiles;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // close 메소드 또는 클리너에 의해 호출</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        @Override public void run() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      System.out.println(&quot;Cleaning room&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      numJunkPiles = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // room의 상태, cleanable과 공유됨</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private final State state;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // cleanable, gc에 의해 가능할때 room이 청소됩니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private final Cleaner.Cleanable cleanable;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    public Room(int numJunkPiles) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        state = new State(numJunkPiles);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        cleanable = cleaner.register(this, state);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    @Override public void close() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        cleanable.clean();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><a href="https://m.blog.naver.com/PostView.nhn?blogId=kbh3983&amp;logNo=220908731253&amp;proxyReferer=https:%2F%2Fwww.google.com%2F" target="_blank" rel="noopener noreferrer">추가적인 참고자료</a></p><p>다음과 같이 State 인스턴스가 Room을 참조하지 않도록 사용합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-9-try-with-resource-를-try-finally-보다-선호합니다"></a>Item 9. TRY-WITH-RESOURCE 를 TRY-FINALLY 보다 선호합니다.<a class="hash-link" href="#item-9-try-with-resource-를-try-finally-보다-선호합니다" title="Direct link to heading">#</a></h2><p>Java 라이브러리에서는 close 메소드를 호출하는 경우, 많은 자원이 소모되기 때문에 다른 방법을 사용해야합니다.</p><p><code>Try-finally</code> 는 2개 이상의 경우에서는 사용하기 어렵기 때문에, <code>try-with-resource</code> 를 사용하는 것이 좋습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static String firstLineOfFile (String path) throws IOException {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try (BufferedReader br = new BufferedReader (new FileReader(path)) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return br.readLine ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static String firstLineOfFile (String path, String defaultVal) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  try (BufferedReader br = new BufferedReader (new FileReader (path))) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return br.readLine ();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } catch (IOException e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return defaultVal;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/effective-java/ch2.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-07-06T11:46:25.000Z" class="lastUpdatedDate_1WI_">7/6/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch1"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 1. 소개</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch3"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">3. 모든 객체의 공통적인 메소드 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-1-생성자-대신-정적-팩토리-메서드-고려" class="table-of-contents__link">Item 1. 생성자 대신 정적 팩토리 메서드 고려</a><ul><li><a href="#정적-팩토리-메서드의-장점" class="table-of-contents__link">정적 팩토리 메서드의 장점</a></li><li><a href="#정적-팩토리-메서드의-단점" class="table-of-contents__link">정적 팩토리 메서드의 단점</a></li><li><a href="#대표적-팩토리-메서드" class="table-of-contents__link">대표적 팩토리 메서드</a></li></ul></li><li><a href="#item-2-생성자-매개-변수가-많은-경우-빌더를-고려" class="table-of-contents__link">Item 2. 생성자 매개 변수가 많은 경우, 빌더를 고려</a><ul><li><a href="#telescoping-constructor-패턴" class="table-of-contents__link">telescoping constructor 패턴</a></li><li><a href="#javabeans-패턴" class="table-of-contents__link">JavaBeans 패턴</a></li><li><a href="#builder-패턴" class="table-of-contents__link">Builder 패턴</a></li></ul></li><li><a href="#item-3-private-생성자-또는-열거형을-통해-싱글-톤-속성을-적용" class="table-of-contents__link">Item 3. private 생성자 또는 열거형을 통해 싱글 톤 속성을 적용</a><ul><li><a href="#1-public-final-field를-통한-singleton-구현" class="table-of-contents__link">1. public final field를 통한 singleton 구현</a></li><li><a href="#2-정적-팩토리를-통한-싱글톤" class="table-of-contents__link">2. 정적 팩토리를 통한 싱글톤</a></li><li><a href="#3-단일-요소-열거-형-선언" class="table-of-contents__link">3. 단일 요소 열거 형 선언</a></li></ul></li><li><a href="#item-4-private-생성자를-통해-noninstantiability비인스턴스성을-적용합니다" class="table-of-contents__link">Item 4. private 생성자를 통해 noninstantiability(비인스턴스성)을 적용합니다.</a></li><li><a href="#item-5-hardwiring-자원에-의존성-주입dependency-injection을-선호합니다" class="table-of-contents__link">Item 5. Hardwiring 자원에 의존성 주입(Dependency Injection)을 선호합니다.</a></li><li><a href="#item-6-불필요한-객체를-생성하는-것을-줄입니다" class="table-of-contents__link">Item 6. 불필요한 객체를 생성하는 것을 줄입니다.</a></li><li><a href="#item-7-사용하지-않는-개체의-참조를-제거합니다" class="table-of-contents__link">Item 7. 사용하지 않는 개체의 참조를 제거합니다.</a><ul><li><a href="#메모리-낭비의-원인-1---미-참조" class="table-of-contents__link">메모리 낭비의 원인 1 - 미 참조</a></li><li><a href="#메모리-낭비의-원인-2---캐시" class="table-of-contents__link">메모리 낭비의 원인 2 - 캐시</a></li><li><a href="#메모리-낭비의-원인-3-리스너-및-기타-콜백" class="table-of-contents__link">메모리 낭비의 원인 3. 리스너 및 기타 콜백</a></li></ul></li><li><a href="#item-8-finalizers종료자와-cleaners클리너를-피합니다" class="table-of-contents__link">Item 8. Finalizers(종료자)와 Cleaners(클리너)를 피합니다.</a><ul><li><a href="#finalizers와-cleaner의-단점-1---즉시-실행될-것이라는-보장이-없음" class="table-of-contents__link">Finalizers와 Cleaner의 단점 1 - 즉시 실행될 것이라는 보장이 없음</a></li><li><a href="#finalizers와-cleaner의-단점-2---종료-중에-발생한-예외는-무시됩니다" class="table-of-contents__link">Finalizers와 Cleaner의 단점 2 - 종료 중에 발생한 예외는 무시됩니다.</a></li><li><a href="#finalizers와-cleaner의-단점-3---심각한-성능-저하" class="table-of-contents__link">Finalizers와 Cleaner의 단점 3 - 심각한 성능 저하</a></li><li><a href="#finalizers와-cleaner의-단점-4---심각한-보안-문제-존재" class="table-of-contents__link">Finalizers와 Cleaner의 단점 4 - 심각한 보안 문제 존재</a></li><li><a href="#finalizers나-cleaner를-쓰지-않기-위해서" class="table-of-contents__link">Finalizers나 Cleaner를 쓰지 않기 위해서.</a></li><li><a href="#finalizers나-cleaner의-합법적인-용도" class="table-of-contents__link">Finalizers나 Cleaner의 합법적인 용도</a></li></ul></li><li><a href="#item-9-try-with-resource-를-try-finally-보다-선호합니다" class="table-of-contents__link">Item 9. TRY-WITH-RESOURCE 를 TRY-FINALLY 보다 선호합니다.</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.fd7fc677.js"></script>
<script src="/til/assets/js/main.75e7f7dc.js"></script>
</body>
</html>