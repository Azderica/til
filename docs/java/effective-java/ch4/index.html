<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">4. 클래스와 인터페이스 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/java/effective-java/ch4"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="4. 클래스와 인터페이스 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="Class와 Interface는 추상화의 기본 단위이며, 이를 위해 여러 요소 등을 사용할 수 있습니다."><meta data-react-helmet="true" property="og:description" content="Class와 Interface는 추상화의 기본 단위이며, 이를 위해 여러 요소 등을 사용할 수 있습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/java/effective-java/ch4"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch4" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/java/effective-java/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.a052687c.js" as="script">
<link rel="preload" href="/til/assets/js/main.27e28f29.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">4. 클래스와 인터페이스</h1></header><div class="markdown"><p>Class와 Interface는 추상화의 기본 단위이며, 이를 위해 여러 요소 등을 사용할 수 있습니다.</p><ul><li><a href="https://azderica.github.io/05-java-study/" target="_blank" rel="noopener noreferrer">클래스 란</a></li><li><a href="https://azderica.github.io/08-java-study/" target="_blank" rel="noopener noreferrer">인터페이스 란</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-15-클래스-및-멤버의-접근성을-최소화합니다"></a>Item 15. 클래스 및 멤버의 접근성을 최소화합니다.<a class="hash-link" href="#item-15-클래스-및-멤버의-접근성을-최소화합니다" title="Direct link to heading">#</a></h2><ul><li>정보 은닉은 개발, 테스트, 최적화, 사용, 이해 및 수정에서 큰 용이성을 가집니다.</li><li><strong>각 클래스 또는 멤버를 가능한 한 액세스 할 수 없게 처리합니다.</strong></li></ul><p>액세스 수준은 다음과 같이 4가지로 구성됩니다.</p><ul><li>private : 선언된 최상위 클래스에서만 액세스 가능</li><li>package-private(default) : 선언된 패키지의 모든 클래스에서 액세스 가능</li><li>protected : 선언된 클래스의 하위 클래스 및 선언된 패키지의 모든 클래스에서 액세스 가능</li><li>public : 어디서나 액세스 가능</li></ul><p>추가적으로 지켜야하는 룰은 다음과 같습니다.</p><ul><li>public 클래스의 인스턴스 필드는 public이면 안됩니다.</li><li><strong>변경가능한 public 필드가 있는 class는 일반적으로 스레드로부터 안전하지 않습니다.</strong></li><li>클래스에 public static final array field 또는 이러한 필드를 반환하는 접근자가 있으면 안됩니다.<ul><li>해결책은 2개가 있습니다.</li><li>public array를 비공개로 바꾸고, public static 목록에 추가합니다.</li><li>array를 private로 만들고, public method를 추가합니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 잠재적인 보안 구멍</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public static final Thing[] VALUES = {...};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><strong>결론적으로, 프로그램 요소의 접근성을 최대한 줄여야합니다.</strong></p><blockquote><p>고민 점.</p></blockquote><ul><li>모든 메서드에 테스트 코드를 작성하는 것이 중요하다고 생각하는데, private으로 선언해버리면 테스트 코드에서 쓸 수가 없어서 어떤식으로 해야할지.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-16-public-class에서는-public-field가-아닌-접근자-메소드를-사용합니다"></a>Item 16. public class에서는 public field가 아닌, 접근자 메소드를 사용합니다.<a class="hash-link" href="#item-16-public-class에서는-public-field가-아닌-접근자-메소드를-사용합니다" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // 이런식으로 짜면, 캡슐화의 이점이 없습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public double x;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public double y;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>클래스가 패키지 외부에서 액세스 가능한 경우, 접근자 메소드를 제공합니다.</li><li>그러나, 클래스가 <code>package-private 클래스</code>이거나 <code>private 중첩 클래스</code>인 경우, 데이터 필드를 노출하는데 본질적인 문제는 없습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-17-변경-가능성을-최소화합니다"></a>Item 17. 변경 가능성을 최소화합니다.<a class="hash-link" href="#item-17-변경-가능성을-최소화합니다" title="Direct link to heading">#</a></h2><p>분변 클래스는 단순히 인스턴스를 수정할 수 없는 클래스이며 이는 설계, 구현 및 사용하기에 더 쉬우며 오류 가능성이 적고 더 안전합니다.</p><p>클래스를 불변으로 만들려면 <code>5가지 규칙</code>을 지켜야합니다.</p><ul><li>객체의 상태(state)를 수정하는 메소드를 제공하면 안됩니다.</li><li>클래스를 확장할 수 없는지 확인합니다.</li><li>모든 필드를 final으로 만듭니다.</li><li>모든 필드를 private로 설정합니다.</li><li>변경 가능한 구성 요소에 대한 독점적인 액세스를 보장합니다.</li></ul><p>변경 불가능한 객체는 이러한 장점을 가지고 있습니다.</p><ul><li>단순합니다.</li><li>생성된 시점의 상태를 파괴될 때까지 그대로 간직합니다.</li><li>스레드로부터 안전하며 동기화가 필요하지 않습니다. 그렇기에 이러한 객체는 자유롭게 공유할 수 있습니다.</li><li>다른 개체를 위해서 좋은 <strong>building block</strong>을 만듭니다.</li><li>상태는 변경되지 않기 때문에, 일시적인 불일치 가능성이 없습니다.</li></ul><p>다만 이러한 단점을 가지고 있습니다.</p><ul><li>값이 다르면 반드시 독립된 객체로 만들어야합니다.</li><li><code>getter</code>가 있다고 반드시 <code>setter</code>가 필요한 것은 아닙니다.</li><li>대부분이 장점이며, 단점은 단시 일정 상황에서 잠재석인 성능 저하가 발생할 수 있습니다. 다만 모든 클래스를 불변으로 만들 수 없습니다.</li><li>대부분의 클래스를 변경할 수 있는 부분으로 최소화해야합니다.</li><li>그리고 다른 이유가 없으면, 모든 필드를 private final로 선언해야합니다.</li><li>생성자는 모든 불변성을 설정하여, 완전히 초기화된 객체를 만들어야합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-18-inheritance상속보다-composition구성을-선호합니다"></a>Item 18. Inheritance(상속)보다 Composition(구성)을 선호합니다.<a class="hash-link" href="#item-18-inheritance상속보다-composition구성을-선호합니다" title="Direct link to heading">#</a></h2><p>상속은 코드 재사용을 달성하는 방법이지만 좋은 방법은 아닙니다.</p><ul><li>메서드 호출과 달리 상속은 캡슐화를 위반합니다.</li><li>즉, 상속의 취약점을 피하기 위해서는 상속 대신 컴포지션과 전달을 사용하는 것이 좋습니다.</li></ul><p>특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더 사용하는 것이 좋습니다. 아래는 그러한 좋은 케이스입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Wrapper Class - 상속 대신 합성을 사용하는 경우.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class InstrumentedSet &lt;E&gt; extends ForwardingSet &lt;E&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private int addCount = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public InstrumentedSet (Set &lt;E&gt; s) { super(s) }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public boolean add(E e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    addCount++;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return super.add(e);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public boolean addAll(Collection&lt;? extends E&gt; c) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    addCount += c.size();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return super.addAll(c);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public int getAddCount() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return addCount;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Reusable forwarding class</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final Set&lt;E&gt; s;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public void clear() { s.clear(); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean contains(Object o) { return s.contains(o); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean isEmpty()          { return s.isEmpty();   }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public int size()                 { return s.size();      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Iterator&lt;E&gt; iterator()     { return s.iterator();  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean add(E e)           { return s.add(e);      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean remove(Object o)   { return s.remove(o);   }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean containsAll(Collection&lt;?&gt; c) { return s.containsAll(c); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean addAll(Collection&lt;? extends E&gt; c) { return s.addAll(c);      }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean removeAll(Collection&lt;?&gt; c) { return s.removeAll(c);   }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public boolean retainAll(Collection&lt;?&gt; c) { return s.retainAll(c);   }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Object[] toArray()          { return s.toArray();  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public &lt;T&gt; T[] toArray(T[] a)      { return s.toArray(a); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public boolean equals(Object o) { return s.equals(o);  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public int hashCode()    { return s.hashCode(); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public String toString() { return s.toString(); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위와 같은 코드는 인터페이스를 통해서 <strong>클래스의 디자인이 가능하며 매우 유연</strong>합니다.</p><p>상속은 하위 클래스가 실제로 수퍼 클래스의 하위 유형인 상황에서만 적절합니다. 즉, <code>is-a</code> 관계인 경우에만 주로 사용하는 것이 좋습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-19-상속을-고려해-설계하고-문서화합니다-그렇지-않으면-상속을-사용하지-않습니다"></a>Item 19. 상속을 고려해 설계하고 문서화합니다. 그렇지 않으면 상속을 사용하지 않습니다.<a class="hash-link" href="#item-19-상속을-고려해-설계하고-문서화합니다-그렇지-않으면-상속을-사용하지-않습니다" title="Direct link to heading">#</a></h2><p>상속을 위해 클래스를 설계하고 문서화하는 것은 아래를 의미합니다.</p><ul><li>클래스는 메서드 재정의의 효과를 정확하게 문서화해야합니다. 즉, <strong>클래스는 재정의 가능한 메서드의 자체 사용을 문서화해야합니다.</strong></li><li>클래스 내부 동작 과정 중간에 끼어들 수 잇는 훅을 잘 선별해서 <code>protected</code> 메서드 형태로 수정해야할 수도 있습니다.</li><li>상속용으로 설계한 클래스는 배포전에 하위 클래스를 작성하여 클래스를 테스트해야합니다.</li><li>상속용 클래스의 생성자는 재정의 가능한 메서드를 직접 혹은 간접으로 호출하면 안됩니다.</li><li>clone이나 readObject 모두 직접적이나 간접적으로든 재정의 가능 메서드를 호출하면 안됩니다.</li></ul><p>즉, 클래스를 상속용으로 설계하려면 매우 까다로우며 제약사항이 있습니다. 이를 해결하는 좋은 방법은 상속용으로 설계하지 않는 클래스는 상속을 금지합니다. (<code>final</code>이나 외부접근이 불가능하도록 클래스를 구성합니다./)</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-20-추상-클래스보다는-인터페이스를-선호합니다"></a>Item 20. 추상 클래스보다는 인터페이스를 선호합니다.<a class="hash-link" href="#item-20-추상-클래스보다는-인터페이스를-선호합니다" title="Direct link to heading">#</a></h2><p>자바에서는 type을 구현하는 두가지 방법은 인터페이스와 추상클래스가 있습니다.</p><ul><li>기존클래스를 쉽게 개조하여 새 인터페이스를 구현할 수 있습니다.</li><li>인터페이스는 <code>믹스인(mixin)</code>를 정의하는 것에 이상적입니다.<ul><li>mixin : 클래스가 기본유형에 추가하여 구현할 수 있는 유형이며 선택적 동작을 제공함</li></ul></li><li>인터페이스는 계층구조가 없는 타입 프레임워크를 만들 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public interface Singer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  AudioClip sing(Song s);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public interface Songwriter {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Song compose (int chartPosition);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public interface SingerSongwriter extends Singer, Songwriter {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  AudioClip strum();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void actSensitive();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>인터페이스는 wrapper 클래스를 통해 안전하고 강력한 기능 향상을 가능하게합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="template-method-pattern"></a>Template Method Pattern<a class="hash-link" href="#template-method-pattern" title="Direct link to heading">#</a></h3><p>인터페이스와 함께, abstract skeletal 구현 클래스를 제공해서 장점을 결합한 패턴입니다. 인터페이스는 유형을 정의하고, 기본 메소드를 제공하며 skeletal 구현하며 클래스는 나머지 non-primitive 인터페이스를 구현합니다.</p><p>인터페이스 자체에 있는 기본 메소드의 이점을 사용할 수 있고 skeletal 구현 클래스는 구현의 작업을 지원할 수 있습니다,.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Skeletal implementation class</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Entries in a modifiable map must override this method</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public V setValue(V value) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    throw new UnsupportedOperationException();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Implements the general contract of Map.Entry.equals</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public boolean equals(Object o) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (o == this)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (!(o instanceof Map.Entry))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Map.Entry&lt;?,?&gt; e = (Map.Entry) o;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Objects.equals(e.getKey(), getKey())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      &amp;&amp; Objects.equals(e.getValue(), getValue());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Implements the general contract of Map.Entry.hashCode</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public int hashCode() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Objects.hashCode(getKey())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      ^ Objects.hashCode(getValue());</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public String toString() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return getKey() + &quot;=&quot; + getValue();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>skeletal 구현은 상속을 위해 설계되었으므로 skeletal 구현에서는 좋은 문서가 절대적으로 필요합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-21-인터페이스는-구현하는-쪽을-생각해-설계합니다"></a>Item 21. 인터페이스는 구현하는 쪽을 생각해 설계합니다.<a class="hash-link" href="#item-21-인터페이스는-구현하는-쪽을-생각해-설계합니다" title="Direct link to heading">#</a></h2><p>Java 8 이후로, default method 구성이 추가되었습니다. 또한 주로 람다 사용을 용이하기 위해서 Java 8의 핵심 Collection Interface에 많은 기본 메서드가 추가됩니다. Java의 라이브러리의 기본 메소드는 잘 구현되어 있으며, 대부분 제대로 작동합니다.</p><p>그러나 <strong>모든 가능한 구현의 모든 불변을 유지하는 default 메서드를 작성하는 것은 어렵습니다.</strong></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Java 8의 Collection 인터페이스에 추가 된 기본 메소드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">default boolean removeIf (Predicate &lt;? super E&gt; filter) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Objects.requireNonNull(filter);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  boolean result = false;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for (Iterator&lt;E&gt; it = iterator(); it.hasNext(); ) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (filter.test(it.next())) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      it.remove();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      result = true;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return result;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>해당 코드가 removeIf 메소드에 대해 작성할 수 있는 코드이지만, 실제 Collection 구현에서는 실패합니다.</p><p>기본 메서드가 있는 경우, 인터페이스의 기존 구현이 오류나 경고없이 컴파일 될 수 있지만 런타임에는 실패합니다.</p><p>기본 메소드가 Java 플랫폼의 일부이지만, <strong>인터페이스를 신중하게 디자인하는 것이 여전히 가장 중요합니다</strong>.</p><p>인터페이스 출시 이후에, 몇 가지 인터페이스 결함을 수정하는 것이 가능하지만 이를 믿을 수 없습니다. 따라서 release 하기 전에는 새 인터페이스를 테스트하는 것이 중요합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-22-인터페이스는-타입을-정의하는-용도로만-사용합니다"></a>Item 22. 인터페이스는 타입을 정의하는 용도로만 사용합니다.<a class="hash-link" href="#item-22-인터페이스는-타입을-정의하는-용도로만-사용합니다" title="Direct link to heading">#</a></h2><p>클래스가 인터페이스를 구현할 때, 인터페이스는 클래스의 인스턴스를 참조하는데 사용할 수 있는 type으로 사용됩니다.</p><p>상수 인터페이스 패턴은 인터페이스를 제대로 사용하지 못하는 것입니다. 상수 유틸리티 클래스로 다음과 같이 선언할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 상수 유틸리티 클래스</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class PhysicalConstants {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private PhysicalConstants() {}  // 인스턴스화 방지</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static final double AVOGADROS_NUMBER = 6.022_140_857e23;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static final double BOLTZMANN_CONST = 1.380_648_52e-23;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static final double ELECTRON_MASS = 9.109_383_56e-31;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>즉, 인터페이스는 type을 정의하는데만 사용해야합니다. 상수를 내보낼 때는 사용해서는 안됩니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-23-태그가-있는-클래스보다-클래스-계층-구조를-활용합니다"></a>Item 23. 태그가 있는 클래스보다 클래스 계층 구조를 활용합니다.<a class="hash-link" href="#item-23-태그가-있는-클래스보다-클래스-계층-구조를-활용합니다" title="Direct link to heading">#</a></h2><p>경우에 따라 인스턴스가 둘 이상의 특징으로 제공되는 인스턴스의 특징을 나타내는 tag field를 포함하는 클래스를 실행할 수 있습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Tagged class - 클래스 계층보다 안좋습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Figure {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  enum Shape {RECTANGLE, CIRCLE};</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Tag field : the shape of this figure</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final Shape shape;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // These fields are used only if shape is RECTANGLE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double length;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // This field is used only if shape is CIRCLE</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double radius;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Constructor for circle</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Figure(double radius) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    shape = Shape.CIRCLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.radius = radius;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // Constructor for rectangle</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Figure(double length, double width) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    shape = Shape.RECTANGLE;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.length = length;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.width = width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  double area() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    switch(shape) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case RECTANGLE:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return length * width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      case CIRCLE:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return Math.PI * (radius * radius);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      default:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        throw new AssertionError(shape);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이러한 코드는 매우 지저분합니다. 즉, <strong>태그가 지정된 클래스는 장황하고 오류가 발생하기 쉬우며 비효율적입니다.</strong> 이러한 클래스는 클래스 계층 구조를 모방한 것입니다.</p><p>이를 클래스 계층으로 나타내면 다음과 같습니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Class hierarchy replacement for a tagged class</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class Figure {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  abstract double area();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Circle extends Figure {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double radius;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Circle(double radius) { this.radius = radius; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override double area() { return Math.PI * (radius * radius); }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Rectangle extends Figure {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double length;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final double width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  Rectangle(double length, double width) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.length = length;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    this.width  = width;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override double area() { return length * width; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>이와 같은 클래스 계층은 태그 지정된 클래스의 모든 단점을 해결하고, 자연스러운 계층 관계를 반영하여 유연성을 높이고 컴파일시 유형 검사를 향상 시킬수 있습니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-24-멤버-클래스는-되도록-static으로-만듭니다"></a>Item 24. 멤버 클래스는 되도록 static으로 만듭니다.<a class="hash-link" href="#item-24-멤버-클래스는-되도록-static으로-만듭니다" title="Direct link to heading">#</a></h2><p>nested(중첩된) class는 다른 클래스내에 정의된 클래스입니다. nested class가 다른 컨텍스트에서 유용하다면 최상위 클래스여야지 의미가 있습니다.</p><p>중첩 클래스는 다음으로 나눠집니다.</p><ul><li>static member class</li><li>non-static member class</li><li>anonymous class</li><li>local class</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="static-member-class"></a>static member class<a class="hash-link" href="#static-member-class" title="Direct link to heading">#</a></h3><p>static member class (정적 멤버 클래스)은 public helper class로, 외부 클래스와 함께 사용하는 경우 유용합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="non-static-member-class"></a>non-static member class<a class="hash-link" href="#non-static-member-class" title="Direct link to heading">#</a></h3><p>정적 멤버 클래스와 비정적 멤버 클래스의 유일한 차이점은 static 선언에 수정자가 있다는 점입니다.</p><p>일반적으로 nonstatic member class의 일반적인 용도 중 하나 는 외부 클래스의 인스턴스를 관련없는 일부 클래스의 인스턴스로 볼 수 있도록 허용하는 Adapter이며, 다음과 같이 구현됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// nonstatic member class의 일반적인 사용</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ... // Bulk of the class omitted</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Override public Iterator&lt;E&gt; iterator() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return new MyIterator();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private class MyIterator implements Iterator&lt;E&gt; { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>둘러싸는 인스턴스에 액세스할 필요가 없는 멤버 클래스를 선언하는 경우, 항상 해당 선언에 static modifier을 넣습니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="anonymous-class"></a>anonymous class<a class="hash-link" href="#anonymous-class" title="Direct link to heading">#</a></h3><p>익명 클래스는 이름이 없고, 적용 가능성에는 많은 제한이 있습니다. 선언된 시점을 제외하고는 인스턴스화할 수 없습니다. 또한 길어지면 가독성이 떨어지기 때문에 짧게 유지해야합니다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="local-class"></a>local class<a class="hash-link" href="#local-class" title="Direct link to heading">#</a></h3><p>가장 자주 사용되지 않으며, 지역 변수가 선언될 수 있고 동일한 scope 내에 지정 규칙을 지킵니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="item-25-단일-최상-클래스는-한-파일에-하나만-담습니다"></a>Item 25. 단일 최상 클래스는 한 파일에 하나만 담습니다.<a class="hash-link" href="#item-25-단일-최상-클래스는-한-파일에-하나만-담습니다" title="Direct link to heading">#</a></h2><p>Java 컴파일러를 사용하면 단일 소스 파일에 여러 최상위 클래스를 정의할 수 있지만, 이에 대한 이점이 없으며 위험이 있습니다.</p><p>즉, 아래의 코드는 매우 위험합니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 하나의 파일에 정의 된 두 개의 클래스</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Utensil {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static final String NAME = &quot;pan&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Dessert {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  static final String NAME = &quot;cake&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>위의 코드보다 나은 케이스입니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 여러 최상위 클래스 대신 정적 멤버 클래스</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Test {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public static void main (String [] args) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println (Utensil.NAME + Dessert.NAME);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static class Utensil {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    static final String NAME = &quot;pan&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private static class Dessert {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    static final String NAME = &quot;cake&quot;;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음과 같이, <strong>단일 소스에는 여러 최상이 클래스 또는 인터페이스를 넣으면 안됩니다.</strong></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/java/effective-java/ch4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-10-07T08:12:51.000Z" class="lastUpdatedDate_1WI_">10/7/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 3. 모든 객체의 공통적인 메소드</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/java/effective-java/ch5"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">5. 제네릭 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#item-15-클래스-및-멤버의-접근성을-최소화합니다" class="table-of-contents__link">Item 15. 클래스 및 멤버의 접근성을 최소화합니다.</a></li><li><a href="#item-16-public-class에서는-public-field가-아닌-접근자-메소드를-사용합니다" class="table-of-contents__link">Item 16. public class에서는 public field가 아닌, 접근자 메소드를 사용합니다.</a></li><li><a href="#item-17-변경-가능성을-최소화합니다" class="table-of-contents__link">Item 17. 변경 가능성을 최소화합니다.</a></li><li><a href="#item-18-inheritance상속보다-composition구성을-선호합니다" class="table-of-contents__link">Item 18. Inheritance(상속)보다 Composition(구성)을 선호합니다.</a></li><li><a href="#item-19-상속을-고려해-설계하고-문서화합니다-그렇지-않으면-상속을-사용하지-않습니다" class="table-of-contents__link">Item 19. 상속을 고려해 설계하고 문서화합니다. 그렇지 않으면 상속을 사용하지 않습니다.</a></li><li><a href="#item-20-추상-클래스보다는-인터페이스를-선호합니다" class="table-of-contents__link">Item 20. 추상 클래스보다는 인터페이스를 선호합니다.</a><ul><li><a href="#template-method-pattern" class="table-of-contents__link">Template Method Pattern</a></li></ul></li><li><a href="#item-21-인터페이스는-구현하는-쪽을-생각해-설계합니다" class="table-of-contents__link">Item 21. 인터페이스는 구현하는 쪽을 생각해 설계합니다.</a></li><li><a href="#item-22-인터페이스는-타입을-정의하는-용도로만-사용합니다" class="table-of-contents__link">Item 22. 인터페이스는 타입을 정의하는 용도로만 사용합니다.</a></li><li><a href="#item-23-태그가-있는-클래스보다-클래스-계층-구조를-활용합니다" class="table-of-contents__link">Item 23. 태그가 있는 클래스보다 클래스 계층 구조를 활용합니다.</a></li><li><a href="#item-24-멤버-클래스는-되도록-static으로-만듭니다" class="table-of-contents__link">Item 24. 멤버 클래스는 되도록 static으로 만듭니다.</a><ul><li><a href="#static-member-class" class="table-of-contents__link">static member class</a></li><li><a href="#non-static-member-class" class="table-of-contents__link">non-static member class</a></li><li><a href="#anonymous-class" class="table-of-contents__link">anonymous class</a></li><li><a href="#local-class" class="table-of-contents__link">local class</a></li></ul></li><li><a href="#item-25-단일-최상-클래스는-한-파일에-하나만-담습니다" class="table-of-contents__link">Item 25. 단일 최상 클래스는 한 파일에 하나만 담습니다.</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.a052687c.js"></script>
<script src="/til/assets/js/main.27e28f29.js"></script>
</body>
</html>