<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">7. 연산자 오버로딩과 기타 관례 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch7"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="7. 연산자 오버로딩과 기타 관례 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="- 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 관례에 의존합니다."><meta data-react-helmet="true" property="og:description" content="- 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 관례에 의존합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch7"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch7" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch7" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.200a3fc7.js" as="script">
<link rel="preload" href="/til/assets/js/main.b9c64efc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">7. 연산자 오버로딩과 기타 관례</h1></header><div class="markdown"><ul><li>언어 기능을 타입에 의존하는 자바와 달리 코틀린은 관례에 의존합니다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="71-산술-연산자-오버로딩"></a>7.1 산술 연산자 오버로딩<a class="hash-link" href="#71-산술-연산자-오버로딩" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="711-이항-산술-연산-오버로딩"></a>7.1.1. 이항 산술 연산 오버로딩<a class="hash-link" href="#711-이항-산술-연산-오버로딩" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">data dlass Point(val x: Int, val y: Int) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    operator fun plus(other: Point): Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return Point(x + other.x, y + other.y)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p1 = Point(10, 20)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p2 = Point(30, 40)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(p1 + p2)    // Point(x = 40, y = 60)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>오버로딩 가능한 이항 산술 연산자는 다음과 같습니다.</li></ul><table><thead><tr><th>식</th><th>함수 이름</th></tr></thead><tbody><tr><td>a * b</td><td>times</td></tr><tr><td>a / b</td><td>div</td></tr><tr><td>a % b</td><td>mod(1.1 부터 rem)</td></tr><tr><td>a + b</td><td>plus</td></tr><tr><td>a - b</td><td>minus</td></tr></tbody></table><blockquote><p>코틀린 연산자를 자바에서 호출하기는 쉽습니다.</p></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">operator fun Point.times(scale: Double): Point {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Point((x * scale).toInt(), (y * scale).toInt())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p = Point(10, 20)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(p * 1.5)    // Point(x = 15, y = 30)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린 연산자는 자동으로 교환 법칙(commutativity)를 지원하지는 않습니다.</li><li>연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나와 일치해야하지만은 않습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">operatior fun Char.times(count: Int): String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return toString().repeat(count)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(&#x27;a&#x27; * 3)    // aaa</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="712-복합-대입-연산자-오버로딩"></a>7.1.2. 복합 대입 연산자 오버로딩<a class="hash-link" href="#712-복합-대입-연산자-오버로딩" title="Direct link to heading">#</a></h3><ul><li><code>+=</code>, <code>-=</code> 등의 연산자는 <strong>복합 대입(compound assignment) 연산자</strong>라고 부릅니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val numbers = ArrayList&lt;Int&gt;()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">numbers += 42</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(numbers[0])</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>복합 대입 연산자 함수도 비슷하게 <code>minusAssign, timesAssign</code> 등의 이름을 사용합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">operator fun&lt;T&gt; MutableCollection&lt;T&gt;.plusAssign(element: T) { this.add(element) }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>a += b</code>는 <code>a = a.plus(b)</code> 또는 <code>a.plusAssign(b)</code> 로 번역할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="713-단항-연산자-오버로딩"></a>7.1.3. 단항 연산자 오버로딩<a class="hash-link" href="#713-단항-연산자-오버로딩" title="Direct link to heading">#</a></h3><ul><li>코틀린은 단항 연산자도 제공합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">operator fun Point.unaryMinus(): Point { return Point(-x, -y) }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p = Point(10, 20)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(-p)     // Point(x=-10, y=-20)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>오버로딩할 수 있는 단항 산술 연산자는 다음과 같습니다.</li></ul><table><thead><tr><th>식</th><th>함수 이름</th></tr></thead><tbody><tr><td>+a</td><td>unaryPlus</td></tr><tr><td>-a</td><td>unaryMinus</td></tr><tr><td>!a</td><td>not</td></tr><tr><td>++a, a++</td><td>inc</td></tr><tr><td>--a, a--</td><td>dec</td></tr></tbody></table><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="72-비교-연산자-오버로딩"></a>7.2 비교 연산자 오버로딩<a class="hash-link" href="#72-비교-연산자-오버로딩" title="Direct link to heading">#</a></h2><ul><li>코틀린은 자바와 달리 모든 객체에 대해 비교 연산을 수행할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="721-동등성-연산자-equals"></a>7.2.1. 동등성 연산자: equals<a class="hash-link" href="#721-동등성-연산자-equals" title="Direct link to heading">#</a></h3><ul><li>코틀린은 <code>==</code> 연산자를 <code>equals</code> 메서드 호출로 컴파일합니다.</li><li><code>a == b</code> 는 <code>a?.equals(b) ?: (b == null)</code> 을 의미합니다.</li><li>식별자 비교(identity equals, <code>===</code>) 를 사용해 파라미터의 수신 객체와 같은 지 비교하며, 자바의 <code>==</code> 연산자와 동일합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="722-순서-연산자-compareto"></a>7.2.2. 순서 연산자: compareTo<a class="hash-link" href="#722-순서-연산자-compareto" title="Direct link to heading">#</a></h3><ul><li>코틀린도 자바와 동일한 <code>Compareable</code> 인터페이스를 지원합니다.</li><li><code>a &gt;= b</code> 는 <code>a.compareTo(b) &gt;= 0</code> 을 의미합니다.</li><li>다음과 같은 라이브러리도 사용가능합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val firstName: String, val lastName: String</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">): Comparable&lt;Person&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    override fun compareTo(other: Person): Int {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return compareValuesBy(this, other, Person::lastName, Person::firstName)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="73-컬렉션과-범위에-대해-쓸-수-있는-관례"></a>7.3 컬렉션과 범위에 대해 쓸 수 있는 관례<a class="hash-link" href="#73-컬렉션과-범위에-대해-쓸-수-있는-관례" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="731-인덱스로-원소에-접근-get과-set"></a>7.3.1. 인덱스로 원소에 접근: get과 set<a class="hash-link" href="#731-인덱스로-원소에-접근-get과-set" title="Direct link to heading">#</a></h3><ul><li>코틀린에서 맵의 원사에 접근할 때나 자바에서 배열 원소에 접근할 때, <code>[]</code>를 사용합니다.</li><li><code>x[a, b]</code> 는 <code>x.get(a, b)</code> 로 호출됩니다.</li><li><code>x[a, b] = c</code> 는 <code>x.set(a, b, c)</code> 로 호출됩니다. </li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="732-in-관례"></a>7.3.2. in 관례<a class="hash-link" href="#732-in-관례" title="Direct link to heading">#</a></h3><ul><li>컬렉션이 지원하는 다른 연산자는 <code>in</code> 이 있습니다.</li><li><code>a in c</code> 는 <code>c.contains(a)</code> 로 전달됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="733-rangeto-관례"></a>7.3.3. rangeTo 관례<a class="hash-link" href="#733-rangeto-관례" title="Direct link to heading">#</a></h3><ul><li><code>start..end</code> 는 <code>start.rangeTo(end)</code> 를 지원합니다.</li><li><code>rangeTo</code> 함수는 범위를 반환합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val n = 9</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(0..(n+1))   // 0..10</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">(0..n).forEach { print(it) }    // 0123456789</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="734-for-루프를-위한-iterator-관례"></a>7.3.4. for 루프를 위한 iterator 관례<a class="hash-link" href="#734-for-루프를-위한-iterator-관례" title="Direct link to heading">#</a></h3><ul><li>코틀린의 <code>for</code> 루프는 범위 검사와 똑같이 <code>in</code> 연산자를 사용하나 의미는 다르며 이때는 <code>list.iterator()</code> 를 호출합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">operator fun CharSequence.iterator(): CharIterator  // for (c in &quot;abc&quot;)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="74-구조-분해-선언과-component-함수"></a>7.4 구조 분해 선언과 component 함수<a class="hash-link" href="#74-구조-분해-선언과-component-함수" title="Direct link to heading">#</a></h2><ul><li>코틀린의 특징 중 <strong>구조 분해 선언(destructuring declaration)</strong> 에 대해 이야기합니다.</li><li><code>val (a, b) = p</code> 는 <code>val a = p.component1(), val b = p.component2()</code> 와 같습니다.</li><li>다음과 같이 사용할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 구조 분해 선언을 사용해 여러 값 반환</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">data class NameComponents(val name: String, val extension: String)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun splitFilename(fullName: String): NameComponents {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val (name, extension) = fullName.split(&#x27;.&#x27;, limit = 2)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return NameComponents(name, extension)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val (name, ext) = splitFilename(&quot;example.kt&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(name)   // example</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(ext)    // ext</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="741-구조-분해-선언과-루프"></a>7.4.1. 구조 분해 선언과 루프<a class="hash-link" href="#741-구조-분해-선언과-루프" title="Direct link to heading">#</a></h3><ul><li>확장 함수를 대표적으로 사용한 예제는 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 구조 분해 선언을 사용해 맵 이터레이션</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun printEntries (map: Map&lt;String, String&gt;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for ((key, value) in map) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        println(&quot;$key -&gt; $value&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val map = mapOf(&quot;Oracle&quot; to &quot;Java&quot;, &quot;JetBrains&quot; to &quot;Kotlin&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printEntries(map)   // Oracle -&gt; Java \n JetBrains -&gt; Kotlin</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="75-프로퍼티-접근자-로직-재활용-위임-프로퍼티"></a>7.5 프로퍼티 접근자 로직 재활용: 위임 프로퍼티<a class="hash-link" href="#75-프로퍼티-접근자-로직-재활용-위임-프로퍼티" title="Direct link to heading">#</a></h2><ul><li><strong>위임 프로퍼티(delegated property)</strong> 를 사용하면 값을 뒷받침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현할 수 있습니다.</li><li>이러한 특성의 기반에는 <strong>위임</strong>이 있으며, 위임은 객체가 직접 작업을수행하지 않고 다른 도우미 객체가 그 작업을 처리하게 맡기는 디자인 패턴입니다.</li><li>작업을 처리하는 도무이 객체를 <strong>위임 객체(delegate)</strong> 라 부릅니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="751-위임-프로퍼티-소개"></a>7.5.1. 위임 프로퍼티 소개<a class="hash-link" href="#751-위임-프로퍼티-소개" title="Direct link to heading">#</a></h3><ul><li>일반적인 위임의 문법은 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Foo {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var p: Type by Delegate()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Foo {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private val delegate = Delegate()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var p: Type</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    set(value: Type) = delegate.setValue(..., value)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    get() = delegate.getValue(...)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>프로퍼티 위임 관례를 따르는 Delegate 클래스는 <code>getValue</code>와 <code>setValue</code>를 제공해야합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Delegate {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    operator fun getValue(...) {...}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    operator fun setValue(..., value: Type) { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Foo {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var p: Type by Delegate()   // &quot;by&quot; 키워드는 프로퍼티와 위임 객체를 연결합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val foo = Foo()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val oldValue = foo.p    // delegate.getValue() 호출</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">foo.p = newValue        // delegate.setValue(..., newValue)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="752-위임-프로퍼티-사용-by-lazy를-사용한-프로퍼티-초기화-지연"></a>7.5.2. 위임 프로퍼티 사용: by lazy()를 사용한 프로퍼티 초기화 지연<a class="hash-link" href="#752-위임-프로퍼티-사용-by-lazy를-사용한-프로퍼티-초기화-지연" title="Direct link to heading">#</a></h3><ul><li><strong>지연 초기화(lazy initialization)</strong> 는 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우 초기화할 때 흔히 쓰이는 패턴입니다.</li><li>초기화 과정에 자원을 많이 사용하거나 객체를 사용할 때마다 꼭 초기화하지 않아도 되는프로퍼티에 대해 지연 초기화 패턴을 사용할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Email { /*...*/ }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun loadEmails(person: Person) : List&lt;Email&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(&quot;${person.name}의 이메일을 가져옴&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return listOf(/*...*/)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 지연 초기화 예제.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person (val name: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private var _emails: List&lt;Email&gt;? = null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val emails: List&lt;Email&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        get() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            if(_emails == null) { _emails loadEmails(this)}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return _emails!!    // 저장해 둔 데이터가 있으면 데이터 반환</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p = Person(&quot;Alice&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">p.emails    // Load emails for Alice</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위의 예제는 <strong>뒷받침하는 프로퍼티(backing property)</strong> 라는 기법을 사용합니다.<ul><li><code>_emails</code>라는 프로퍼티는 값을 저장하고, 다른 프로퍼티인 <code>emails</code>는 <code>_emails</code>라는 프로퍼티에 대한 읽기 연산을 저장합니다.</li></ul></li><li>코틀린은 이를 개선했으며, <code>lazy</code>라는 표준 라이브러리 함수가 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val name: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val emails by lazy { loadEmails(this) }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="753-위임-프로퍼티-구현"></a>7.5.3. 위임 프로퍼티 구현<a class="hash-link" href="#753-위임-프로퍼티-구현" title="Direct link to heading">#</a></h3><ul><li>코틀린의 위임 방식에 대한 예제는 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class ObservableProperty (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var propValue: Int, val changeSupport: PropertyChangeSupport</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    operator fun getValue(p: Person, prop: KProperty&lt;*&gt;): Int = propValue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    operator fun setValue(p: Person, prop: KProperty&lt;*&gt;, newValue: Int) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val oldValue = propValue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        propValue = newValue</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        changeSupport.firePropertyChange(prop.name, oldValue, newValue)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val name: String, age: Int, salary: Int</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">) : PropertyChangeAware() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var age: Int by ObservableProperty(age, changeSupport)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var salary: Int by ObservableProperty(salary, changeSupport)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>by</code> 오른쪽에 오는 객체를 <strong>위임 객체(delegate)</strong> 라고 부릅니다.</li><li>코틀린은 위임 객체를 감춰진 프로퍼티에 저장하고, 주 객체의 프로퍼티를 읽거나 쓸 때마다 위임 객체의 <code>getValue</code> 와 <code>setValue</code> 를 호출해줍니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Delegates.observable을 사용해 프로퍼티 변경 통지 구현</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val name: String, age: Int, salary: Int</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">) : PropertyChangeAware() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private val observer = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        prop: KProperty&lt;*&gt;, oldValue: Int, newValue: Int -&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        changeSupport.firePropertyChange(prop.name, oldValue, newValue)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var age: Int by Delegates.observable(age, observer)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var salary: Int by Delegates.observable(salary, observer)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위임 메커니즘을 모든 타입에 두루두루 사용할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="754-위임-프로퍼티-컴파일-규칙"></a>7.5.4. 위임 프로퍼티 컴파일 규칙<a class="hash-link" href="#754-위임-프로퍼티-컴파일-규칙" title="Direct link to heading">#</a></h3><ul><li>컴파일러는 모든 프로퍼티 접근자 안은 <code>getValue</code>와 <code>setValue</code> 호출을 생성해줍니다.<ul><li><code>val x = c.prop</code> 는 <code>val x = &lt;delegate&gt;.getValue(c, &lt;property&gt;)</code></li><li><code>c.prop = x</code> 는 <code>&lt;delegate&gt;.setValue(c, &lt;property&gt;, x)</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="755-프로퍼티-값을-맵에-저장"></a>7.5.5. 프로퍼티 값을 맵에 저장<a class="hash-link" href="#755-프로퍼티-값을-맵에-저장" title="Direct link to heading">#</a></h3><ul><li>자신의 프로퍼티를 동적으로 정의할 수 있는 객체를 만들 때 위임 프로퍼티를 활용하는 경우가 있으며 그런 객체를 <strong>확장 가능한 객체(expando object)</strong> 라고 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 값을 맵에 저장하는 위임 프로퍼티</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private val _attributes = hashMapOf&lt;String, String&gt;()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fun setAttribute(attrName: String, value: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        _attributes[attrName] = value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val name: String by _attributes</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>표준 라이브러리가 <code>Map</code>과 <code>MutableMap</code> 인터페이스에 대해 <code>getValue</code>와 <code>setValue</code> 확장 함수를 제공합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="756-프레임워크에서-위임-프로퍼티-활용"></a>7.5.6. 프레임워크에서 위임 프로퍼티 활용<a class="hash-link" href="#756-프레임워크에서-위임-프로퍼티-활용" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 위임 프로퍼티를 사용해 데이터베이스 칼럼 접근</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">object Users: IdTable() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val name = varchar(&quot;name&quot;, length = 50).index()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val age = integer(&quot;age&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class User(id: EntityID) : Entity(id) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var name: String by Users.name</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var age: Int by Users.age</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>User</code>의 상위 클래스인 <code>Entity</code> 클래스는 데이터베이스 칼럼을 엔티티의 속성(attribute) 값으로 연결해주는 매핑이 있습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="76-요약"></a>7.6 요약<a class="hash-link" href="#76-요약" title="Direct link to heading">#</a></h2><ul><li>코틀린에서는 정해진 이름의 함수를 오버로딩암으로써 표준 수학 연산자를 오버로딩할 수 있습니다.</li><li>비교 연산자는 <code>equals</code>와 <code>compareTo</code> 메서드로 변환됩니다.</li><li>클래스에 <code>get, set, contains</code>라는 함수를 정의하면 그 클래스의 인스턴스에 대해 <code>[]</code>와 <code>in</code> 연산을 사용할 수 있고, 그 객체를 코틀린 컬렉션 객 체와 비슷하게 다룰 수 있습니다.</li><li>미리 정해진 관례를 따라 <code>rangeTo, iterator</code> ㅎ마수를 정의하면 범위를 만들거나 컬렉션과 배열의 원소를 이터레이션할 수 있습니다.</li><li>구조 분해 선언을 통해 한 객체의 상태를 분해해서 여러 변수에 대입할 수 있습니다.</li><li>위임 프로퍼티를 통해 프로퍼티 값을 저장하거나 초기화하거나 읽거나 변경할 때 사용하는 로직을 재활용할 수 있습니다. 위임 프로퍼티는 프레임워크를 만들 때 아주 유용합니다.</li><li>표준 라이브러리 함수인 <code>lazy</code>를 통해 지연 초기화 프로퍼티를 쉽게 구현할 수 있습니다.</li><li><code>Delegates.observable</code> 함수를 사용하면 프로퍼티 변경을 관찰할 수 있는 관찰자를 쉽게 추가할 수 있습니다.</li><li>맵을 위임 객체로 사용하는 위임 프로퍼티를 통해 다양한 속성을 제공하는 객체를 유연하게 다룰 수 있습니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/kotlin/kotlin-in-action/ch7.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-08-21T23:23:22.000Z" class="lastUpdatedDate_1WI_">8/21/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 6. 코틀린 타입 시스템</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch8"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">8. 고차 함수: 파라미터와  반환 값으로 람다 사용 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#71-산술-연산자-오버로딩" class="table-of-contents__link">7.1 산술 연산자 오버로딩</a><ul><li><a href="#711-이항-산술-연산-오버로딩" class="table-of-contents__link">7.1.1. 이항 산술 연산 오버로딩</a></li><li><a href="#712-복합-대입-연산자-오버로딩" class="table-of-contents__link">7.1.2. 복합 대입 연산자 오버로딩</a></li><li><a href="#713-단항-연산자-오버로딩" class="table-of-contents__link">7.1.3. 단항 연산자 오버로딩</a></li></ul></li><li><a href="#72-비교-연산자-오버로딩" class="table-of-contents__link">7.2 비교 연산자 오버로딩</a><ul><li><a href="#721-동등성-연산자-equals" class="table-of-contents__link">7.2.1. 동등성 연산자: equals</a></li><li><a href="#722-순서-연산자-compareto" class="table-of-contents__link">7.2.2. 순서 연산자: compareTo</a></li></ul></li><li><a href="#73-컬렉션과-범위에-대해-쓸-수-있는-관례" class="table-of-contents__link">7.3 컬렉션과 범위에 대해 쓸 수 있는 관례</a><ul><li><a href="#731-인덱스로-원소에-접근-get과-set" class="table-of-contents__link">7.3.1. 인덱스로 원소에 접근: get과 set</a></li><li><a href="#732-in-관례" class="table-of-contents__link">7.3.2. in 관례</a></li><li><a href="#733-rangeto-관례" class="table-of-contents__link">7.3.3. rangeTo 관례</a></li><li><a href="#734-for-루프를-위한-iterator-관례" class="table-of-contents__link">7.3.4. for 루프를 위한 iterator 관례</a></li></ul></li><li><a href="#74-구조-분해-선언과-component-함수" class="table-of-contents__link">7.4 구조 분해 선언과 component 함수</a><ul><li><a href="#741-구조-분해-선언과-루프" class="table-of-contents__link">7.4.1. 구조 분해 선언과 루프</a></li></ul></li><li><a href="#75-프로퍼티-접근자-로직-재활용-위임-프로퍼티" class="table-of-contents__link">7.5 프로퍼티 접근자 로직 재활용: 위임 프로퍼티</a><ul><li><a href="#751-위임-프로퍼티-소개" class="table-of-contents__link">7.5.1. 위임 프로퍼티 소개</a></li><li><a href="#752-위임-프로퍼티-사용-by-lazy를-사용한-프로퍼티-초기화-지연" class="table-of-contents__link">7.5.2. 위임 프로퍼티 사용: by lazy()를 사용한 프로퍼티 초기화 지연</a></li><li><a href="#753-위임-프로퍼티-구현" class="table-of-contents__link">7.5.3. 위임 프로퍼티 구현</a></li><li><a href="#754-위임-프로퍼티-컴파일-규칙" class="table-of-contents__link">7.5.4. 위임 프로퍼티 컴파일 규칙</a></li><li><a href="#755-프로퍼티-값을-맵에-저장" class="table-of-contents__link">7.5.5. 프로퍼티 값을 맵에 저장</a></li><li><a href="#756-프레임워크에서-위임-프로퍼티-활용" class="table-of-contents__link">7.5.6. 프레임워크에서 위임 프로퍼티 활용</a></li></ul></li><li><a href="#76-요약" class="table-of-contents__link">7.6 요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.200a3fc7.js"></script>
<script src="/til/assets/js/main.b9c64efc.js"></script>
</body>
</html>