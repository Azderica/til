<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">6. 코틀린 타입 시스템 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch6"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="6. 코틀린 타입 시스템 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="- 코틀린은 널이 될수 있는 타입(nullable type)과 읽기 전용 컬렉션을 제공해줍니다."><meta data-react-helmet="true" property="og:description" content="- 코틀린은 널이 될수 있는 타입(nullable type)과 읽기 전용 컬렉션을 제공해줍니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch6"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch6" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch6" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.b1ccfb14.js" as="script">
<link rel="preload" href="/til/assets/js/main.0b469ff7.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">6. 코틀린 타입 시스템</h1></header><div class="markdown"><ul><li>코틀린은 <code>널이 될수 있는 타입(nullable type)</code>과 <code>읽기 전용 컬렉션</code>을 제공해줍니다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="61-널-가능성"></a>6.1 널 가능성<a class="hash-link" href="#61-널-가능성" title="Direct link to heading">#</a></h2><ul><li><code>널 가능성(nullability)</code>은 <code>NullPointerException</code> 오류를 필할 수 있게 돕기 위한 코틀린 타입 시스템의 특성입니다.</li><li>코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="611-널이-될-수-있는-타입"></a>6.1.1 널이 될 수 있는 타입<a class="hash-link" href="#611-널이-될-수-있는-타입" title="Direct link to heading">#</a></h3><ul><li>코틀린과 자바의 첫 번째이자 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int strLen(String s) { return s.length(); }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun strLen(s: String) = s.length</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">strLen(null)  // error</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표(?)를 명시해야 합니다.</li><li>널이 될 수 있는 타입의 변수가 있다면 그에 대한 수행할 수 있는 연산이 제한됩니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 예시</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val x: String? = null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val y: String = x</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Error: Type mismatch: inferred type is String? but Strign was expected</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// if 검사를 통해서는 null 값을 다룰 수 있습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun strLenSafe(s: String?): Int = if(s != null) x.length else 0</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="612-타입의-의미"></a>6.1.2 타입의 의미<a class="hash-link" href="#612-타입의-의미" title="Direct link to heading">#</a></h3><ul><li>null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않습니다.</li><li>이러한 의미로 자바의 타입 시스템은 널을 제대로 다루지 못합니다.</li></ul><blockquote><p>NullPointerException 오류를 다루는 다른 방법</p></blockquote><blockquote><ul><li>자바에도 <code>NullPointerException</code> 문제를 해결하는 데 <code>@Nullable</code>으나 <code>@NotNull</code>과 같은 애노테이션을 쓸 수도 있습니다. 그러나 이는 모든 문제를 해결할 수도 없습니다.</li><li>자바에서 <code>null</code> 대신 자바 8의 <code>Optional</code> 타입 등의 <code>null</code>을 감싸는 특별한 래퍼 타입을 활용할 수도 있습니다.</li></ul></blockquote><ul><li>코틀린에서 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="613-안전한-호출-연선자-"></a>6.1.3 안전한 호출 연선자: ?.<a class="hash-link" href="#613-안전한-호출-연선자-" title="Direct link to heading">#</a></h3><ul><li><code>?.</code>은 null 검사와 메서드 호출을 한 번의 연산으로 수행합니다.</li><li><code>s?.toUpperCase()</code> 는 <code>if(s != null) s.toUpperCase() else null</code>과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun printAllCaps(s: String?) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val allCaps: String? = s?.toUpperCase()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(allCaps)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printAllCaps(&quot;abc&quot;) // ABC</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printAllCaps(null)  // null</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>메서드 호출 뿐 아니라, 프로퍼티를 읽을 때도 안전한 호출이 가능합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Company(val name: String, val address: Address?)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val name: String, val company: Company?)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun Person.countryName(): String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val country = this.company?.address?.country</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return if(country != null) country else &quot;Unknown&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(Person(&quot;Dmitry&quot;, null).countryName()) // Unknown</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="614-엘비스-연산자-"></a>6.1.4 엘비스 연산자: ?:<a class="hash-link" href="#614-엘비스-연산자-" title="Direct link to heading">#</a></h3><ul><li>코틀린은 <code>null</code> 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공하며 이 연산자를 <code>엘비스(elvis)</code> 연산자라고 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun foo(s: String?) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val t: String = s ?: &quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun strLenSafe(s: String?): Int = s?.length ?:0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(strLenSafe(&quot;abc&quot;))  // 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(strLenSafe(null))   // 0</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun Person.countryName() = company?.address?.country?:&quot;Unknown&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린에서는 return 이나 throw 등의 연산도 식이므로, 엘비스 연산자를 사용할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Company(val name: String, val address: Address?)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val name: String, val company: Company?)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun printShippingLabel(person: Person) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val address = person.company?.address?:throw illegalArgumentException(&quot;No address&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  with (address) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(streetAddress)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(&quot;$zipCode $city, $country&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val address = Address(&quot;Elesestr. 47&quot;, 80687, &quot;Munich&quot;, &quot;Germany&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val jetbrains = Company(&quot;JetBrains&quot;, address)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val person = Person(&quot;Dmitry&quot;, jetbrains)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printShippingLabel(person)  // Elesestr. 47 /n 80687 Munich, Germany</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printShippingLable(Person(&quot;Alexey&quot;, null))  // Exception, No address</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="615-안전한-캐스-as"></a>6.1.5 안전한 캐스: as?<a class="hash-link" href="#615-안전한-캐스-as" title="Direct link to heading">#</a></h3><ul><li><code>as?</code> 연산자는 어떤 값을 지정한 타입으로 캐스트합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val firstName: String, val lastName: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun equals(o: Any?): Boolean {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val otherPerson = o as? Person ?: return false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun hashCode(): Int = firstName.hashCode() * 37 + lastName.hashCode()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p1 = Person(&quot;Dmitry&quot;, &quot;Jemerov&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val p2 = Person(&quot;Dmitry&quot;, &quot;Jemerov&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(p1 == p2) // true</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(p1.equals(42))  // false</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>이 패턴을 사용하면 파라미터로 받은 값이 원하는 타입인지쉽게 검사하고 캐스트할 수 있으며, 타입이 맞지않으면 쉽게 false를 반환할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="616-널-아님-단언-"></a>6.1.6 널 아님 단언: !!<a class="hash-link" href="#616-널-아님-단언-" title="Direct link to heading">#</a></h3><ul><li><code>not-null assertion</code>은 코틀린에서 널이 될 수 있는 타입의 값을 다룰 때, 사용할 수 있는 도구 중 가장 단순한 도구 입니다.</li><li><code>!!</code> 를 사용하면 어떤 값이든 널이 될 수 없는 타입으로 바꿀 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun ignoreNulls(s: String?) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val sNotNull: String = s!!</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(sNotNull.length)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}9</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ignoreNulls(null) // exception</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위와 같이 작성을 하면, null이면 예외가 발생해도 감수함을 의미합니다.</li><li>일반적으로는 다음과 같이 작성하는 것이 좋습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class CopyRowAction(val list: JList&lt;String&gt;): AbstractAction() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun isEnabled(): Boolean = list.selectedValue != null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun actionPerformed(e: ActionEvent) { val value = list.selectedValue!! }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="617-let-함수"></a>6.1.7 let 함수<a class="hash-link" href="#617-let-함수" title="Direct link to heading">#</a></h3><ul><li><code>let</code> 함수를 통해, 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 통해 한꺼번에 처리할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun sendEmailTo(email: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(&quot;Sending email to $email&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var email: String? = &quot;a@example.com&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">email?.let { sendEmailTo(it) }  //  &quot;a@example.com&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코드를 아래와 같이 간단하게 만들 수도 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// before</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val person: Person? = getThreBestPersonInTheWorld()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">if (person != null) sendEmailTo(person.email)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// after</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">getThreBestPersonInTheWorld()?.let { sendEmailTo(it.email) }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="618-나중에-초기화할-프로퍼티"></a>6.1.8 나중에 초기화할 프로퍼티<a class="hash-link" href="#618-나중에-초기화할-프로퍼티" title="Direct link to heading">#</a></h3><ul><li>코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메서드 안에서 초기화할 수 없습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Null 이 될 수 있는 프로퍼티 접근, 다만 코드가 지저분함</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class myService { fun performAction(): String = &quot;foo&quot; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class MyTest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private var myService: MyService? = null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Before fun setUp() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    myService = MyService()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Test fun testAction() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Assert.assertEquals(&quot;foo&quot;, myService!!.performAction())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>이러한 못생긴 코드를 해결하기 위해서 <code>late-initialized</code> 할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class myService { fun performAction(): String = &quot;foo&quot; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class MyTest {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private lateinit var myService: MyService</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Before fun setUp() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    myService = MyService()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  @Test fun testAction() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    Assert.assertEquals(&quot;foo&quot;, myService.performAction())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>나중에 초기화하는 프로퍼티는 항상 <code>var</code> 이여야 합니다.</li><li>이를 초기화하기 전에 접근하면, <code>lateinit preopert ... has not been initialized</code>라는 예외가 발생합니다.</li><li>일반적으로 <code>lateinit</code> 프로퍼티를 의존관계 주입(DI) 프레임워크와 함께 사용하는 경우가 많습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="619-널이-될-수-있는-타입-확장"></a>6.1.9 널이 될 수 있는 타입 확장<a class="hash-link" href="#619-널이-될-수-있는-타입-확장" title="Direct link to heading">#</a></h3><ul><li>널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있습니다.</li><li>확장 함수의 경우, 직접 변수에 대해 메서드를 호출하면 알아서 널 차리를 해줍니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// null이 될 수 있는 수신 객체에 대해 확장 함수 호출</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun verifyUserInput(input: String?) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  if(input.isNullOrBlank()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(&quot;Please fill in the required fields&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">verifyUserInput(&quot; &quot;)  // &quot;Please fill in the required fields&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">verifyUserInput(null) // &quot;Please fill in the required fields&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>자바에서는 메서드 안의 this는 그 메서드가 호출된 수신 객체를 가리키므로 항상 널이 아닙니다.</li><li>코틀린에서는 앞에서 살펴본 let 함수도 널이 될 수 있는 타입의 값에 대해 호출할 수 있지만 let은 this가 널인지 검사하지 않습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val person: Person? = ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">person.let { sendEmailTo(it) }    // Error: Type mismatch: inferred type is Person? but Person was expected</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><blockquote><p>확장 함수를 작성한다면, 확장 함수를 널이 될 수 있는 타입에 대해 정의할지 여부를 고민할 필요가 있습니다. 처음에는 널이 될 수 없는 타입에 대한 확장 함수를 정의하고, 나중에 널이 될 수 있는 타입에 대해 호출했다면 여기서 널을 제대로 처리하게 되면 안전하게 그 확장 함수를 널이 될 수 있는 타입에 대한 확장 함수로 바꿀 수 있습니다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="6110-타입-파라미터의-널-가능성"></a>6.1.10 타입 파라미터의 널 가능성<a class="hash-link" href="#6110-타입-파라미터의-널-가능성" title="Direct link to heading">#</a></h3><ul><li>다음은 널이 될 수 있는 예시입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun &lt;T&gt; printHashCode(t: T) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(t?.hashCode())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printHashCode(null) // null, 해당 경우 &quot;T&quot;의 타입은 &quot;Any?&quot;로 추론됩니다.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한(upper bound)를 지정해야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 널이 될 수 없도록 상한을 사용합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun &lt;T: Any&gt; printHashCode(t: T) {  // T는 널이 될 수 없는 타입입니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(t.hashCode())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printHashCode(null) // Error, 이 코드는 컴파일 되지 않습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">printHashCode(42)   // 42</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>타입 파라미터는 널이 될 수 있는 타입을 표시하려면 반드시 물음표를 타입 이름 뒤에 붙여야 한다는 규칙의 유일한 예외입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="6111-널-가능성과-자바"></a>6.1.11 널 가능성과 자바<a class="hash-link" href="#6111-널-가능성과-자바" title="Direct link to heading">#</a></h3><ul><li>자바와 코틀린을 같이 사용하는 경우, 안전하게 하기 위해서는 신경써야 하는 부분이 있습니다.</li><li>자바의 경우, 애노테이션으로 널 가능성 정보를 지정할 수 있습니다.<ul><li><code>@Nullable Type</code> = <code>Type?</code></li><li><code>@NotNull Type</code> = <code>Type</code></li></ul></li><li>널 가능성 애노테이션이 소스코드에 없는 경우에는 자바의 타입은 코틀린의 플랫폼 타입(platform type)이 됩니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="플랫폼-타입"></a>플랫폼 타입<a class="hash-link" href="#플랫폼-타입" title="Direct link to heading">#</a></h4><ul><li>플랫폼 타입은 코틀린이 널 관련 정보를 알 수 없는 타입을 의미합니다.<ul><li><code>Type</code> = <code>Type?</code> or <code>Type</code></li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">public class Person {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  private final String anme;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public Person(String name) { this.name = name; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  public String getName() { return name; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위의 코드에서는 코틀린 컴파일러는 String 타입의 널 가능성에 대해 전혀 알지 못합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun yellAt(person: Person) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println(person.name.toUpperCase() + &quot;!!!&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">yellAt(Person(null))  //   java.lang.IllegalArgumentException: Paramter specified as non-null is null</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린 컴파일러는 공개(public) 가시성인 코틀린 함수의 널이 아닌 타입인 파라미터와 수신 객체에 대한 널 검사를 추가해줍니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun yellAtSafe(person: Person) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  println((person.name ?: &quot;AnyOne&quot;).toUpperCase() + &quot;!!!&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">yellAtSafe(Person(null))  // ANYONE!!!</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린은 플랫폼 타입을 통해서, 불필요한 널 검사를 줄일 수 있습니다.</li><li>특히 제네릭을 다룰 때 상황이 안좋아지기 때문에, 이를 프로그래머에게 책임을 부여하는 실용적인 접근 방법을 사용합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val s: String? = person.name  // 자바 프로퍼티를 널이 될 수 있는 타입으로 볼 수 있습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val s1: String = person.name  // 자바 프로퍼티를 널이 될 수 없는 타입으로도 볼 수 있습니다.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="상속"></a>상속<a class="hash-link" href="#상속" title="Direct link to heading">#</a></h4><ul><li>코틀린에서 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 널이 도리 수 잇는 타입으로 선언할지 널이 될 수 없는 타입으로 선언할지 결정해야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface StringProcessor { void process(String value); }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 코틀린에서 자바 인터페이스를여러 다른 널 가능성으로 구현합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class StringPrinter : StringProcessor {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun process(value: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(value)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class NullableStringPrinter : StringProcessor {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun process(value: String?) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(value != null) { println(value) }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>자바 클래스나 인터페이스를 코틀린에서 구현할 경우 널 가능성을 제대로 처리하는 일이 중요합니다.</li><li>코틀린 컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어 줄 수 있습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="62-코틀린의-원시-타입"></a>6.2 코틀린의 원시 타입<a class="hash-link" href="#62-코틀린의-원시-타입" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="621-원시-타입-int-boolean-등"></a>6.2.1 원시 타입: Int, Boolean 등<a class="hash-link" href="#621-원시-타입-int-boolean-등" title="Direct link to heading">#</a></h3><ul><li>자바는 원시 타입(primitive type)과 참조 타입(reference type)이 있지만, 코틀린은 원시 타입과 래퍼 타입을 구분하지 않으며 항상 같은 타입을 사용합니다.</li><li>코틀린은 실행 시점에 숫자 타입은 가능한 가장 효율적인 방식으로 표현됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="622-널이-될-수-있는-원시-타입-int-boolean-등"></a>6.2.2 널이 될 수 있는 원시 타입: Int?, Boolean? 등<a class="hash-link" href="#622-널이-될-수-있는-원시-타입-int-boolean-등" title="Direct link to heading">#</a></h3><ul><li>널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없으므로, 자바의 래퍼 타입으로 컴파일됩니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">data class Person(val name: String, val age: Int? = null) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun isOlderThan(other: Person): Boolean? {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(age == null || other.age == null)  return null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return age &gt; other.age</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(Person(&quot;Sam&quot;, 35).isOlderThan(Person(&quot;Amy&quot;, 42))) // false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(Person(&quot;Sam&quot;, 35).isOlderThan(Person(&quot;Jane&quot;)))    // null</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>제네릭 클래스의 경우 래퍼 타입을 사용합니다.</li><li>JVM은 타입 인자로 원시 타입을 허용하지 않기 때문에 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="623-숫자-변환"></a>6.2.3 숫자 변환<a class="hash-link" href="#623-숫자-변환" title="Direct link to heading">#</a></h3><ul><li>코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// &quot;Error: type mismatch&quot; 컴파일 오류 발생</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val i = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val l: Long = i</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 정상</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val i = 1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val l: Long = i.toLong()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린은 모든 원시 타입에 대한 변환 함수를 제공합니다. (<code>Boolean</code> 제외)</li><li>코틀린은 개발자의 혼란을 피하기 위해 <strong>타입 변환를 명시</strong>합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="624-any-any-최상위-타입"></a>6.2.4 Any, Any?: 최상위 타입<a class="hash-link" href="#624-any-any-최상위-타입" title="Direct link to heading">#</a></h3><ul><li><code>Any</code> 타입이 <strong>모든 널이 될 수 없는 타입의 조상 타입</strong>입니다.<ul><li><code>val answer: Any = 42</code></li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="625-unit-타입-코틀린의-void"></a>6.2.5 Unit 타입: 코틀린의 void<a class="hash-link" href="#625-unit-타입-코틀린의-void" title="Direct link to heading">#</a></h3><ul><li>코틀린 <code>Unit</code> 타입은 자바 패ㅑㅇdhk rkxdms rlsmddmf gkqslek.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 아래는 같은 의미힙ㄴ디ㅏ.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun f(): Unit { ... }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun f() { ... }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린 <code>Unit</code>은 모든 기능을 갖는 일반적인 타입이며, <code>void</code>와 달리 타입 인자로 사용할 수 있습니다.</li><li>다음과 같이 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 <code>Unit</code>을 쓸 때 유용합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface Processor&lt;T&gt; { fun process(): T }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class NoResultProcessor : Processor&lt;Unit&gt; {   </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun process() {  // Unit을 반환하지만 타입 지정의 필요가 없습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // 업무 처리 코드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  } // return 명시 필요가 없습니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>Unit</code>은 <strong>단 하나의 인스턴스만 갖는 타입</strong>을 의미합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="626-nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다"></a>6.2.6 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다<a class="hash-link" href="#626-nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다" title="Direct link to heading">#</a></h3><ul><li>코틀린에서는 반환 값이라는 개념 자체가 의미 없는 함수가 일부 존재합니다.</li><li>함수가 정상적으로 끝나지 않는다는 사실을 알기 위해서 <code>Nothing</code>이라는 특별한 반환 타입이 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun fail(message: String): Nothing {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  throw IllegalStateException(message)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fail(&quot;Error occurred&quot;)  // java.lang.IllegalStateException: Error occurred</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>Nothing</code> 타입은 아무 값도 포함하지 않으며, 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있습니다.</li><li><code>Nothing</code> 은 아무 값도 저장할 수 없으므로 아무 의미가 없습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val address = company.address ?: fail(&quot;No address&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(address.city)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="63-컬렉션과-배열"></a>6.3 컬렉션과 배열<a class="hash-link" href="#63-컬렉션과-배열" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="631-널-가능성과-컬렉션"></a>6.3.1 널 가능성과 컬렉션<a class="hash-link" href="#631-널-가능성과-컬렉션" title="Direct link to heading">#</a></h3><ul><li>널 가능성은 타입 시스템 일관성을 지키기 위해 필수적입니다.</li><li><code>List&lt;Int?&gt;</code> 와 <code>List&lt;Int&gt;?</code> 는 다릅니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="632-읽기-전용과-변경-가능한-컬렉션"></a>6.3.2 읽기 전용과 변경 가능한 컬렉션<a class="hash-link" href="#632-읽기-전용과-변경-가능한-컬렉션" title="Direct link to heading">#</a></h3><ul><li>코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 중 하나는 <strong>코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리한 점</strong>입니다.</li><li>컬렉션의 데이터를 수정하려면 <code>kotlin.collections.MutableCollection</code> 인터페이스를 사용해야 합니다.</li><li>컬렉션의 읽기 전용 인터페이스와 변경 가능 인터페이스를 구별함으로서 프로그램에서 데이터에 어떤 일이 벌어지는지를 더 쉽게 이해할 수 있게 됩니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun &lt;T&gt; copyElements(source: Collection&lt;T&gt;, target: MutableCollection&lt;T&gt;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  for(item in source) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    target.add(item)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val source: Collection&lt;Int&gt; = arrayListOf(3, 5, 7)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val target: MutableCollection&lt;Int&gt; = arrayListOf(1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">copyElements(source, target)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(target) // 1, 3, 5, 7</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val source: Collection&lt;Int&gt; = arrayListOf(3, 5, 7)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val target: Collection&lt;Int&gt; = arrayListOf(1)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">copyElements(source, target)  // error</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위 코드에서 source 컬렉션은 변경하지 못하지만, target 컬렉션의 경우 변경가능함을 알 수 있습니다.</li><li>다만, 읽기 전용 컬렉션은 항상 <strong>스레드 안전(thread safe)</strong> 하지는 않습니다.</li><li>다중 스레드 환경에서 데이터를 다루는 경우 데이터를 적절하게 동기화하거나 동시 접근을 허용하는 데이터 구조를 활용해야 합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="633-코틀린-컬렉션과-자바"></a>6.3.3 코틀린 컬렉션과 자바<a class="hash-link" href="#633-코틀린-컬렉션과-자바" title="Direct link to heading">#</a></h3><p><img src="https://user-images.githubusercontent.com/42582516/169536424-31796592-afc7-4c35-9f49-4f4edb05eb8d.png" alt="kotlin-collection-interface"></p><blockquote><p>초록색은 읽기 전용, 주황색은 변경 가능, 하늘색은 자바 클래스를 의미합니다.</p></blockquote><ul><li>다른 컬렉션의 예시는 아래와 같습니다.</li></ul><table><thead><tr><th>컬렉션 타입</th><th>읽기 전용 타입</th><th>변경 가능 타입</th></tr></thead><tbody><tr><td>List</td><td>listOf</td><td>mutableListOf, arrayListOf</td></tr><tr><td>Set</td><td>setOf</td><td>mutableSetOf, hashSetOf, linkedSetOf, sortedSetOf</td></tr><tr><td>Map</td><td>mapOf</td><td>mutableMapOf, hashMapOf, linkedMapOf, sortedMapOf</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="634-컬렉션을-플랫폼-타입으로-다루기"></a>6.3.4 컬렉션을 플랫폼 타입으로 다루기<a class="hash-link" href="#634-컬렉션을-플랫폼-타입으로-다루기" title="Direct link to heading">#</a></h3><ul><li>컴파일러는 코틀린 코드가 그 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입 어느 쪽으로 사용할 수 있게 허용합니다.</li><li>자바 인터페이스가 파일에 들어가는 텍스트를 처리하는 객체를 표현하는 예시입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface FileContentProcessor {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void processContents(File path, byte[] binaryContents, List&lt;String&gt; textContents);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class FileIndexer : FileContentProcessor {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun processContents(path: File, binaryContents: ByteArray?, textContexts: List&lt;String&gt;?) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    //...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>컬렉션 파라미터가 있는 다른 자바 인터페이스 예시입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface DataParser&lt;T&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  void parseData(String input, List&lt;T&gt; output, List&lt;String&gt; errors);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class PersonParser: DataParser&lt;Person&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun parseData(input: String, output: MutableList&lt;Person&gt;, errors: MutableList&lt;Person&gt;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="635-객체의-배열과-원시-타입의-배열"></a>6.3.5 객체의 배열과 원시 타입의 배열<a class="hash-link" href="#635-객체의-배열과-원시-타입의-배열" title="Direct link to heading">#</a></h3><ul><li>코틀린에서 배열을 만드는 방법은 다음과 같습니다.<ul><li><code>arrayOf</code> 함수에 원소를 넘기면 배열을 만들 수 있습니다.</li><li><code>arrayOfNulls</code> 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크기가 같은 배열을 만들 수 있습니다.</li><li><code>Array</code> 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해줍니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val letters = Array&lt;String&gt;(26) { i -&gt; (&#x27;a&#x27; + i).toString() }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(letters.jointToString(&quot;&quot;))  // abcdefghijklmnopqrstuvwxyz</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="64-요약"></a>6.4 요약<a class="hash-link" href="#64-요약" title="Direct link to heading">#</a></h2><ul><li>코틀린은 널이 될 수 있는 타입을 지원해 <code>NullPointerException</code> 오류를 컴파일 시점에 감지할 수 있습니다.</li><li>코틀린의 <code>?.</code>, <code>?:</code> <code>!!</code>, <code>let</code> 함수 등을 사용하면 널이 될 수 잇는 타입을 간결한 코드로 다룰 수 있습니다.</li><li><code>as?</code> 연산자를 사용하면 값을 다른 타입으로 변환하는 것과 변환이 불가능한 경우를 처리하는 것을 한꺼번에 편리하게 처리할 수 있습니다.</li><li>자바에서 가져온 타입은 코틀린에서 플랫폼 타입으로 취급됩니다.</li><li>코틀린에서는 수를 표현하는 타입이 일반 클래스와 똑같이 생겼고 일반 클래스와 똑같이 동작합니다.</li><li>널이 될 수 있는 원시 타입(Int? 등)은 자바의 <code>박싱한 원시 타입(java.lang.Integer)</code>에 대응합니다.</li><li><code>Any</code> 타입은 다른 모든 타입의 조상 타입이며, 자바의 <code>Object</code>에 해당합니다. <code>Unit</code> 은 자바의 <code>void</code>와 비슷합니다.</li><li>정상적으로 끝나지 않는 함수의 반환 타입을 지정할 때 <code>Nothing</code> 타입을 사용합니다.</li><li>코틀린 컬렉션은 표준 자바 컬렉션 클래스를 사용합니다. 그러나 코틀린은 자바보다 컬렉션을 더 개선해서 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해 제공합니다.</li><li>자바 클래스를 코틀린에서 확장하거나 자바 인터페이스를 코틀린에서 구현하는 경우, 메서드 파라미터의 널 가능성과 변경 가능성에 대해 생각해야합니다.</li><li>코틀린의 <code>Array</code> 클래스는 일반 제네릭 클래스처럼 보입니다.</li><li>원시타입의 배열은 <code>IntArray</code>와 같이 각 타입에 대한 특별한 배열로 표현합니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/kotlin/kotlin-in-action/ch6.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-07-28T13:26:17.000Z" class="lastUpdatedDate_1WI_">7/28/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch5"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 5. 람다로 프로그래밍</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch7"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">7. 연산자 오버로딩과 기타 관례 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#61-널-가능성" class="table-of-contents__link">6.1 널 가능성</a><ul><li><a href="#611-널이-될-수-있는-타입" class="table-of-contents__link">6.1.1 널이 될 수 있는 타입</a></li><li><a href="#612-타입의-의미" class="table-of-contents__link">6.1.2 타입의 의미</a></li><li><a href="#613-안전한-호출-연선자-" class="table-of-contents__link">6.1.3 안전한 호출 연선자: ?.</a></li><li><a href="#614-엘비스-연산자-" class="table-of-contents__link">6.1.4 엘비스 연산자: ?:</a></li><li><a href="#615-안전한-캐스-as" class="table-of-contents__link">6.1.5 안전한 캐스: as?</a></li><li><a href="#616-널-아님-단언-" class="table-of-contents__link">6.1.6 널 아님 단언: !!</a></li><li><a href="#617-let-함수" class="table-of-contents__link">6.1.7 let 함수</a></li><li><a href="#618-나중에-초기화할-프로퍼티" class="table-of-contents__link">6.1.8 나중에 초기화할 프로퍼티</a></li><li><a href="#619-널이-될-수-있는-타입-확장" class="table-of-contents__link">6.1.9 널이 될 수 있는 타입 확장</a></li><li><a href="#6110-타입-파라미터의-널-가능성" class="table-of-contents__link">6.1.10 타입 파라미터의 널 가능성</a></li><li><a href="#6111-널-가능성과-자바" class="table-of-contents__link">6.1.11 널 가능성과 자바</a></li></ul></li><li><a href="#62-코틀린의-원시-타입" class="table-of-contents__link">6.2 코틀린의 원시 타입</a><ul><li><a href="#621-원시-타입-int-boolean-등" class="table-of-contents__link">6.2.1 원시 타입: Int, Boolean 등</a></li><li><a href="#622-널이-될-수-있는-원시-타입-int-boolean-등" class="table-of-contents__link">6.2.2 널이 될 수 있는 원시 타입: Int?, Boolean? 등</a></li><li><a href="#623-숫자-변환" class="table-of-contents__link">6.2.3 숫자 변환</a></li><li><a href="#624-any-any-최상위-타입" class="table-of-contents__link">6.2.4 Any, Any?: 최상위 타입</a></li><li><a href="#625-unit-타입-코틀린의-void" class="table-of-contents__link">6.2.5 Unit 타입: 코틀린의 void</a></li><li><a href="#626-nothing-타입-이-함수는-결코-정상적으로-끝나지-않는다" class="table-of-contents__link">6.2.6 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다</a></li></ul></li><li><a href="#63-컬렉션과-배열" class="table-of-contents__link">6.3 컬렉션과 배열</a><ul><li><a href="#631-널-가능성과-컬렉션" class="table-of-contents__link">6.3.1 널 가능성과 컬렉션</a></li><li><a href="#632-읽기-전용과-변경-가능한-컬렉션" class="table-of-contents__link">6.3.2 읽기 전용과 변경 가능한 컬렉션</a></li><li><a href="#633-코틀린-컬렉션과-자바" class="table-of-contents__link">6.3.3 코틀린 컬렉션과 자바</a></li><li><a href="#634-컬렉션을-플랫폼-타입으로-다루기" class="table-of-contents__link">6.3.4 컬렉션을 플랫폼 타입으로 다루기</a></li><li><a href="#635-객체의-배열과-원시-타입의-배열" class="table-of-contents__link">6.3.5 객체의 배열과 원시 타입의 배열</a></li></ul></li><li><a href="#64-요약" class="table-of-contents__link">6.4 요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.b1ccfb14.js"></script>
<script src="/til/assets/js/main.0b469ff7.js"></script>
</body>
</html>