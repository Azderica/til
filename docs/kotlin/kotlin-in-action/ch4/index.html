<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">4. 클래스, 객체, 인터페이스 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch4"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="4. 클래스, 객체, 인터페이스 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="4.1 클래스 계층 정의"><meta data-react-helmet="true" property="og:description" content="4.1 클래스 계층 정의"><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch4"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch4" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.aa396546.js" as="script">
<link rel="preload" href="/til/assets/js/main.b2125fab.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">4. 클래스, 객체, 인터페이스</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="41-클래스-계층-정의"></a>4.1 클래스 계층 정의<a class="hash-link" href="#41-클래스-계층-정의" title="Direct link to heading">#</a></h2><ul><li>코틀린 가시성/접근 변경자는 자바와 비슷하지만 아무것도 지정하지 않은 경우 기본 가시성은 다릅니다.</li><li><code>sealed</code>은 클래스 상속을 제한합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="411-코틀린-인터페이스"></a>4.1.1 코틀린 인터페이스<a class="hash-link" href="#411-코틀린-인터페이스" title="Direct link to heading">#</a></h3><ul><li>다음과 같은 예시가 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface Clickable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun click()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Button: Clickable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun click() = println(&quot;I was clicked&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린에서는 override 변경자를 꼭 사용해야합니다.</li><li>디폴트 메서드도 사용할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface Clickable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun click()   // 일반 메서드 선언</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun showoff() = println(&quot;I&#x27;m clickable!&quot;) // 디폴트 구현이 있는 메서드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface Focusable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun showOff() = println(&quot;I&#x27;m focusable!&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린 컴파일러는 두 메서드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Button: Clickable, Focusable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun click() = println(&quot;I was clicked&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun shoOff() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    super&lt;Clickable&gt;.showOff()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    super&lt;Focusable&gt;.showOff()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린은 자바 6와 호환되게 설계되었습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="412-open-final-abstract-변경자-기본적으로-final"></a>4.1.2 open, final, abstract 변경자: 기본적으로 final<a class="hash-link" href="#412-open-final-abstract-변경자-기본적으로-final" title="Direct link to heading">#</a></h3><ul><li>취약한 기반 클래스(fragile base class)와 같은 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로 깨져버린 경우에 생깁니다.</li><li>코틀린의 클래스와 메서드는 기본적으로 <code>final</code>입니다.</li><li>상속을 허용하려면 클래스 앞에 <code>open</code> 변경자를 붙여야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">open class RichButton: Clickable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun disable() {}      // 이 함수는 파이널입니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  open fun animate() {} // 하위 클래스에서 이 메서드를 오버라이드해도 됩니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun click() {} // 이 함수는 상위 클래스에서 열려있는 메서드를 오버라이드합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>오버라이드를 금지하려면 <code>final</code>을 명시해야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">open class RichButton: Clickable {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  final override fun click() {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>final을 통해 다양한 경우에 스마트 캐스트가 가능합니다.</li><li>abstract로 선언한 추상 클래스는 인스턴스화할 수 없습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">abstract class Animated {   // 추상 클래스</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  abstract fun animate()    // 추상 함수</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  open fun stopAnimating() {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun animateTwice() {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위를 요약하면 다음과 같습니다.</li></ul><table><thead><tr><th>변경자</th><th>오버라이드 관련</th><th>설명</th></tr></thead><tbody><tr><td><code>final</code></td><td>오버라이드할 수 없음</td><td>클래스 멤버의 기본 변경자</td></tr><tr><td><code>open</code></td><td>오버라이드할 수 있음</td><td>반드시 open을 명시해야 오버라이드할 수 있음</td></tr><tr><td><code>abstract</code></td><td>반드시 오버라이드해야함</td><td>추상 클래스의 멤버에만 변경자를 붙일 수 있음</td></tr><tr><td><code>override</code></td><td>상위 클래스나 상위 인스턴스의 멤버를 오버라이드</td><td>오버라이드하는 멤버는 기본적으로 열려있음</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="413-가시성-변경자-기본적으로-공개"></a>4.1.3 가시성 변경자: 기본적으로 공개<a class="hash-link" href="#413-가시성-변경자-기본적으로-공개" title="Direct link to heading">#</a></h3><ul><li>가시성 변경자는 자바와 비슷하지만 패키지 전용(package-private)는 없습니다.</li><li>코틀린에서는 internal이 새로 등장했습니다.</li></ul><table><thead><tr><th>변경자</th><th>클래스 멤버</th><th>최상위 선언</th></tr></thead><tbody><tr><td><code>public</code></td><td>모든 곳에서 볼 수 있음</td><td>모든 곳에서 볼 수 있음</td></tr><tr><td><code>internal</code></td><td>같은 모듈 안에서만 볼 수 있음</td><td>같은 모듈 안에서만 볼 수 있음</td></tr><tr><td><code>protected</code></td><td>하위 클래스 안에서만 볼 수 있음</td><td>(최상위 선언에 적용할 수 없음)</td></tr><tr><td><code>private</code></td><td>같은 클래스 안에서만 볼 수 있음</td><td>같은 파일 안에서만 볼 수 있음</td></tr></tbody></table><ul><li>코틀린을 자바로 변경시, private을 package-private로 컴파일합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="414-내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스"></a>4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스<a class="hash-link" href="#414-내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" title="Direct link to heading">#</a></h3><ul><li>자바처럼 코틀린에서도 클래스 안에 다른 클래스를 선언할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Button : View {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun getCurrentState() : State = ButtonState()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun restoreState(state: State) { /*...*/ }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  class ButtonState : State { /*...*/ }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>자바와 코틀린의 중첩 클래스와 내부 클래스의 관계입니다.</li></ul><table><thead><tr><th>클래스 B 안에 정의된 클래스 A</th><th>자바</th><th>코틀린</th></tr></thead><tbody><tr><td>중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음)</td><td><code>static class A</code></td><td><code>class A</code></td></tr><tr><td>내부 클래스(바깥쪽 클래스에 대한 참조를 저장함)</td><td><code>class A</code></td><td><code>inner class A</code></td></tr></tbody></table><ul><li>Inner 안에서 바깥쪽 클래스 Outer의 참조에 접근하려면 <code>this@Outer</code>라고 써야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Outer {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  inner class Inner {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fun getOuterReference(): Outer = this@Outer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="415-봉인된-클래스-클래스-계층-정의-시-계층-확장-제한"></a>4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한<a class="hash-link" href="#415-봉인된-클래스-클래스-계층-정의-시-계층-확장-제한" title="Direct link to heading">#</a></h3><ul><li>코틀린은 상위 클래스에 sealed 변경자를 통해 상위 클래스를 상속환 하위 클래스 정의를 제한할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">sealed class Expr {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  class Num(val value: Int) : Expr()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  class Sum(val left: Expr, val right: Expr) : Expr()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun eval(e: Expr): Int =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  when (e) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    is Expr.Num -&gt; e.value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    is Expr.Sum -&gt; eval(e.right) + eval(e.left)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="42-뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언"></a>4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언<a class="hash-link" href="#42-뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언" title="Direct link to heading">#</a></h2><ul><li>코틀린은 주(primary) 생성자와 부(secondary) 생성자를 구분합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="421-클래스-초기화-주-생성자와-초기화-블록"></a>4.2.1 클래스 초기화: 주 생성자와 초기화 블록<a class="hash-link" href="#421-클래스-초기화-주-생성자와-초기화-블록" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class User constructor(_nickname: String) { // 주 생성자</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val nickname: String</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  init {    // 초기화 블록</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    nickname = _nickname</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>constructor</code> 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용하고, <code>init</code> 키워드는 초기화 블록을 시작합니다</li><li>초기화 블록은 주 생성자와 함께 사용됩니다.</li><li>클래스 정의 시 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 인자가 없는 디폴트 생성자를 만듭니다.</li><li>클래스를 외부에서 인스턴스화하지 못하게 하려면 private으로 만들면 됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="422-뷰-생성자-상위-클래스를-다른-방식으로-초기화"></a>4.2.2 뷰 생성자: 상위 클래스를 다른 방식으로 초기화<a class="hash-link" href="#422-뷰-생성자-상위-클래스를-다른-방식으로-초기화" title="Direct link to heading">#</a></h3><blockquote><p>인자에 대한 디폴트 값을 제공하기 위해 부 생성자를 여러개 만들지 말고 파라미터의 디폴트 값을 생성자 시그니처에 명시해야 합니다.</p></blockquote><ul><li>생성자는 여러 필요한 경우가 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">open class View {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor(ctx: Context) { /* 코드 */ }  // 부 생성자</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor(ctx: Context, attr: AttributeSet) { /* 코드 */ }  // 부 생성자</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class MyButton: View {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor(ctx: Context) : super(ctx) { /* 코드 */}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) { /* 코드 */}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위는 생성자를 위임한 예시입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="423-인터페이스에-선언된-프로퍼티-구현"></a>4.2.3 인터페이스에 선언된 프로퍼티 구현<a class="hash-link" href="#423-인터페이스에-선언된-프로퍼티-구현" title="Direct link to heading">#</a></h3><ul><li>인터페이스는 아무 상태를 포함할 수 없으므로 상태를 저장할 필요가 있다면 인터페이스를 구현한 하위 클래스에서 상태 저장을 위한 프로퍼티를 만들어야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class PrivateUser(override val nickname: String) : User // 주 생성자에 있는 프로퍼티</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class SubscribingUser(val email: String) : User {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override val nickname: String</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    get() = email.substringBefore(&#x27;@&#x27;)  // 커스텀 게터</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class FacebookUser(val accountId: Int) : User {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override val nickname = getFacebookName(accountId)  // 프로퍼티 초기화 식</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>인터페이스에 선언된 프로퍼티와 달리 클래스에 구현된 프로퍼티는 뒷받침하는 필드를 원하는 대로 사용할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="424-게터와-세터에서-뒷받침하는-필드에-접근"></a>4.2.4 게터와 세터에서 뒷받침하는 필드에 접근<a class="hash-link" href="#424-게터와-세터에서-뒷받침하는-필드에-접근" title="Direct link to heading">#</a></h3><ul><li>코틀린에서 프로퍼티의 값을 바꿀 때는 <code>user.address = &quot;new value&quot;</code>처럼 필드 설정 구문을 사용합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 새터에서 뒷받침하는 필드 접근</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class User(val name: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var address: String = &quot;unspecified&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    set(value: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      println(&quot;&quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        Address was changed for $name:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        &quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trimIndent())</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      field = value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>변경 가능 프로퍼티의 게터와세터 중 한쪽만 직접 정의해도 됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="425-접근자의-가시성-변경"></a>4.2.5 접근자의 가시성 변경<a class="hash-link" href="#425-접근자의-가시성-변경" title="Direct link to heading">#</a></h3><ul><li><code>get</code>이나 <code>set</code> 앞에 가시성 변경자를 추가해서 접근성의 가시성을 변경할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 비공개 세터가 있는 프로퍼티 선언하기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class LengthCounter {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var counter: Int = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    private set</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun addWord(word: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    counter += word.length</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="43-컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임"></a>4.3 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임<a class="hash-link" href="#43-컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임" title="Direct link to heading">#</a></h2><ul><li>코틀린은 유용한 메서드를 자동으로 만들어주는 예와 클래스 위임 패턴을 아주 간단하게 쓸 수 있게 해줍니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="431-모든-클래스가-정의해야-하는-메서드"></a>4.3.1 모든 클래스가 정의해야 하는 메서드<a class="hash-link" href="#431-모든-클래스가-정의해야-하는-메서드" title="Direct link to heading">#</a></h3><ul><li>자바와 마찬가지로 코틀린 클래스도 <code>toString, equals, hashCode</code> 등을 오버라이드할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Client(val name: String, val postalCode: Int) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // equals</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun equals(other: Any?): Boolean {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(other == null || other !is Client)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      return false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return name == other.name &amp;&amp; postalCode == other.postalCode</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // toString</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun toString() = &quot;client(name=$name, postalCode=$postalCode)&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  // hashCode</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun hashCode(): Int = name.hashCode() * 31 + postalCode</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="432-데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성"></a>4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성<a class="hash-link" href="#432-데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">data class Client(val name: String, val postalCode: Int)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>자바에서 요구하는 모든 메서드를 포함합니다.<ul><li>인스턴스 간 비교를 위한 equals</li><li>Hashmap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode</li><li>클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toString</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-클래스와-불면성-copy-메서드"></a>데이터 클래스와 불면성: copy() 메서드<a class="hash-link" href="#데이터-클래스와-불면성-copy-메서드" title="Direct link to heading">#</a></h4><ul><li>데이터 클래스의 프로퍼티가 꼭 val일 필요는 없으나, 데이터 클래스의 모든 프로퍼티를 읽기 전용으로 만들어서 데이터 클래스를 불변 클래스로 만드는 것이 권장됩니다.</li><li>이 대표적인 예시로 <code>copy</code>메서드이며 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val lee = Client(&quot;lee&quot;, 4122)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(lee.copy(postalCode = 4000))</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="433-클래스-위임-by-키워드-사용"></a>4.3.3 클래스 위임: by 키워드 사용<a class="hash-link" href="#433-클래스-위임-by-키워드-사용" title="Direct link to heading">#</a></h3><ul><li>대규모 객체지향 시스템을 설계할 때 시스템을 취약하게 하는 문제는 보통 <strong>구현 상속(implementation inheritance)</strong> 에 의해 발생합니다.</li><li>하위 클래스가 상위 클래스의 메서드 중 일부를 오버라이드하면 하위 클래스는 상위 클래스의 세부 구현 사항에 의존합니다.</li><li>코틀린은 위의 문제를 해결하기 위해 기본적으로 클래스를 <code>final</code>로 취급합니다.<ul><li>상속을 염두에 두고 open 변경자로 열어둔 클래스만 확장할 수 있습니다.</li></ul></li><li>상속을 허용하지 않는 클래스에 새로운 동작을 추가할 때가 있으며 이때 <code>데코레이터(Decorator)</code> 패턴을 사용합니다.<ul><li>상속을 허용하지 않는 클래스 대신 사용할 수 있는 새로운 클래스를 만들되 기존 클래스와 같은 인터페이스를 데코레이터가 제공하게 만들고, 기존 클래스를 데코레이터 내부에 필드로 유지합니다.</li><li><strong>새로 정의해야 하는 기능은 데코레이터의 메서드에 새로 정의하고 기존 기능이 그대로 필요한 부분은 데코레이터의 메서드가 기존 클래스의 메서드에게 요청을 전달</strong>합니다.</li></ul></li><li>by 키워드를 통해 인터페이스에 대한 구현을 다른 객체에 위임중을 명시할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class DelegatingCollection&lt;T&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} : Collection&lt;T&gt; by innerList()</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>불필요한 메서드 정의를 위처럼 없앨 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class CountingSet&lt;T&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">} : MutableCollection&lt;T&gt; by innerSet {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var objectAdded = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun add(element: T): Boolean {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    objectsAdded++</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return innerSet.add(element)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun addAll(c: Collection&lt;T&gt;): Boolean {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    objectsAdded += c.size</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return innerSet.addAll(c)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>이 경우는 구현 방식에 대한 의존관계가 생기지 않는 장점이 있습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="44-object-클래스-클래스-선언과-인스턴스-생성"></a>4.4 object 클래스: 클래스 선언과 인스턴스 생성<a class="hash-link" href="#44-object-클래스-클래스-선언과-인스턴스-생성" title="Direct link to heading">#</a></h2><ul><li>object 키워드를 사용하는 여러 상황을 살펴봐야합니다.<ul><li>객체 선언(object declaration)</li><li>동반 객체(companion object)</li><li>객체 식은 자바의 무명 내부 클래스(anonymous inner class) 대신 사용합니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="441-객체-선언-싱글턴을-쉽게-만들기"></a>4.4.1 객체 선언: 싱글턴을 쉽게 만들기<a class="hash-link" href="#441-객체-선언-싱글턴을-쉽게-만들기" title="Direct link to heading">#</a></h3><ul><li>객체지향 시스템을 설계하다 보면 인스턴스가 하나만 필요한 클래스가 유용한 경우가 많습니다.</li><li>코틀린은 <code>객체 선언</code> 기능을 통해 싱글턴을 언어에서 기본 지원합니다.<ul><li>객체 선언은 클래스 선언과 그 클래스에 속한 단일 인스턴스의 선언을 합친 선언입니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 객체 선언을 사용해 Comparator 구현</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">object CaseInsensitiveFileComparator : Comparator&lt;File&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  override fun compare(file1: File, file2: File): Int {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return file1.path.compareTo(file2.path, ignoreCase = true)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>싱글턴 패턴과 마찬가지 이유로 대규모 소프트웨어 시스템에서는 객체 선언이 항상 적합하지는 않습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">data class Person(val name: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  object NameComparator : Comparator&lt;Person&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    override fun compare(p1: Person, p2: Person): Int = p1.name.compareTo(p2.name)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="442-동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소"></a>4.4.2 동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소<a class="hash-link" href="#442-동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소" title="Direct link to heading">#</a></h3><ul><li>코틀린 클래스 안에는 정적인 멤버가 없으며 자바의 static 키워드를 지원하지 않스빈다. 대신 패키지 수준의 최상위 함수와 객체 선언을 활용합니다.</li><li>최상위 함수는 private 클래스에 접근할 수 없스빈다.</li><li>내부 정보에 접근이 필요한 경우 중첩된 객체 선언의 멤버 함수로 정의해야 합니다.<ul><li>대표적인 예시로 팩토리 메서드를 예시로 들 수 있습니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 부 생성자를 팩토리 메서드로 대신하기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class User private constructor(val nickname: String) {  // 주 생성자를 비공개로 만듦</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  companion object {  // 동반 객체 선언</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fun newSubscribingUser(email: String) = User(email.substringBefore(&#x27;@&#x27;))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fun newFacebookUser(accountId: Int) = User(getFacebookName(accountId))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><strong>팩토리 메서드</strong>는 목적에 따라 이름을 정할 수 있으며, 선언된 클래스의 하위 클래스 객체도 반환이 가능합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="443-동반-객체를-일반-객체처럼-사용"></a>4.4.3 동반 객체를 일반 객체처럼 사용<a class="hash-link" href="#443-동반-객체를-일반-객체처럼-사용" title="Direct link to heading">#</a></h3><ul><li>동반 객체는 클래스 안에 정의된 일반 객체입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val name: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  companion object Loader { // 동반 객체에 이름을 붙입니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fun fromJson(jsonText: String): Person = ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>동반 객체도 인터페이스를 구현할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">interface JSONFactory&lt;T&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  fun fromJSON(jsonText: String): T</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val name: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  companion object : JSONFactory&lt;Person&gt; { // 동반 객체가 인터페이스를 구현합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    override fun fromJson(jsonText: String): Person = ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>클래스에 동반 객체가 있으면 그 객체 안에 함수를 정의함으로써 클래스에 대해 호출할 수 있는 확장 함수를 만들 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 비지니스 모듈</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class Person(val firstName: String, val lastName: String) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  companion object {}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 클라이언트/서버 통신 모듈</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun Person.Companion.fromJSON(json: String): Person { // 확장함수 선언</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="444-객체-식-무명-내부-클래스를-다른-방식으로-작성"></a>4.4.4 객체 식: 무명 내부 클래스를 다른 방식으로 작성<a class="hash-link" href="#444-객체-식-무명-내부-클래스를-다른-방식으로-작성" title="Direct link to heading">#</a></h3><ul><li>무명 객체(anonymous object)를 정의할 때 object 키워드를 사용합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 무명 객체로 이벤트 리스너 구현</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">window.addMouseListener(  // MouseAdapter를 확장하는 무명 객체를 선언합니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  object : MouseAdapter() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // MouseAdapter의 메서드 오버라이드</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    override fun mouseClicked(e: MouseEvent) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    override fun mouseEntered(e: MouseEvent) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><blockquote><p>객체 선언과 달리 무명 객체는 싱클턴이 아니며, 객체 식이 쓰일 때마다 새로운 인스턴스가 생성됩니다.</p></blockquote><ul><li>무명 객체 식 안에서 변수의 값을 변경할 수도 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun countClicks(window: Window) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  var clickCount = 0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  window.addMouseListener(object: MouseAdapter() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    override fun mouseClicked(e: MouseEvent) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      clickCount++</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><blockquote><p>객체 식은 무명 객체 안에서 여러 메서드를 오버라이드해야하는 경우에 유용합니다.</p></blockquote><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="45-요약"></a>4.5 요약<a class="hash-link" href="#45-요약" title="Direct link to heading">#</a></h2><ul><li>코틀린의 인터페이스는 디폴트 구현을 포함할 수 있고 프로퍼티도 포함할 수 있습니다.</li><li>모든 코틀린 선언은 기본적으로 final이며 public입니다.</li><li>선언이 final이 되지 않게 만들려면 앞에 open을 붙여야합니다.</li><li>internal 선언은 같은 모듈안에서만 볼 수 있습니다.</li><li>중첩 클래스는 기본적으로 내부 클래스가 압니다. 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키려면 inner 키워드를 중첩 클래스 선언 앞에 붙여서 내부 클래스로 만들어야합니다.</li><li>sealed 클래스를 사용하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩 클래스로 정의해야합니다.</li><li>초기화 클록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있습니다.</li><li>field 식별자를 통해 프로퍼티 접근자(게터/세터) 안에서 프로퍼티의 데이터를 저장하는 데 쓰이는 뒷받침하는 필드를 참조할 수 있습니다.</li><li>데이터 클래스를 사용하면 컴파일러가 equals, hashCode, toString, copy 등의 메서드를 자동으로 생성해줍니다.</li><li>클래스 위임을 사용하면 위임 패턴을 구현할 때 필요한 수많은 성가신 준비 코드를 줄일 수 있습니다.</li><li>객체 선언을 사용하면 코틀린답게 싱글턴 클래스를 정의할 수 있습니다.</li><li>동반 객체는 자바의 정적 메서드와 필드 정의를 대신합니다.</li><li>동반 객체도 인터페이스를 구현할 수 있습니다.</li><li>코틀린의 객체 식은 자바의 무명 내부 클래스를 대신합니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/kotlin/kotlin-in-action/ch4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-12-10T07:39:50.000Z" class="lastUpdatedDate_1WI_">12/10/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 3. 함수 정의와 호출</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch5"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">5. 람다로 프로그래밍 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#41-클래스-계층-정의" class="table-of-contents__link">4.1 클래스 계층 정의</a><ul><li><a href="#411-코틀린-인터페이스" class="table-of-contents__link">4.1.1 코틀린 인터페이스</a></li><li><a href="#412-open-final-abstract-변경자-기본적으로-final" class="table-of-contents__link">4.1.2 open, final, abstract 변경자: 기본적으로 final</a></li><li><a href="#413-가시성-변경자-기본적으로-공개" class="table-of-contents__link">4.1.3 가시성 변경자: 기본적으로 공개</a></li><li><a href="#414-내부-클래스와-중첩된-클래스-기본적으로-중첩-클래스" class="table-of-contents__link">4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스</a></li><li><a href="#415-봉인된-클래스-클래스-계층-정의-시-계층-확장-제한" class="table-of-contents__link">4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한</a></li></ul></li><li><a href="#42-뻔하지-않은-생성자와-프로퍼티를-갖는-클래스-선언" class="table-of-contents__link">4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언</a><ul><li><a href="#421-클래스-초기화-주-생성자와-초기화-블록" class="table-of-contents__link">4.2.1 클래스 초기화: 주 생성자와 초기화 블록</a></li><li><a href="#422-뷰-생성자-상위-클래스를-다른-방식으로-초기화" class="table-of-contents__link">4.2.2 뷰 생성자: 상위 클래스를 다른 방식으로 초기화</a></li><li><a href="#423-인터페이스에-선언된-프로퍼티-구현" class="table-of-contents__link">4.2.3 인터페이스에 선언된 프로퍼티 구현</a></li><li><a href="#424-게터와-세터에서-뒷받침하는-필드에-접근" class="table-of-contents__link">4.2.4 게터와 세터에서 뒷받침하는 필드에 접근</a></li><li><a href="#425-접근자의-가시성-변경" class="table-of-contents__link">4.2.5 접근자의 가시성 변경</a></li></ul></li><li><a href="#43-컴파일러가-생성한-메서드-데이터-클래스와-클래스-위임" class="table-of-contents__link">4.3 컴파일러가 생성한 메서드: 데이터 클래스와 클래스 위임</a><ul><li><a href="#431-모든-클래스가-정의해야-하는-메서드" class="table-of-contents__link">4.3.1 모든 클래스가 정의해야 하는 메서드</a></li><li><a href="#432-데이터-클래스-모든-클래스가-정의해야-하는-메서드-자동-생성" class="table-of-contents__link">4.3.2 데이터 클래스: 모든 클래스가 정의해야 하는 메서드 자동 생성</a></li><li><a href="#433-클래스-위임-by-키워드-사용" class="table-of-contents__link">4.3.3 클래스 위임: by 키워드 사용</a></li></ul></li><li><a href="#44-object-클래스-클래스-선언과-인스턴스-생성" class="table-of-contents__link">4.4 object 클래스: 클래스 선언과 인스턴스 생성</a><ul><li><a href="#441-객체-선언-싱글턴을-쉽게-만들기" class="table-of-contents__link">4.4.1 객체 선언: 싱글턴을 쉽게 만들기</a></li><li><a href="#442-동반-객체-팩토리-메서드와-정적-멤버가-들어갈-장소" class="table-of-contents__link">4.4.2 동반 객체: 팩토리 메서드와 정적 멤버가 들어갈 장소</a></li><li><a href="#443-동반-객체를-일반-객체처럼-사용" class="table-of-contents__link">4.4.3 동반 객체를 일반 객체처럼 사용</a></li><li><a href="#444-객체-식-무명-내부-클래스를-다른-방식으로-작성" class="table-of-contents__link">4.4.4 객체 식: 무명 내부 클래스를 다른 방식으로 작성</a></li></ul></li><li><a href="#45-요약" class="table-of-contents__link">4.5 요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.aa396546.js"></script>
<script src="/til/assets/js/main.b2125fab.js"></script>
</body>
</html>