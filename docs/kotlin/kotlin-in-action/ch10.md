---
sidebar_position: 10
---

# 10. 애노테이션과 리플렉션

- **애노테이션(annotation)** 과 **리플렉션(reflection)** 을 사용하면 제약을 벗어나서 미리 알지 못하는 임의 클래스를 다룰 수 있습니다.

## 10.1 애노테이션 선언과 적용

- 자바 프레임워크도 애노테션을 많이 사용하면, 코틀린 애노테이션도 개념은 마찬가지입니다.
- 메타데이터를 선언에 추가하면 애노테이션을 처리하는 도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해줍니다.

### 10.1.1 애노테이션 적용

- 코틀린은 자바와 같은 방법으로 애노테이션을 사용할 수 있습니다.

```kt
import org.junit.*

class MyTest {
    @Test fun testTrue() { Assert.assertTrue(true) }
}
```

- 애노테이션의 인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스, 그리고 지금까지 말한 요소들로 이뤄진 배열이 들어갈 수 있습니다.
- 애노테이션 인자를 지정하는 문법은 자바와 약간 다릅니다.
  - 클래스를 이노테이션 인자로 지정할 때는 `@MyAnnotation(MyClass::class)`처럼 `::class`를 클래스 이름 뒤에 넣어야 합니다.
  - 다른 애노테이션을 인자로 지정할 때는 인자로 들어가는 애노테이션의 이름 앞에 `@`를 넣지 않아야합니다.
  - 배열을 인자로 지정하려면 `@RequestMapping(path = arrayOf("/foo", "/bar"))` 처럼 `arrayOf` 함수를 사용합니다. `@JavaAnnotationWithArrayValue("abc", "foo", "bar")` 처럼 `arrayOf` 함수를 쓰지 않아도 됩니다.
- 애노테이션 인자를 컴파일 시점에 알 수 있어야 하므로, 임의의 프로퍼티를 인자로 지정할 수는 없습니다.

### 10.1.2 애노테이션 대상

- 애노테이션을 붙일 때 이런 요소 중 어떤 요소에 애노테이션을 붙일지 표시할 필요가 있습니다. 
- **사용 지점 대상(use-site target)** 선언으로 애노테이션을 붙일 요소를 정할 수 있습니다. 

```kt
@get:Rule
// @get : 사용 지점 대상
// Rule : 애노테이션 이름
```

- 사용 지점 대상을 지정할 때 지원하는 대상 목록은 다음과 같습니다.

|이름|설명|
|---|------------------|
|`property`|프로퍼티 전체|
|`field`|프로퍼티에 의해 생성되는 필드|
|`get`|프로퍼티 게터|
|`set`|프로퍼티 세터|
|`receiver`|확장 함수나 프로퍼티의 수신 객체 파라미터|
|`param`|생성자 파라미터|
|`setparam`|세터 파라미터|
|`delegate`|위임 프로퍼티의 위임 인스턴스를 담아둔 필드|
|`file`|파일 안에 선언된 최상위 함수와 프로퍼티를 담아둔 클래스|

### 10.1.3 애노테이션을 활용한 JSON 직렬화 제어

### 10.1.4 애노테이션 선언

### 10.1.5 매타애노테이션: 애노테이션을 처리하는 방법 제어

### 10.1.6 애노테이션 파라미터로 클래스 사용

### 10.1.7 애노테이션 파라미터로 제네릭 클래스 받기

<br/>

## 10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰

### 10.2.1 코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty

### 10.2.2 리플렉션을 사용한 객체 직렬화 구현

### 10.2.3 애노테이션을 활용한 직렬화 제어

### 10.2.4 JSON 파싱과 객체 역직렬화

### 10.2.5 최종 역직렬화 단계: callBy(), 리플렉션을 사용해 객체 만들기

<br/>

## 10.3 요약
