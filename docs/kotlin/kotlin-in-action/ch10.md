---
sidebar_position: 10
---

# 10. 애노테이션과 리플렉션

- **애노테이션(annotation)** 과 **리플렉션(reflection)** 을 사용하면 제약을 벗어나서 미리 알지 못하는 임의 클래스를 다룰 수 있습니다.

## 10.1 애노테이션 선언과 적용

- 자바 프레임워크도 애노테션을 많이 사용하면, 코틀린 애노테이션도 개념은 마찬가지입니다.
- 메타데이터를 선언에 추가하면 애노테이션을 처리하는 도구가 컴파일 시점이나 실행 시점에 적절한 처리를 해줍니다.

### 10.1.1 애노테이션 적용

- 코틀린은 자바와 같은 방법으로 애노테이션을 사용할 수 있습니다.

```kt
import org.junit.*

class MyTest {
    @Test fun testTrue() { Assert.assertTrue(true) }
}
```

- 애노테이션의 인자로는 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션 클래스, 그리고 지금까지 말한 요소들로 이뤄진 배열이 들어갈 수 있습니다.
- 애노테이션 인자를 지정하는 문법은 자바와 약간 다릅니다.
  - 클래스를 이노테이션 인자로 지정할 때는 `@MyAnnotation(MyClass::class)`처럼 `::class`를 클래스 이름 뒤에 넣어야 합니다.

### 10.1.2 애노테이션 대상

### 10.1.3 애노테이션을 활용한 JSON 직렬화 제어

### 10.1.4 애노테이션 선언

### 10.1.5 매타애노테이션: 애노테이션을 처리하는 방법 제어

### 10.1.6 애노테이션 파라미터로 클래스 사용

### 10.1.7 애노테이션 파라미터로 제네릭 클래스 받기

<br/>

## 10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰

### 10.2.1 코틀린 리플렉션 API: KClass, KCallable, KFunction, KProperty

### 10.2.2 리플렉션을 사용한 객체 직렬화 구현

### 10.2.3 애노테이션을 활용한 직렬화 제어

### 10.2.4 JSON 파싱과 객체 역직렬화

### 10.2.5 최종 역직렬화 단계: callBy(), 리플렉션을 사용해 객체 만들기

<br/>

## 10.3 요약
