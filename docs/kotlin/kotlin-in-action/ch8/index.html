<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">8. 고차 함수: 파라미터와  반환 값으로 람다 사용 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch8"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="8. 고차 함수: 파라미터와  반환 값으로 람다 사용 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="- 람다를 인자로 받거나 반환하는 함수인 고차원 함수(high order function)에 대해 이야기합니다."><meta data-react-helmet="true" property="og:description" content="- 람다를 인자로 받거나 반환하는 함수인 고차원 함수(high order function)에 대해 이야기합니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch8"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch8" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/kotlin/kotlin-in-action/ch8" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.5f84a277.js" as="script">
<link rel="preload" href="/til/assets/js/main.d38bca81.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</h1></header><div class="markdown"><ul><li>람다를 인자로 받거나 반환하는 함수인 고차원 함수(high order function)에 대해 이야기합니다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="81-고차-함수-정의"></a>8.1 고차 함수 정의<a class="hash-link" href="#81-고차-함수-정의" title="Direct link to heading">#</a></h2><ul><li>고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="811-함수-타입"></a>8.1.1 함수 타입<a class="hash-link" href="#811-함수-타입" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val sum = { x: Int, y: Int -&gt; x + y }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val action = { println(42) }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린 문법은 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">(Int, String) -&gt; Unit</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// (Int, String) : 파라미터 타입</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Unit : 반환 타입</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>다음과 같이 사용할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">var canReturnNull: (Int, Int) -&gt; Int? = { x, y -&gt; null }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">var funOrNull: ((Int, Int) -&gt; Int)? = null</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>파라미터 이름은 타입 검사 시 무시됩니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="812-인자로-받은-함수-호출"></a>8.1.2 인자로 받은 함수 호출<a class="hash-link" href="#812-인자로-받은-함수-호출" title="Direct link to heading">#</a></h3><ul><li>filter의 선언은 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun String.filter(predicate: (Char) -&gt; Boolean): String</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// String.filter    : 수신 객체 타입</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// predicate        : 파라미터 타입</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// (Char) -&gt; Boolean: 파라미터 함수 타입</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// (Char)           : 파라미터로 받는 함수의 파라미터 타입</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// Boolean          : 파라미터로 받는 함수의 반환 타입</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>filter를 구현하면 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun String.filter(predicate: (Char) -&gt; Boolean): String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val sb = StringBuilder()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for(index in 0 until length) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val element = get(index)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (predicate(element)) sb.append(element)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return sb.toString()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(&quot;ab1c&quot;.filter { it in &#x27;a&#x27;...&#x27;z&#x27; })  // abc</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="813-자바에서-코틀린-함수-타입-사용"></a>8.1.3 자바에서 코틀린 함수 타입 사용<a class="hash-link" href="#813-자바에서-코틀린-함수-타입-사용" title="Direct link to heading">#</a></h3><ul><li>컴파일된 코드안에서 함수 타입은 일반 인터페이스로 바뀝니다.</li><li>함수 타입을 사용하는 코틀린 함수를 자바에서도 쉽게 호출할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun processTheAnswer(f: (Int) -&gt; Int) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(f(42))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">processTheAnswer(number -&gt; number + 1)  // 43</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>자바에서 코틀린 표준 라이브러리가 제공하는 람다를 인자로 받는 확장 함수를 쉽게 호출할 수는 있으나 코드가 깔끔하지는 않습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><div tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">strings.add(&quot;42&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">CollectionsKt.forEach(strings. s -&gt; {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    System.out.println(s);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return Unit.INSTANCES;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="814-디폴트-값을-지정한-함수-타입-파라미터나-널이-될-수-있는-함수-타입-파라미터"></a>8.1.4 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터<a class="hash-link" href="#814-디폴트-값을-지정한-함수-타입-파라미터나-널이-될-수-있는-함수-타입-파라미터" title="Direct link to heading">#</a></h3><ul><li>호출마다 람다를 넘기게 되면, 함수 호출을 오히려 불편하게 되는 경우가 있으나, 이 때는 파라미터에 대한 디폴트 값을 지정하면 이런 문제를 해결할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun &lt;T&gt; Collection&lt;T&gt;.joinToString (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    separator: String = &quot;, &quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    prefix: String = &quot;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    postfix: String = &quot;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    transform: (T) -&gt; String = { it.toString() }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">): String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val result = StringBuilder(prefix)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for((index, element) in this.withIndex()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(index &gt; 0) result.append(separator)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        result.append(transform(element))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    result.append(postfix)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return result.toString()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val letters = listOf(&quot;Alpha&quot;, &quot;Beta&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(letters.joinToString()) // Alpha, Beta</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(letters.joinToString { it.toLowerCase() })  // alpha, beta</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(letters.joinToString(separator = &quot;!&quot;, postfix = &quot;! &quot;, ... transform = {it.toUpperCase() } ))    // ALPHA!, BETA!</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>안전 호출을 활용하면 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun &lt;T&gt; Collection&lt;T&gt;.joinToString (</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    separator: String = &quot;, &quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    prefix: String = &quot;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    postfix: String = &quot;&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    transform: ((T) -&gt; String)? = null</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">): String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val result = StringBuilder(prefix)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    for((index, element) in this.withIndex()) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(index &gt; 0) result.append(separator)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val str = transform?.invoke(element) ?: element.toString()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        result.append(str)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    result.append(postfix)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return result.toString()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="815-함수를-함수에서-반환"></a>8.1.5 함수를 함수에서 반환<a class="hash-link" href="#815-함수를-함수에서-반환" title="Direct link to heading">#</a></h3><ul><li>함수가 함수를 반환할 필요가 있는 경우보다는 함수가 함수를 인자로 받아야 할 필요가 있는 경우가 더 많습니다. 그렇지만 함수가 함수를 반환하는 유용합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">data class Person(</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val firstName: String,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val lastName: String,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    val phoneNumber: String?</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">class ContactListFilters {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var prefix: String = &quot;&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    var onlyWithPhoneNumber: Boolean = false</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    fun getPredicate(): (Person) -&gt; Boolean {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        val startsWithPrefix = { p: Person -&gt; </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        } </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(!onlyWithPhoneNumber) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return startsWithPrefix</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return { startsWithPrefix(it) &amp;&amp; it.phoneNumber != null }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val contacts = listOf(Person(&quot;Dmitry&quot;, &quot;Jemerov&quot;, &quot;123-4567&quot;), Person(&quot;Svetlana&quot;, &quot;Isakova&quot;, null))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val contactListFilters = ContactListFilters()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">with (contactListFilters) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    prefix = &quot;Dm&quot;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    onlyWithPhoneNumber = true    </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(contacts.filter(... contactListFilters.getPredicate()))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">// [Person(firstName=Dmitry, lastName=Jemerov, phoneNumber=123-4567)]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>고차 함수는 코드 구조를 개선하고 중복을 없앨 때 쓸 수 있는 강력한 도구입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="816-람다를-활용한-중복-제거"></a>8.1.6 람다를 활용한 중복 제거<a class="hash-link" href="#816-람다를-활용한-중복-제거" title="Direct link to heading">#</a></h3><ul><li>함수 타입과 람다 식은 재활용하기 좋은 코드를 만들 때 쓸 수 있는 좋은 도구입니다.</li><li>람다는 복잡한 구조를 만들어야만 피할 수 있는 코드 중복도 람다를 활용하면 간결하고 쉽게 제거할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">val averageMobileDuration = log</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .filter { it.os in setOf(OS.IOS, OS.ANDROID) }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .map(SiteVisit::duration)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    .average()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(averageMobileDuration)  // 12.15</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun List&lt;SiteVisit&gt;.averageDurationFor(predicate: (SiteVisit) -&gt; Boolean) =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        filter(predicate).map(SiteVisit::duration).average()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(log.averageDurationFor { it.os in setOf(OS.ANDROID, OS.IOS) })  // 12.15</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(log.averageDurationFor { it.os == OS.IOS &amp;&amp; it.path == &quot;/signup&quot; }) // 8.0</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="82-인라인-함수-람다의-부가-비용-없애기"></a>8.2 인라인 함수: 람다의 부가 비용 없애기<a class="hash-link" href="#82-인라인-함수-람다의-부가-비용-없애기" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="821-인라이닝이-작동하는-방식"></a>8.2.1 인라이닝이 작동하는 방식<a class="hash-link" href="#821-인라이닝이-작동하는-방식" title="Direct link to heading">#</a></h3><ul><li>어떤 함수를 <code>inline</code>으로 선언하면 그 함수의 본문이 인라인이 됩니다.</li><li>즉, 함수를 호출하는 코드를 함수를 호출하는 바이트코드 대신에 함수 본문을 번역한 바이트 코드로 컴파일한다는 뜻입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">inline fun &lt;T&gt; synchronized(lock: Lock, action: () -&gt; T) : T {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    lock.lock()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try { return action() }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    finally { lock.unlock() }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val l = Lock()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">synchronzied(l) { ... }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>위 코드는 자바의 <code>synchronized</code> 와 동일합니다.</li><li>인라인 함수를 호출하는 코드 위치에서는 변수에 저장된 람다의 코드를 알 수 없습니다.</li><li>인라인 함수를 두 곳에서 각가 다른 람다를 사용해 호출한다면 두 호출은 각각 따로 인라이닝 됩니다.</li></ul><blockquote><p>인라인 함수란?</p><ul><li>성능 향상을 위한 것이며, 호출해서 실행이 아니라 코드 자체가 함수 내용이 된다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c++"><div tabindex="0" class="prism-code language-c++ codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">void PrintHello() { cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl; }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PrintHello();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  PrintHello();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>다음과 같이 바뀌게 됩니다.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c++"><div tabindex="0" class="prism-code language-c++ codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">int main() {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="822-인라인-함수의-한계"></a>8.2.2 인라인 함수의 한계<a class="hash-link" href="#822-인라인-함수의-한계" title="Direct link to heading">#</a></h3><ul><li>인라이닝을 하는 방식으로는 람다를 사용하는 모든 함수를 인라이닝할 수 없습니다.</li><li>함수 본문에서 파라미터로 받은 람다를 호출한다면 그 호출을 쉽게 람다 본문으로 바꿀 수 있습니다.</li><li>하지만 파라미터로 받은 람다를 다른 변수에 저장하고 나중에 그 변수를 사용한다면 람다를 표현하는 객체가 어딘가 존재해야 하기 때문에 람다를 인라이닝할 수 없습니다.</li><li>일반적으로 인라인 함수의 본문에서 람다 식을 바로 호출하거나 람다 식을 인자로 전달받아 바로 호출하는 경우에는 그 람다를 인라이닝할 수 있으나, 안되는 경우는 <code>Illegal usage of inline-parameter</code>라는 메시지와 함께 금지시킵니다.</li><li>인라인을 허용하고, 금지하는 경우는 다음과 같이 진행할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    // ...</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린에서는 어떤 모듈이나 서드파티 라이브러리 안에서 인라인 함수를 정의하고 그 모듈이나 라이브러리 밖에서 해당 인라인 함수를 사용할 수 있습니다.</li><li>자바에서도 코틀린에서 정의한 인라인 함수를 호출할 수 있으나, 일반 함수 호출로 컴파일합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="823-컬렉션-연산-인라이닝"></a>8.2.3 컬렉션 연산 인라이닝<a class="hash-link" href="#823-컬렉션-연산-인라이닝" title="Direct link to heading">#</a></h3><ul><li>코틀린 표준 라이브러리의 컬렉션 함수는 대부분 람다를 인자로 받습니다. 표준 라이브러리 함수가 아니라 직접 연산이 더 효율적으로 볼 수도 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 람다를 사용해 컬렉션 거르기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">data class Person(val name: String, val age: Int)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val people = listOf(Person(&quot;Alice&quot;, 29), Person(&quot;Bob&quot;, 31))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(people.filter{ it.age &lt; 30 })   // [Person(name=Alice, age=29)]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 컬렉션을 직접 거르기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">val result = mutableListOf&lt;Person&gt;()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">for(person in people) { </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if(person.age &lt; 30) result.add(person)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">println(result) // [Person(name=Alice, age=29)]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>시퀀스를 통해 성능을 향상시킬 수 있는 경우는 컬렉션 크기가 큰 경우뿐이며, 작은 경우는 컬렉션을 사용하는 것이 좋습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="824-함수를-인라인으로-선언해야-하는-경우"></a>8.2.4 함수를 인라인으로 선언해야 하는 경우<a class="hash-link" href="#824-함수를-인라인으로-선언해야-하는-경우" title="Direct link to heading">#</a></h3><ul><li><code>inline</code> 키워드를 사용해도 람다를 인자로 받는 함수만 성능이 좋아질 가능성이 높습니다.</li><li>일반 함수 호출의 경우 JVM은 이미 강력하게 인라이닝을 지원합니다. JVM은 코드 실행을 분석해서 가장 이익이 되는 방향으로 호출을 인라이닝합니다.</li><li>람다를 인자로 받는 함수를 인라이닝하면 이익이 많습니다.<ul><li>1) 인라이닝을 통해 없앨 수 있는 부가 비용이 상당합니다. </li><li>2) 현재의 JVM은 함수 호출과 람다를 인라이닝해 줄 정도로 똑똑하지 못합니다.</li><li>3) 인라이닝을 사용하면 일반 람다에서는 사용할 수 없는 몇 가지 기능을 사용할 수 있습니다.</li></ul></li><li><code>inline</code> 변경자를 함수에 붙일 때는 코드 크기에 주의를 기울여야 합니다.<ul><li>인라이닝하는 함수가 큰 경우 함수의 본문에 해당하는 바이트코드를 모든 호출 지점에 복사해 넣고 나면 바이트코드가 전체적으로 아주 커집니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="825-자원-관리를-위해-인라인된-람다-사용"></a>8.2.5 자원 관리를 위해 인라인된 람다 사용<a class="hash-link" href="#825-자원-관리를-위해-인라인된-람다-사용" title="Direct link to heading">#</a></h3><ul><li>람다로 중복을 없앨 수 있는 일반적인 패턴 중 한개는 작업을 하기 전에 자원을 획득하고 작업을 마친 후 자원을 해제하는 자원 관리입니다.<ul><li><strong>자원(resource)</strong> 는 파일, 락, 데이터베이스 트랜잭션 등 여러 다른 대상을 가리킬 수 있습니다.</li><li>일반적으로 사용하는 <code>try/finally</code> 문을 사용하여 <code>try</code> 블록을 시작하기 직전에 자원을 획득하고 <code>finally</code> 블록에서 자원을 해제하는 것입니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 코틀린 라이브러리에 있는 withLock 함수 정의</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun &lt;T&gt; Lock.withLock(action: () -&gt; T): T {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    lock()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    try {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return action()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    } finally {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        unlock()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>코틀린에서는 함수 타입의 값을 파라미터로 받는 함수를 통해 자원등을 매끄럽게 처리할 수 있으며, 이와 같은 기능을 언어 구성 요소로 제공하지 않습니다.</li><li>자바 <code>try-with-resource</code> 와 같은 기능을 제공하는 <code>use</code> 함수가 코틀린 표준 라이브러리 안에 들어있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun readFirstLineFromFile(path: String): String {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    BufferedReader(FileReader(path)).use {br -&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return br.readLine()</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li><code>use</code> 함수는 닫을 수 있는(closeable) 자원에 대한 확장 함수며, 람다를 인자로 받습니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="83-고차-함수-안에서-흐름-제어"></a>8.3 고차 함수 안에서 흐름 제어<a class="hash-link" href="#83-고차-함수-안에서-흐름-제어" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="831-람다-안의-return문-람다를-둘러싼-함수로부터-반환"></a>8.3.1 람다 안의 return문: 람다를 둘러싼 함수로부터 반환<a class="hash-link" href="#831-람다-안의-return문-람다를-둘러싼-함수로부터-반환" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun lookForAlice(people: List&lt;Person&gt;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    people.forEach {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (it.name == &quot;Alice&quot;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            println(&quot;Found!&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">            return</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(&quot;Alice is not found&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>자신을 둘러싸고 있는 블록보다 더 바깥에 있는 다른 블록을 반환하게 만드는 <code>return</code>문을 <strong>넌로컬(non-local)return</strong> 이라 부릅니다.</li><li><code>return</code>이 바깥쪽 함수를 반환시킬 수 있는 때는 람다를 인자로 받는 함수가 인라인 함수인 경우일 뿐입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="832-람다로부터-반환-레이블을-사용한-return"></a>8.3.2 람다로부터 반환: 레이블을 사용한 return<a class="hash-link" href="#832-람다로부터-반환-레이블을-사용한-return" title="Direct link to heading">#</a></h3><ul><li>람다식에서도 <strong>로컬(local) return</strong>을 사용할 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun lookForAlice(people: List&lt;Person&gt;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    people.forEach {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if(it.name == &quot;Alice&quot;) return@forEach   // return@forEach는 람다식으로부터 반환시킵니다.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    println(&quot;Alice might be somewhere&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>람다 식에는 레이블이 2개 이상 붙을 수 없습니다.</li><li>넌로컬 반환문은 장황하고, 람다 안의 여러 위치에 return 식이 들어가야하는 경우 사용하기 불편합니다. 이때는 무명 함수를 사용합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="833-무명-함수-기본적으로-로컬-return"></a>8.3.3 무명 함수: 기본적으로 로컬 return<a class="hash-link" href="#833-무명-함수-기본적으로-로컬-return" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 무명 함수 안에서 return 사용하기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">fun lookForAlice(people: List&lt;Perosn&gt;) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    people.forEach(fun (person) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (person.name == &quot;Alice&quot;) return</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        println(&quot;${person.name} is not Alice&quot;)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    })</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">lookForAlice (people)   // Bob is not Alice</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>무명 함수는 일반 함수와 비슷해 보이며, 차이는 함수 이름이나 파라미터 타입을 생략할 수 있다는 점입니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// filter에 무명 함수 넘기기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">people.filter(fun (person): Boolean {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    return person.age &lt; 30</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>무명 함수도 일반 함수와 같은 반환 타입 지정 규칙을 따릅니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly kt"><div tabindex="0" class="prism-code language-kt codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">// 식이 본문인 무명 함수 사용하기</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">people.filter(fun (person) = person.age &lt; 30)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>무명 함수 안에서 레이블이 붙지 않은 return 식은 무명 함수 자체를 반환시킬 뿐 무명 함수를 둘러싼 다른 함수를 반환시키지 않습니다.</li><li>무명 함수 본문의 return은 무명 함수를 반환시키고, 무명 함수 밖의 다른 함수를 반환시키지 못합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="84-요약"></a>8.4 요약<a class="hash-link" href="#84-요약" title="Direct link to heading">#</a></h2><ul><li>함수 타입을 사용해 함수에 대한 참조를 담는 변수나 파라미터나 반환 값을 만들 수 있습니다.</li><li>고차 함수는 다른 함수를 인자로 받거나 함수를 반환합니다. 함수의 파라미터 타입이나 반환 타입으로 함수 타입을 사용하면 고차 함수를 선언할 수 있습니다.</li><li>인라인 함수를 컴파일할 때 컴파일러는 그 함수의 본문과 그 함수에게 전달된 람다의 본문을 컴파일한 바이트코드를 모든 함수 호출 지점에 삽입해줍니다. 이렇게 만들어지는 바이트코드는 람다를 활용한 인라인 함수 코드를 풀어서 직접 쓴 경우와 비교할 때 아무 부가 비용이 들지 않습니다.</li><li>고차 함수를 사용하면 컴포넌트를 이루는 각 부분의 코드를 더 잘 재사용할 수 있습니다. 또 고차 함수를 활용해 강력한 제네릭 라이브러리를 만들 수 있습니다.</li><li>인라인 함수에서는 람다 안에 있는 <code>return</code>문이 바깥쪽 함수를 반환시키는 넌 로컬 <code>return</code> 을 사용할 수 있습니다.</li><li>무명 함수는 람다 식을 대신할 수 있으며 <code>return</code> 식을 처리하는 규칙이 일반 람다 식과는 다릅니다. 본문 여러 곳에서 <code>return</code>해야 하는 코드 블록을 만들어야한다면 람다 대신 무명 함수를 쓸 수 있습니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/kotlin/kotlin-in-action/ch8.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-07-31T22:52:04.000Z" class="lastUpdatedDate_1WI_">7/31/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch7"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 7. 연산자 오버로딩과 기타 관례</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/kotlin/kotlin-in-action/ch9"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">9. 제네릭스 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#81-고차-함수-정의" class="table-of-contents__link">8.1 고차 함수 정의</a><ul><li><a href="#811-함수-타입" class="table-of-contents__link">8.1.1 함수 타입</a></li><li><a href="#812-인자로-받은-함수-호출" class="table-of-contents__link">8.1.2 인자로 받은 함수 호출</a></li><li><a href="#813-자바에서-코틀린-함수-타입-사용" class="table-of-contents__link">8.1.3 자바에서 코틀린 함수 타입 사용</a></li><li><a href="#814-디폴트-값을-지정한-함수-타입-파라미터나-널이-될-수-있는-함수-타입-파라미터" class="table-of-contents__link">8.1.4 디폴트 값을 지정한 함수 타입 파라미터나 널이 될 수 있는 함수 타입 파라미터</a></li><li><a href="#815-함수를-함수에서-반환" class="table-of-contents__link">8.1.5 함수를 함수에서 반환</a></li><li><a href="#816-람다를-활용한-중복-제거" class="table-of-contents__link">8.1.6 람다를 활용한 중복 제거</a></li></ul></li><li><a href="#82-인라인-함수-람다의-부가-비용-없애기" class="table-of-contents__link">8.2 인라인 함수: 람다의 부가 비용 없애기</a><ul><li><a href="#821-인라이닝이-작동하는-방식" class="table-of-contents__link">8.2.1 인라이닝이 작동하는 방식</a></li><li><a href="#822-인라인-함수의-한계" class="table-of-contents__link">8.2.2 인라인 함수의 한계</a></li><li><a href="#823-컬렉션-연산-인라이닝" class="table-of-contents__link">8.2.3 컬렉션 연산 인라이닝</a></li><li><a href="#824-함수를-인라인으로-선언해야-하는-경우" class="table-of-contents__link">8.2.4 함수를 인라인으로 선언해야 하는 경우</a></li><li><a href="#825-자원-관리를-위해-인라인된-람다-사용" class="table-of-contents__link">8.2.5 자원 관리를 위해 인라인된 람다 사용</a></li></ul></li><li><a href="#83-고차-함수-안에서-흐름-제어" class="table-of-contents__link">8.3 고차 함수 안에서 흐름 제어</a><ul><li><a href="#831-람다-안의-return문-람다를-둘러싼-함수로부터-반환" class="table-of-contents__link">8.3.1 람다 안의 return문: 람다를 둘러싼 함수로부터 반환</a></li><li><a href="#832-람다로부터-반환-레이블을-사용한-return" class="table-of-contents__link">8.3.2 람다로부터 반환: 레이블을 사용한 return</a></li><li><a href="#833-무명-함수-기본적으로-로컬-return" class="table-of-contents__link">8.3.3 무명 함수: 기본적으로 로컬 return</a></li></ul></li><li><a href="#84-요약" class="table-of-contents__link">8.4 요약</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.5f84a277.js"></script>
<script src="/til/assets/js/main.d38bca81.js"></script>
</body>
</html>