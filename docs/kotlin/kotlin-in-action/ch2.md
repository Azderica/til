---
sidebar_position: 2
---

# 2. 코틀린 기초

## 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello. World!

```kotlin
fun main(args: Array<String>) {
  println("Hello, world!")
}
```

### 2.1.2 함수

- 함수의 선언은 `fun` 키워드로 시작합니다.
- `fun 함수이름(파라미터 변수이름: 변수타입): 반환타입 { 함수 본문 }`

> 코틀린에서 if는 식(expression)이며 문(statement)이 아닙니다.
>
> - 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있으나 문은 자신을 둘렀가ㅗ 있는 가장 안쪽 블록의 최상위 요소로 존재합니다.

### 2.1.3 변수

- 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름에 타입을 명시하거나 생략하도록 허락합니다.
- 변경 가능한 변수과 변경 불가능한 변수
  - `val` : 변경 불가능한 참조를 저장하는 변수(자바의 final)
  - `var` : 변경 가능한 참조
- 기본적으로 모든 변수를 val 키워드를 통해 불변 변수로 선언하고 필요시에만 var로 변경하는 것이 중요합니다.
- val 변수는 블록을 실행할 때 정확히 한 번 초기화돼야 합니다.

### 2.1.4 문자열 템플릿

```kotlin
fun main(args: Array<String>) {
  val name = if(args.size > 0) args[0] else "Kotlin"
  println("Hello, $name!")
}
```

- `$`을 추가해 효율적으로 표현이 가능합니다.
- 복잡한 식의 경우 괄호를 사요아홀 수 있습니다.
  - `println("Hello, ${args[0]}!")`

<br/>

## 2.2 클래스와 프로퍼티

### 2.2.1 프로퍼티

### 2.2.2 커스텀 접근자

### 2.2.3 코틀린 소스코드 구조: 디렉토리와 패키지

<br/>

## 2.3 선택 표현과 처리: enum과 when

### 2.3.1 enum 클래스 정의

### 2.3.2 when으로 enum 클래스 다루기

### 2.3.3 when과 임의의 객체를 함께 사용

### 2.3.4 인자 없는 when 사용

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합

### 2.3.6 리팩토링: if를 when으로 변경

### 2.3.7 if와 when의 분기에서 블록 사용

<br/>

## 2.4 대상을 이터레이션: while과 for 루프

### 2.4.1 while 루프

### 2.4.2 수에 대한 이터레이션: 범위와 수열

### 2.4.3 맵에 대한 이터레이션

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

<br/>

## 2.5 코틀린의 예외 처리

### 2.5.1 try, catch, finally

### 2.5.2 try를 식으로 사용

<br/>

## 2.6 요약
