<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">7. 트랜잭션 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch7"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="7. 트랜잭션 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다."><meta data-react-helmet="true" property="og:description" content="현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch7"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch7" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch7" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.f33c1eac.js" as="script">
<link rel="preload" href="/til/assets/js/main.f4846ab0.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">data</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">아파치 카프카 애플리케이션 프로그래밍 with 자바</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch1">1. 들어가며</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch2">2. 카프카 빠르게 시작해보기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/data/apache-kafka-with-java/ch3">3. 카프카 기본 개념 설명</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">도메인 주도 설계 첫걸음</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch1">비즈니스 도메인 분석하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch2">2. 도메인 지식 찾아내기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch3">3. 도메인 복잡성 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/domain-driven-design/ch4">4. 바운디드 컨텍스트 연동</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">오브젝트</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch1">1. 객체, 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch2">2. 객체지향 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch3">3. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch4">4. 설계 품질과 트레이드 오프</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch5">5. 책임 할당하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch6">6. 메시지와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch7">7. 객체 분해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch8">8. 의존성 관리하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch9">9. 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch10">10. 상속과 코드 재사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch11">11. 합성과 유연한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch12">12. 다형성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch13">13. 서브클래싱과 서브타이핑</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch14">14. 일관성 있는 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch15">15. 디자인 패턴과 프레임 워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch16">부록 A. 계약에 의한 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch17">부록 B. 타입 계층의 구현</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object/ch18">부록 C. 동적인 협력, 정적인 코드</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">가상 면접 사례로 배우는 대규모 시스템 설계 기초</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch1">1. 사용자 수에 따른 규모 확장성</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch2">2. 개략적인 규모 추정</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch3">3. 시스템 설계 면접 공략법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch4">4. 처리율 제한 장치의 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch5">5. 안정 해시 설계안</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch6">6. 키-값 저장소 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch7">7. 분산 시스템을 위한 유일 ID 생성기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch8">8. URL 단축기 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch9">9. 웹 크롤러 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch10">10장. 알림 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch11">11장. 뉴스 피드 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch12">12장. 채팅 시스템 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch13">13장. 검색어 자동완성 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch14">14장. 유튜브 설계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/system-design-interview/ch15">15장. 구글 드라이브 설계</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch2">2. 코틀린 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch3">3. 함수 정의와 호출</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch4">4. 클래스, 객체, 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch5">5. 람다로 프로그래밍</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch6">6. 코틀린 타입 시스템</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch7">7. 연산자 오버로딩과 기타 관례</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch8">8. 고차 함수: 파라미터와  반환 값으로 람다 사용</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch9">9. 제네릭스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch10">10. 애노테이션과 리플렉션</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">react</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">따라하며 배우는 리액트 A-Z</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch1">따라하는 리액트, 리액트란?</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch2">간단한 To-Do 앱 만들며 리액트 익히기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch3">To-Do 앱 최적화하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch4">4. Netflix 앱 만들기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch5">5. 넷플릭스 앱 모달 및 이미지 불러오기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch6">6. React TDD 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch8">8. Nextjs and Typescript</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch9">9. React Version</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch10">10. Redux</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/react/react-a-to-z/ch11">도커로 리액트 실행하기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Spring Cloud로 개발하는 마이크로서비스 애플리케이션(MSA)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-cloud-msa/ch0">0. Microservice와 Spring Cloud 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-cloud-msa/ch6">6. User Microservice</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">스프링 시큐리티(강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-security/ch1">1부 스프링 시큐리티: 폼 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-security/ch2">2부 스프링 시큐리티: 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-security/ch3">3부 웹 애플리케이션 시큐리티</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/spring-security/ch4">4부. 스프링 시큐리티 그 밖에</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">think</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">커리어 스킬</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch4">개발자로 일하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/career-skill/ch5">경력 발전시키기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">개발자의 글쓰기</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch0">프롤로그. 개발자의 글쓰기는 달라야 한다.</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch1">1장. 개발자가 알아야 할 글쓰기 기본</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch2">2장. 개발 시간을 줄여주는 이름 짓기와 주석 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch3">3장. 사용자와 소통하는 에러 메시지 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch4">4장. 독자 관점에서 릴리스 문서와 장애 보고서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch5">5장. 설명, 묘사, 논증, 서사로 개발 가이드 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch6">6장. 수주를 돕는 SI 제안서 쓰기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/developers-writing/ch7">7장. 기술 블로그 쉽게 쓰고 운영하기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">프로그래머의 뇌</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch1">1. 코딩 중 겪는 혼란에 대한 이해</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch2">2. 신속한 코드 분석</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch3">3. 프로그래밍 문법 빠르게 배우기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch4">4. 복잡한 코드 읽는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch5">5. 코드를 더 깊이 있게 이해하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch6">6. 코딩 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch7">7. 생각의 버그</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch8">8. 명명을 잘하는 방법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch9">9. 나쁜 코드와 인지 부하를 방지하는 두 가지 프레임워크</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch10">10. 복잡한 문제 해결을 더 잘하려면</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch11">11. 코드를 작성하는 행위</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch12">12. 대규모 시스템의 설계와 개선</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/think/the-programmers-brain/ch13">13. 새로운 개발자 팀원의 적응 지원</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">vue</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Vuejs 시작하기 (인프런 강의)</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch1">Vue.js 시작하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch2">Vue.js 컴포넌트 통신</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch3">Vue.js 라우터, HTTP 통신, 뷰 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch4">Vue.js 템플릿 문법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/vue/vuejs-starter/ch5">Vue CLI &amp; 간단한 Form 만들기</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">7. 트랜잭션</h1></header><div class="markdown"><p>현실에서 데이터 시스템은 여러 가지 문제가 생길 수 있습니다.</p><ul><li>데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있습니다.</li><li>애플리케이션은 언제라도 죽을 수 있습니다.</li><li>네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있습니다.</li><li>여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있습니다.</li><li>클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있습니다.</li><li>클라이언트 사이의 경쟁 조건을 예측하지 못한 버그를 유발할 수 있습니다.</li></ul><p>시스템이 <strong>신뢰성</strong>을 지니려면 이러한 결함을 처리해서 전체 시스템의 치명적인 장애로 이어지는 것을 막아야 합니다.</p><ul><li>트랜잭션은 이런 문제를 <strong>단순화</strong>하는 메커니즘으로 채택되었습니다.</li><li>트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법입니다.<ul><li>개념적으로 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행됩니다.</li><li>트랜잭션은 전체가 <strong>성공(커밋)</strong> 하거나 <strong>실패(abort, 롤백)</strong> 합니다</li><li>트랜잭션을 사용하면 안전하게 재시도할 수 있기 때문에 오류 처리를 하기 훨씬 단순해집니다.</li></ul></li><li>트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만들어졌습니다.<ul><li>트랜잭션을 통해 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있습니다. <strong>(안전성 보장, safety guarantee)</strong></li></ul></li><li>모든 애플리케이션에서 트랜잭션이 필요하지 않으며 때로는 트랜잭션적인 보장을 완화하건아 아예 쓰지않는 것이 이득입니다.</li></ul><p>데이터베이스에서 문제가 생길 수 있는 여러 예를 조사하고 이를 사용하는 알고리즘을 살펴봅니다. 동시성 제어 분야를 깊게 다루며 발생할 수 있는 다양한 종류의 경쟁조건과 데이터베이스에서 <strong>커밋 후 읽기(read committed), 스냅숏 격리(snapshot isolation), 직렬성(serializability)</strong> 같은 격리 수준을 어떻게 같은 격리 수준을 구현하는지에 대해 설명합니다.</p><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="애매모호한-트랜잭션의-개념"></a>애매모호한 트랜잭션의 개념<a class="hash-link" href="#애매모호한-트랜잭션의-개념" title="Direct link to heading">#</a></h2><p>현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원합니다.</p><ul><li>비관계형(NoSQL) 데이터베이스가 주류로 바뀌며 트랜잭션을 약한 보장을 의미하는 단어로 트랜잭션 의미가 재정의 되었습니다.</li><li>트랜잭션은 이점과 한계가 있습니다. 이에 따라 잘 조절해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="acid의-의미"></a>ACID의 의미<a class="hash-link" href="#acid의-의미" title="Direct link to heading">#</a></h3><p>트랜잭션이 제공하는 안전성 보장은 크게 아래로 나눠집니다.</p><ul><li>원자성(<strong>A</strong>tomicity)</li><li>일관성(<strong>C</strong>onsistency)</li><li>격리성(<strong>I</strong>solation)</li><li>지속성(<strong>D</strong>urability)</li></ul><p>그러나 현실에서는 데이터베이스마다 ACID 구현이 제각각이며 <strong>격리성</strong>은 의미 주변에 모호함이 많습니다. (ACID 표준을 따르지 않는 시스템은 때로 <strong>BASE</strong>라 불립니다. 가용성을 제공하고(Basically Available), 유연한 상태를 가지며(Soft state), 최종적 일관성(Eventual consistency) 의 의미를 가집니다.)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="원자성"></a>원자성<a class="hash-link" href="#원자성" title="Direct link to heading">#</a></h4><ul><li>일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 무엇을 가르킵니다.</li><li>ACID의 원자성은 클라이언트가 쓰기 작업을 몇 개 실행할 때, <strong>여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 완료(커밋)될 수 없으면 어보트되고 데이터베이스는 이 트랜잭션에서 지금까지 실횅한 쓰기를 무시하거나 취소</strong>해야합니다.</li><li>오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력은 ACID의 원자성의 결정적인 특징입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관성"></a>일관성<a class="hash-link" href="#일관성" title="Direct link to heading">#</a></h4><ul><li>일관성은 괴장히 여러 의미로 쓰입니다. (복제 일관성, 최종적 일관성, 일관성 해싱, CAP의 일관성 등등)</li><li>ACID의 일관성은 데이터 베이스가 <strong>좋은 상태(항상 진실이어야하는 데이터에 관한 어떤 선언, 불변식(invariant)가 있다는 것)</strong> 에 있어야 한다는 애플리케이션에 특화된 개념입니다.</li><li>일관성의 아이디어는 애플리케이션의 불변식 개념에 의존하고 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임입니다.</li><li>원자성, 격리성, 지속성은 데이터베이스의 속성인 반면 일관성은 애플리케이션의 속성입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="격리성"></a>격리성<a class="hash-link" href="#격리성" title="Direct link to heading">#</a></h4><ul><li>대부분 동시에 여러 클라이언트에서 데이터베이스에 접근하고, 클라이언트 들이 동일한 데이터베이스 레코드에 접근하면 동시성 문제에 맞닥뜨리게 됩니다.</li><li>ACID의 격리성은 동시에 실행되는 트랜잭션은 서로 격리되는 것을 의미합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="지속성"></a>지속성<a class="hash-link" href="#지속성" title="Direct link to heading">#</a></h4><ul><li>데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것입니다.</li><li>지속성(durability)는 트랜잭션이 <strong>성공적으로 커밋</strong>되었다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 <strong>트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장</strong>입니다.</li></ul><blockquote><p>복제와 지속성</p></blockquote><ul><li>고가ㅓ에는 지속성이 아카이브 테이프에 기록되는 것을 의미하였고, 그 이후는 디스크나 SSD에 기록하는 것, 현재는 복제를 의미합니다.</li><li>이중에서 왑녁한 것은 없으며, 여러 위험을 줄이는 기법일 뿐이며 같이 쓸 수 있으면 그렇게 해야합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단일-객체-연산과-다중-객체-연산"></a>단일 객체 연산과 다중 객체 연산<a class="hash-link" href="#단일-객체-연산과-다중-객체-연산" title="Direct link to heading">#</a></h3><p>요약하면 ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술합니다.</p><ul><li>원자성 : 데이터베이스는 전부 반영되거나 아무것도 반영되지 않음을 보장합니다.</li><li>격리성 : 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 합니다.</li></ul><p><strong>다중 객체 트랜잭션</strong>은 흔히 데이터의 여러 조각이 동기화된 상태로 유지되어야 할 때 필요합니다.</p><ul><li>다중 객체 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 합니다.</li><li>비관계형 데이터베이스는 이런식으로 연산을 묶는 경우가 없어서, 다중 객체 API가 있더라도 반드시 트랜잭션 시맨틱을 의미하지는 않습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="단일-객체-쓰기"></a>단일 객체 쓰기<a class="hash-link" href="#단일-객체-쓰기" title="Direct link to heading">#</a></h4><ul><li>원자성과 격리성은 단일 객체를 변경하는 경우에도 적용됩니다.</li><li>단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실(lost update)를 방지하므로 유용합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다중-객체-트랜잭션의-필요성"></a>다중 객체 트랜잭션의 필요성<a class="hash-link" href="#다중-객체-트랜잭션의-필요성" title="Direct link to heading">#</a></h4><ul><li>많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했습니다.<ul><li>다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기도 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오가 있습니다.</li></ul></li><li>단일 객체, 갱신, 삭제만으로도 충분한 사용 사례가 있습니다. (굳이 다중 객체 트랜잭션이 필요 없는 경우)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="오류와-어보트-처리"></a>오류와 어보트 처리<a class="hash-link" href="#오류와-어보트-처리" title="Direct link to heading">#</a></h4><ul><li>트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있습니다.</li><li>다만 모든 시스템이 이러한 철학을 따르지 않으며, 리더 없는 복제를 사용하는 데이터 스토어는 &quot;최선을 다하는(best effort)&quot; 원칙을 기반으로 더 많은 일을 합니다.<ul><li>이 경우, 오류 복구는 애플리케이션에게 책임이 있습니다.</li></ul></li><li>어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지않습니다.<ul><li>트랜잭션이 실제로 성공했으나 네트워크 이슈가 발생한 경우</li><li>오류가 과부하 때문에 발생한 경우</li><li>일시적인 오류만 재시도할 가치가 있으며 영구적인 오류는 재시도해도 소용이 없습니다.</li><li>트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 부수 효과가 실행될 수 있습니다.</li><li>클라이언트 프로세스가 재시도 중에 죽어버리면 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실이 됩니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="완화된-격리-수준"></a>완화된 격리 수준<a class="hash-link" href="#완화된-격리-수준" title="Direct link to heading">#</a></h2><ul><li>두 트랜잭션이 동일한 데이터에 접근하지 않으면 안전하게 병렬 실행할 수 있습니다.</li><li>동시성 버그는 타이밍에 운이 안좋을때만 발생하기 때문에 테스트로 발견하기 어렵습니다.</li><li>이러한 이유로 데이터베이스는 오랫동안 데이터 격리를 제공했습니다.<ul><li>다만 비용이 매우 큰 문제가 있습니다</li></ul></li><li>많은 데이터베이스는 완화된 트랜잭션 격리를 제공합니다.<ul><li>이는 미묘한 버그를 만드는 문제가 있습니다.</li></ul></li><li>일반적으로 도구를 의존하기 보다 동시성 문제를 잘 이해하고 방지하는 방법을 배울 필요가 있습니다.</li></ul><blockquote><p>Q. 우리 회사에서는 뭐쓰지</p></blockquote><blockquote><p>Q. 옛날에 관련해서 본 4단계 계층 구조가 있는데 확인해보기</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커밋-후-읽기"></a>커밋 후 읽기<a class="hash-link" href="#커밋-후-읽기" title="Direct link to heading">#</a></h3><p>가장 기본적인 수준의 트랜잭션은 <strong>커밋 후 읽기(read committed)</strong> 입니다. 이 수준에서는 두 개를 보장해줍니다.</p><ul><li>데이터베이스에서 읽을 때, 커밋된 데이터만 읽게 됩니다. (더티 읽기가 없음)</li><li>데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 됩니다. (더티 쓰기가 없음)</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="더티-읽기-방지"></a>더티 읽기 방지<a class="hash-link" href="#더티-읽기-방지" title="Direct link to heading">#</a></h4><ul><li><strong>더티 읽기(dirty read)</strong> : 트랜재션이 데이터베이스에 데이터를 썼지만 아직 커밋되지 않았거나 어보트 되지 않은 데이터</li><li>이를 막으면 다음의 장점을 가집니다<ul><li>부분적 갱신 데이터는 사용자에게 혼란스러움을 제공할 수 있습니다.</li><li>트랜잭션이 어보트시 롤백을 해야하는데 혼란을 줄 수 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="더티-쓰기-방지"></a>더티 쓰기 방지<a class="hash-link" href="#더티-쓰기-방지" title="Direct link to heading">#</a></h4><ul><li><strong>더티 쓰기(dirty write)</strong> : 먼저 쓴 내용이 아직 커밋에서 쓴 것이고, 나중에 실행된 쓰기 작업이 커밋되지않은 값을 덮어 쓴 경우</li><li>이를 막으면 다음의 장점을 가집니다<ul><li>트렌잭션이 여러 객체를 갱신하면 나쁜 결과를 유발하는 문제가 있습니다.</li><li>경쟁 조건을 막을 수 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="커밋-후-읽기-구현"></a>커밋 후 읽기 구현<a class="hash-link" href="#커밋-후-읽기-구현" title="Direct link to heading">#</a></h4><ul><li>현재 자주 쓰이는 격리 수준</li><li>오라클 11g, PostgreSQL, SQL Server 2012 등에서 기본 설정입니다</li><li>흔한 방법으로 데이터베이스는 로우에 대한 락을 가짐으로 더티 쓰기를 방지합니다.</li><li>읽기 쓰기 잠금은 현실에서 잘 동작하지 않습니다.<ul><li>따라서 과거와 새로운 값을 모두 기억하고 커밋 전까지는 다른 트랜잭션들이 과거의 값을 가집니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스냅숏-격리와-반복-읽기"></a>스냅숏 격리와 반복 읽기<a class="hash-link" href="#스냅숏-격리와-반복-읽기" title="Direct link to heading">#</a></h3><ul><li>커밋 후 읽기 격리를 피상적으로 보면 트랜잭션이 해야하는 모든 일을 해주는 것으로 생각하는 것도 무리가 아닙니다</li><li>위의 격리 수준을 사용해도 깨지는 경우가 존재합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/140755927-fb83ddc7-a6dd-4491-b050-5be8ea7626d5.png" alt="읽기 쓰큐, 깨진 데이터를 본 경우"></p><ul><li>위의 이상 현상을 <strong>비반복 읽기(nonrepeatedable read)</strong> 나 <strong>읽기 스큐(read skew)</strong> 라고 합니다.</li><li>이러한 일시적인 문제를 감내할 수 없는 경우가 있습니다.<ul><li>백업 : 데이터베이스 전체의 복사본을 만들어야하는 경우에 비 일관성이 발생하면 이를 영속적으로 저장하게 굅니다.</li><li>분석 질의와 무결성 확인 : 데이터베이스의 큰 부분을 질의하는 경우</li></ul></li><li><strong>스냅숏 격리</strong>는 이런 문제의 흔한 해결책입니다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽습니다.</li><li><strong>스냅숏 격리</strong>는 백업이나 분석처럼 실행하는게 오래 걸리며 읽기만 실행하는 질의에 요긴합니다.</li><li>스냅숏 격리는 PostgreSQL, InnoDB 저장소 엔진, 마이SQL, 오라클, SQL Server 등에서 지원됩니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스냅숏-격리-구현"></a>스냅숏 격리 구현<a class="hash-link" href="#스냅숏-격리-구현" title="Direct link to heading">#</a></h4><ul><li>스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용합니다.</li><li>성능 관점에서 스냅숏 격리의 핵심 원리는 <strong>읽는 쪽에서 쓰는 쪽을 절대 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것</strong>입니다.</li><li>진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야하기 때문에 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 합니다. 이 기법을 다중 버전 동시성 제어(multi-version concurrency control, MVCC)라고 합니다.</li><li>데이터베이스가 스냅숏 격리가 아니라 커밋 후 읽기 격리만 제공할 필요가 있다면 객체마다 버전 두개씩 쥬히면 충분합니다.</li></ul><p>[이미지]</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="일관된-스냅숏을-보는-가시성-규칙"></a>일관된 스냅숏을 보는 가시성 규칙<a class="hash-link" href="#일관된-스냅숏을-보는-가시성-규칙" title="Direct link to heading">#</a></h4><ul><li>트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정합니다.</li><li>두 조건이 참이면 객체를 볼 수 있습니다.<ul><li>읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다</li><li>읽기 대상 객체가 삭제된 것으로 표시되지 않았다 또는 삭제된 것으로 표시되었지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.</li></ul></li><li>데이터 베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅숏을 제공할 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="색인과-스냅숏-격리"></a>색인과 스냅숏 격리<a class="hash-link" href="#색인과-스냅숏-격리" title="Direct link to heading">#</a></h4><p>다중 버전 데이터베이스에서 색인은 아래처럼 동작합니다.</p><ul><li>간단한 방법으로 단순하게 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것</li><li>현실에서는 여러 구현 세부 사항에 따라 성능이 결정되므로 PostgreSQL은 동일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 합니다.</li><li>CouchDB, LMDB 에서는 B 트리 변종(<strong>쓸때 복사되는, append-only/copy-on-write</strong>)을 사용합니다.</li><li>추가 전용 B 트리도 컴팩션과 가비지 컬렉션을 실행하는 백그라운드 프로세스가 필요합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="반복-읽기와-혼란스러운-이름"></a>반복 읽기와 혼란스러운 이름<a class="hash-link" href="#반복-읽기와-혼란스러운-이름" title="Direct link to heading">#</a></h4><ul><li>스냅숏 격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에 유용합니다.<ul><li>오라클에서는 <strong>직렬성</strong>, PostgreSQL과 MySQL에서는 <strong>반복 읽기(repeatable read)</strong> 라고 합니다.</li><li>이름이 혼란스러운 이유는 SQL 표준에 스냅숏 격리 개념이 없어서 그렇습니다.</li></ul></li><li>SQL 표준의 격리 수준 정의에는 결함이 있습니다. 모호하고 부정확하며 표준이 그래야하는 것만큼 구현이 독립적이지 않습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="갱신-손실-방지"></a>갱신 손실 방지<a class="hash-link" href="#갱신-손실-방지" title="Direct link to heading">#</a></h3><ul><li><strong>갱신 손실(lost update) 문제</strong>는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때, 발생할 수 있습니다.</li><li>두 트랜잭션이 이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있습니다. (나중에 쓴게 먼저 쓴거를 덮어씁니다.)</li><li>아래의 경우에서 발생할 수 있습니다.<ul><li>카운터를 증가시키거나 계좌 잔고를 갱신하는 경우</li><li>복잡한 값을 지역적으로 변경합니다.</li><li>위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="원자적-쓰기-연산"></a>원자적 쓰기 연산<a class="hash-link" href="#원자적-쓰기-연산" title="Direct link to heading">#</a></h4><ul><li>여러 데이터베이스에서 원자적 갱신 연산을 제공합니다.</li><li>원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해서 구현합니다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 합니다. <strong>(커서 안전성, cursor stability)</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="명시적인-잠금"></a>명시적인 잠금<a class="hash-link" href="#명시적인-잠금" title="Direct link to heading">#</a></h4><ul><li>데이터베이스에서 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 방법은 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것입니다.</li><li>올바르게 동작하려면 애플리케이션 로직에 대해 신중하게 생각해야 합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TRANSACTION</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> figures</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> name </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;robot&#x27;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> game_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">222</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">FOR</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- 이동이 유효한지 확인후, 반환된 것의 위치 갱신</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token plain"> figures </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> position </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;c4&#x27;</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">COMMIT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="갱신-손실-자동-감지"></a>갱신 손실 자동 감지<a class="hash-link" href="#갱신-손실-자동-감지" title="Direct link to heading">#</a></h4><ul><li>원자적 연산과 잠금은 <code>read-modify-write</code> 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법입니다.</li><li>이 방법의 <strong>이점</strong>은 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행활 수 있다는 것입니다.</li><li>갱신 손실 감지는 애플리케이션 코드에서 어떤 특별한 데이터베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="compare-and-set"></a>Compare-and-set<a class="hash-link" href="#compare-and-set" title="Direct link to heading">#</a></h4><ul><li>연산의 목적은 값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것입니다.</li><li>현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도 해야합니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- 데이터베이스 구현에 따라 안전할 수도 안전하지 않을 수도 있습니다.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token plain"> wiki_pages </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> content </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;new content&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> content </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;old content&#x27;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="충돌-해소와-복제"></a>충돌 해소와 복제<a class="hash-link" href="#충돌-해소와-복제" title="Direct link to heading">#</a></h4><ul><li>잠금과 <code>compare-and-set</code> 연산은 데이터의 최신 복사본이 하나만 있다고 가정합니다. 그러나 다중 리더나 리더 없는 복제는 데이터의 최신 복사본이 하나만 있다고 보장할 수 없습니다.</li><li>복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 <strong>충돌된 버전(형제, sibling)</strong> 을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것입니다.</li><li>원자적 연산은 복제 상황에서도 잘 동작합니다.</li><li><strong>최종 쓰기 승리(last write wins, LWW)</strong> 충돌 해소 방법은 갱신 손실이 발생하기 쉽습니다. 많은 복제 데이터베이스는 LWW가 기본 설정입니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스큐와-팬텀"></a>쓰기 스큐와 팬텀<a class="hash-link" href="#쓰기-스큐와-팬텀" title="Direct link to heading">#</a></h3><ul><li>앞에서는 다른 트랜잭션들이 동시에 같은 객체에 쓰려고 할 때 발생할 수 있는 두 가지 경쟁 조건인 <strong>더티 쓰기</strong>와 <strong>갱신 손실</strong>을 보았습니다.</li><li>예를 위하 두 사람이 호출 대기를 하는데 동시에 호출 대기를 끄는 경우, 둘다 빠지는 문제가 발생합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스큐를-특징짓기"></a>쓰기 스큐를 특징짓기<a class="hash-link" href="#쓰기-스큐를-특징짓기" title="Direct link to heading">#</a></h4><ul><li>위의 이상 현상을 <strong>쓰기 스큐(write skew)</strong> 라고 합니다.</li><li>두 트랜잭션이 두 개의 다른 객체를 갱신하므로 더티 쓰기도 갱신 손실도 아닙니다.</li><li>쓰기 스큐를 갱신 손실 문제가 일반화된 것으로 생각할 수도 있고 쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그중 일부를 갱신할 때 나타낼 수 있습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">-- 이를 잠구는 방법은 다음과 같습니다.</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">BEGIN</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">TRANSACTION</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> doctors</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> on_call </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">true</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> shift_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FOR</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">UPDATE</span><span class="token plain"> doctors</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">SET</span><span class="token plain"> on_call </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token boolean" style="color:rgb(255, 88, 116)">false</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> name </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;Alice&#x27;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"> shift_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">1234</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">COMMIT</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="추가적인-쓰기-스큐의-예"></a>추가적인 쓰기 스큐의 예<a class="hash-link" href="#추가적인-쓰기-스큐의-예" title="Direct link to heading">#</a></h4><ul><li>회의실 예약 시스템</li><li>다중플레이어 게임</li><li>사용자명 획득</li><li>이중 사용(double-spending) 방지</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스큐를-유발하는-팬텀"></a>쓰기 스큐를 유발하는 팬텀<a class="hash-link" href="#쓰기-스큐를-유발하는-팬텀" title="Direct link to heading">#</a></h4><ul><li>아래의 비슷한 패턴을 따릅니다.<ul><li>SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인합니다.</li><li>첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정합니다.</li><li>애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋합니다.</li></ul></li><li>어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 <strong>팬텀(phantom)</strong> 이라고 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="충돌-구체화"></a>충돌 구체화<a class="hash-link" href="#충돌-구체화" title="Direct link to heading">#</a></h4><ul><li>팬텀의 문제가 잠글 수 있는 객체가 없다는 것이라면 인위적으로 데이터베이스에 잠금 객체를 추가합니다.</li><li>위의 예시에서 예약하는 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 로우를 잠금한 후 그후에 예약이 있는지 확인하고 새 예약을 삽입합니다.</li><li>이러한 방법을 <strong>충돌 구체화(materializing conflict)</strong> 라고 합니다. 팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하기 때문입니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬성"></a>직렬성<a class="hash-link" href="#직렬성" title="Direct link to heading">#</a></h2><p>위의 내용에서 아래의 문제점도 있습니다.</p><ul><li>격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 대한 일관성이 없습니다.</li><li>애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어렵습니다.</li><li>경쟁 조건을 감지하는데 도움이 되는 도구가 없습니다.</li></ul><p>이때 직렬성 격리가 좋습니다. 직렬성 격리는 보통 가장 강력한 격리 수준으로 여겨지며, <strong>여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한번에 하나씩 직렬로 실행될 때와 같도록 보장</strong>합니다. 즉, 데이터베이스가 발생할 수있는 모든 경쟁 조건을 막아줍니다.</p><p>직렬성을 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용합니다.</p><ul><li>트랜잭션 순차적 실행</li><li>2단계 잠금</li><li>직렬성 스냅숏 격리 같은 낙관적 동시성 제어</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="실제적인-직렬-실행"></a>실제적인 직렬 실행<a class="hash-link" href="#실제적인-직렬-실행" title="Direct link to heading">#</a></h3><ul><li>동시성 문제를 피하는 가장 간단한 방법은 동시성을 제거하는 것</li><li>최근에 들어서야 실현 가능하다고 결론지었으며 이가 가능하다고 생각된 이유는 두가지 발전입니다.<ul><li>램 가격의 하락으로 인해 데이터셋 전체를 메모리에 유지할 수 있게 되었습니다.</li><li>데이터베이스 설계자들이 OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달았습니다.</li></ul></li><li>이들의 처리량은 CPU 코어 하나의 처리량으로 제한됨으로 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와 다르게 구성해야 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="트랜잭션을-스토어드-프로시저-안에-캡슐화하기"></a>트랜잭션을 스토어드 프로시저 안에 캡슐화하기<a class="hash-link" href="#트랜잭션을-스토어드-프로시저-안에-캡슐화하기" title="Direct link to heading">#</a></h4><ul><li>트랜잭션을 길게 유지하면 사용자 응답을 대기하는 시간이 길어지므로 이를 회피하기 위해 트랜잭션을 짧게 유지합니다.</li><li>상호작용식 트랜잭션(질의실행 -&gt; 결과 읽기 -&gt; 다른 질의 실행) 은 애플리케이션과 데이터베이스 사이의 네트워크 통신에 많은 시간을 소비합니다.</li><li>따라서 데이터베이스에서 쓸만한 성능을 얻으려면 여러 트랜잭션을 동시에 처리할 필요가 있습니다.</li><li>단일 스레드에서 트랜잭션을 순차적으로 처리하는 시스템은 상호작용하는 다중 구문 트랜잭션을 처리하지 않고, 트랜잭션 코드 전체를 <strong>스토어드 프로시저 형태로 데이터베이스에 미리 제출</strong>합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스토어드-프로시저의-장단점"></a>스토어드 프로시저의 장단점<a class="hash-link" href="#스토어드-프로시저의-장단점" title="Direct link to heading">#</a></h4><p>스토어 프로시저의 단점</p><ul><li>데이터베이스 벤더마다 제각각의 스토어드 프로시저용 언어가 있으며 언어들은 범용 프로그래밍 언어의 발전을 잡지못해 노후화되어 보입니다.</li><li>데이터베이스에서 실행되는 코드는 관리하기가 어렵습니다.</li><li>데이터베이스는 애플리케이션 서버보다 훨씬 더 성능에 민감할 때가 많습니다.</li></ul><p>스토어 프로시저의 장점</p><ul><li>현대의 스토어 프로시저는 기존의 범용 프로그래밍 언어를 제공합니다.</li><li>스토어드 프로시저가 있고 데이터가 메모리에 저장된다면 모든 트랜잭션을 단일 스레드에서 실행하는 게 현실성이 있습니다. I/O 대기가 없고 동시성 제어 메커니즘의 오버헤드를 회피함으로 좋은 처리량을 얻을 수 있습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="파티셔닝"></a>파티셔닝<a class="hash-link" href="#파티셔닝" title="Direct link to heading">#</a></h4><ul><li>위의 내용처럼 모든 트랜잭션을 순차적으로 실행한다면 동시성 제어는 훨씬 간단해지지만 데이터베이스의 트랜잭션 처리량이 단일 장비에 있는 단일 CPU 코어의 속도로 제한됩니다.</li><li>여러 CPU와 여러 노드로 확장하기 위해 데이터를 파티셔닝할 수도 있습니다.</li><li>여러 파티션에 접근해야 하는 트랜잭션이 있다면 데이터베이스가 해당 트랜잭션이 접근하는 모든 파티션에 걸쳐서 코디네이션 해야합니다.</li><li>여러 파티션에 걸친 트랜잭션은 추가적인 코디네이션 오버헤드가 있으므로 단일 파티션 트랜잭션보다 엄청나게 느립니다.</li><li>트랜잭션이 단일 파티션에서 실행될 수 있는지 여부는 애플리케이션에서 사용되는 데이터 구조에 매우 크게 의존합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬-실행-요약"></a>직렬 실행 요약<a class="hash-link" href="#직렬-실행-요약" title="Direct link to heading">#</a></h4><p>트랜잭션 직렬 실행은 몇가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이 됬습니다.</p><ul><li>모든 트랜잭션은 작고 빨라야 합니다.</li><li>활성화된 데이터벳이 메모리에 적재될 수 있는 경우로 사용이 제한됩니다.</li><li>쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 합니다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝 해야합니다.</li><li>여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있습니다.</li></ul><blockquote><p>Q. 어떤 데이터를 DB에 업데이트 해야하는데 업데이트 하나 SP랑 애플리케이션에서 나눠서 10개의 SP(부분적으로 업데이트 범위가 다른)를 쓰는 경우 어떤게 더 빠를까요?</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2단계-잠금2pl"></a>2단계 잠금(2PL)<a class="hash-link" href="#2단계-잠금2pl" title="Direct link to heading">#</a></h3><ul><li>2단계 잠금(two-phase locking, 2PL)은 더티 쓰기의 잠금과 비슷하지만 훨씬 더 강합니다. 쓰기를 실행하는 트랜잭션이 없는 여러 트랜잭션에서 동시에 읽을 수 있으나 쓰기를 하려면 독점적인 접근이 필요합니다.</li><li>2PL에서 쓰기 트랜잭션은 다른 쓰기 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립합니다.</li><li>스냅숏 격리는 <strong>읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다는 원칙</strong>이 있으나, 2PL은 직렬성을 제공하므로 앞에서 설명한 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해줍니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2단계-잠금-구현"></a>2단계 잠금 구현<a class="hash-link" href="#2단계-잠금-구현" title="Direct link to heading">#</a></h4><ul><li>읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용해 구현합니다.</li><li>잠금은 <strong>공유 모드(shared mode)</strong> 나 <strong>독점 모드(exclusive mode)</strong> 로 사용될 수 있습니다.</li><li>잠금은 다음과 같이 사용됩니다.<ul><li>트랜잭션이 객체 읽기를 원한다면 먼저 공유모드로 잠금을 획득합니다.</li><li>트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야합니다.</li><li>트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유 잠금을 독점 잠금으로 업그레이드해야 합니다.</li><li>트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될 때까지 잠금을 갖고 있어야 합니다.</li></ul></li><li>잠금이 아주 많이 사용됨으로 트랜잭션 A는 트랜잭션 B가 잠금을 해제하기를 기다리느라 멈춰있고, 트랜잭션 B도 트랜잭션 A가 잠금을 해제하기를 기다리느라 멈춰 있는 상황이 매우 쉽게 발생하는데 이런 상황을 <strong>교착 상태</strong>라고 합니다.<ul><li>데이터베이스는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 트랜잭션 중 하나를 어보트 시켜서 다른 트랜잭션들이 진행할 수 있게 합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2단계-잠금의-성능"></a>2단계 잠금의 성능<a class="hash-link" href="#2단계-잠금의-성능" title="Direct link to heading">#</a></h4><ul><li>2단계 잠금의 큰 약점은 성능입니다.</li><li>2단계 잠금을 사용하면 완화된 격리 수준을 쓸 때보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠집니다.</li><li>부분적으로는 잠금을 획득하고 해제하는 오버헤드 때문이지만 더 중요한 원인은 동시성이 줄어드는 것입니다.</li><li>전통적인 관계형 데이터베이스들은 트랜잭션의 실행 시간을 제한하지 않습니다. 상호작용시 애플리케이션에서 사용자의 입력을 기다리도록 설되었습니다. 그렇기 때문에 경쟁이 있다면 매우 느릴 수 있습니다.</li><li>2PL 직렬성 격리에서는 교착 상태가 훨씬 더 자주 발생합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="서술-잠금"></a>서술 잠금<a class="hash-link" href="#서술-잠금" title="Direct link to heading">#</a></h4><ul><li>직렬성 격리를 쓰는 데이터베이스는 팬텀을 막야아 합니다.</li><li>개념상으로서는 서술 잠금(predicate lock)이 필요합니다.<ul><li>서술 잠음은 앞의 공유/독점 잠금과 비슷하게 동작하지만 특정 객체에 속하지 않고 아래와 같은 여러 검색 조건에 부합하는 모든 객체에 속합니다.</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly sql"><div tabindex="0" class="prism-code language-sql codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">FROM</span><span class="token plain"> bookings</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">WHERE</span><span class="token plain"> room_id </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">213</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        end_time </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;2018-01-01 12:00&#x27;</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">AND</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        start_time </span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">&#x27;2018-01-01 13:00&#x27;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>서술 잠금이 접근을 제한하는 방법은 다음과 같습니다.<ul><li>트랜잭션 A가 위 SELECT 질의처럼 어떤 조건에 부합하는 객체를 읽기 원한다면 질의의 조건에 대한 공유 모드 서술 잠금을 획득해야 합니다.</li><li>트랜잭션 A가 어떤 객체를 삽입, 갱신, 삭제하기를 원한다면 먼저 기존 값이나 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="색인-범위-잠금"></a>색인 범위 잠금<a class="hash-link" href="#색인-범위-잠금" title="Direct link to heading">#</a></h4><ul><li>서술 잠금은 잘 동작하지 않습니다. (잠금 확인 시간이 오래걸리므로)</li><li>실제로는 <strong>색인 범위 잠금(index-range locking, 다음 키 잠금(next-key locking))</strong> 을 구현합니다.</li><li>어떤 방법을 쓰던지 간략화한 검색 조건이 색인 중 하나에 붙습니다.</li><li>이 방법을 쓰면 팬텀과 쓰기 스큐로부터 보호해주는 효과를 낳습니다.<ul><li>색인 범위 잠금은 서술 잠금보다 정밀하지는 않지만 오버헤드가 훨씬 더 낮으므로 좋은 타협안이 됩니다.</li></ul></li><li>범위 잠금을 잡을 수 있는 적합한 색인이 없다면 데이터베이스는 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있습니다. (성능적으로는 좋지 않으나 안전한 대비책입니다.)</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬성-스냅숏-격리ssi"></a>직렬성 스냅숏 격리(SSI)<a class="hash-link" href="#직렬성-스냅숏-격리ssi" title="Direct link to heading">#</a></h3><ul><li>직렬성 스냅숏 격리(serializable snapshot isolation, SSI)는 완전한 직렬성을 제공하고 스냅숏 격리에 비해 약간의 성능 손해만 있습니다. (최근에 등장)</li><li>오늘날 SSI는 단일 노드 데이터베이스와 분산 데이터베이스 모두에서 사용됩니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="비관적-동시성-제어-대-낙관적-동시성-제어"></a>비관적 동시성 제어 대 낙관적 동시성 제어<a class="hash-link" href="#비관적-동시성-제어-대-낙관적-동시성-제어" title="Direct link to heading">#</a></h4><ul><li>2단계 잠금은 이른바 <strong>비관적</strong> 동시성 제어 메커니즘 입니다.<ul><li>뭔가 잘못될 가능성이 있으면 뭔가 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 합니다.</li><li>다중 스레드 프로그래밍에서 자료구조 보호를 위해 사용되는 <strong>상호 배제(mutual exclusion)</strong> 와 비슷합니다.</li></ul></li><li>직렬 실행은 트랜잭션이 실행되는 동안 전체 데이터베이스에 독점 잠금을 획득하는 것과 본질적으로 같습니다.</li><li>직렬성 스냅숏 격리는 <strong>낙관적 동시성 제어 기법</strong>입니다.<ul><li>트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다는 뜻입니다.</li><li>예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있습니다.</li></ul></li><li>SSI는 스냅숏 격리를 기반으로 합니다. 즉, 트랜잭션에서 실행되는 모든 읽기는 데이터베이스의 일관된 스냅숏을 보게 됩니다.</li><li>SSI는 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="뒤처진-전제에-기반한-결정"></a>뒤처진 전제에 기반한 결정<a class="hash-link" href="#뒤처진-전제에-기반한-결정" title="Direct link to heading">#</a></h4><ul><li>트랜잭션은 어떤 전데를 기반으로 어떤 동작을 합니다.</li><li>애플리케이션이 질의를 실행할 때 데이터베이스는 애플리케이션 로직이 질의 결과를 어떻게 사용할지 모릅니다.</li><li>데이터베이스가 질의 결과가 바뀌었는지 알 수 있는 방법은 두가지 상황이 있습니다.<ul><li>오래된(stale) MVCC 객체 버전을 읽었는지 감지하기 (읽기 전에 커밋되지 않은 쓰기가 발생했음)</li><li>과거의 읽기에 영향을 미치는 쓰기 감지하기(읽은 후에 쓰기가 실행됨)</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="오래된-mvcc-읽기-감지하기"></a>오래된 MVCC 읽기 감지하기<a class="hash-link" href="#오래된-mvcc-읽기-감지하기" title="Direct link to heading">#</a></h4><ul><li>트랜잭션이 MVCC 데이터베이스의 일관된 스냅숏에서 읽으면 스냅숏 생성 시점에 다른 트랜잭션이 썼지만 아직 커밋되지 않은 데이터는 무시합니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/141098286-3db10978-94ca-491c-80ed-331e36ecca2c.png" alt="트랜잭션이 MVCC 스냅숏에서 뒤처진 값을 읽은지 감지"></p><ul><li>데이터베이스는 트랜잭션이 MVCC 가시성 규칙에 따라 다른 트랜잭션의 쓰기를 무시하는 경우를 추적합니다.</li><li>SSI는 불필요한 어보트를 피해서, 일관된 스냅숏에서 읽으며 오래 실행되는 작업을 지원하는 스냅숏 격리의 특성을 유지합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="과거의-읽기와-영향을-미치는-쓰기-감지하기"></a>과거의 읽기와 영향을 미치는 쓰기 감지하기<a class="hash-link" href="#과거의-읽기와-영향을-미치는-쓰기-감지하기" title="Direct link to heading">#</a></h4><ul><li>트랜잭션이 완료되고 동시에 실행되는 모든 트랜잭션들이 완료된 후에 데이터베이스는 트랜잭션에서 어떤 데이터를 읽었는지 잊어버려도 됩니다.</li><li>트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="직렬성-스냅숏-격리의-성능"></a>직렬성 스냅숏 격리의 성능<a class="hash-link" href="#직렬성-스냅숏-격리의-성능" title="Direct link to heading">#</a></h4><ul><li>트랜잭션에서 다양한 트레이드오프가 있으며 트랜잭션의 읽기 쓰기를 추적하는 세밀함의 정도입니다.</li><li>데이터베이스가 각 트랜잭션의 동작을 매우 상세하게 추적하면 어보트돼야 하는 트랜잭션을 정확히 판별할 수 있지만 기록 오버헤드가 심해질 수 있습니다.</li><li>데이터베이스가 각 트랜잭션의 동작을 매우 상세하게 추적하면 어보트돼야 하는 트랜잭션을 정확히 판별할 수 잇지만 기록 오버헤드가 심해질 수 있습니다.</li><li>2단계 잠금과 비교할 때 직렬성 스냅숏 격리의 큰 <strong>이점</strong>은 <strong>트랜잭션이 다른 트랜잭션들이 잡고 있는 잠금을 기다리느라 차단될 필요가 없습니다.</strong></li><li>순차 실행과 비교할 때 직렬성 스냅숏 격리는 단일 CPU 코어의 처리량에 제한되지 않습니다.<ul><li>직렬성 충돌 감지를 여러 장비로 분산시켜서 처리량이 아주 높도록 확장할 수 있습니다.</li><li>데이터가 여러 장비에 걸쳐서 파티셔닝돼 있더라도 트랜잭션은 직렬성 격리를 보장하면서 여러 파티션으로부터 읽고 쓸 수 있습니다.</li></ul></li><li>어보트 비율은 SSI의 전체적인 성능에 큰 영향을 미칩니다.<ul><li>오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬우므로 SSI는 릭기 쓰기 트랜잭션이 상당히 짧기를 요구합니다.</li><li>SSI는 2단계 잠금이나 순차 실행보다는 느린 트랜잭션에 덜 민감합니다.</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정리"></a>정리<a class="hash-link" href="#정리" title="Direct link to heading">#</a></h2><p>트랜잭션이 애플리케이션이 <strong>어떤 동시성 문제와 어떤 종류의 하드웨어와 소프트웨어 결함이 존재하지 않는 것처럼 동작할 수 있게 도와주는 추상층</strong>입니다.</p><p>모든 애플리케이션이 이런 문제에 민감하지 않으며 단일 레코드만 읽거나 쓰는 것처럼 간단한 경우는 트랜잭션 없이도 관리할 수 있으나, 접근 패턴이 복잡할 때는 트랜잭션이 상상할 수 있는 잠재적인 오류를 줄여줍니다.</p><ul><li>트랜잭션이 없으면 다양한 오류 시나리오에서 다양한 방법으로 데이터가 일관성이 깨질 수 있습니다.</li><li>트랜잭션이 없다면 복잡한 상호작용을 하는 접근이 데이터베이스에 미치는 영향을 뗘보기가 매우 어렵습니다.</li></ul><p>격리 수준들의 특징은 다음과 같습니다.</p><ul><li>더티 읽기<ul><li>한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 읽습니다.</li><li>커밋 후 읽기 또는 그보다 강한 격리 수준은 더티 읽기를 방지합니다.</li></ul></li><li>더티 쓰기<ul><li>한 클라이언트가 다른 클라이언트가 썼지만 아직 커밋되지 않은 데이터를 덮어씁니다.</li><li>거의 모든 트랜잭션 구현은 더티 쓰기를 방지합니다.</li></ul></li><li>읽기 스큐(비반복 읽기)<ul><li>클라이언트는 다른 시점에 데이터베이스의 다른 부분을 봅니다.</li><li>스냅숏으로부터 읽는 스냅숏 격리를 가장 흔히 사용합니다.</li></ul></li><li>갱신 손실<ul><li>두클라이언트가 동시에 read-modify-write 주기를 실행합니다.</li><li>한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터가 손실됩니다.</li></ul></li><li>쓰기 스큐<ul><li>트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 씁니다.</li><li>쓰기를 실행하는 시점에서 결정의 전제가 참이 아니며 직렬성 격리만 이런 이상 현상을 막을 수 있습니다.</li></ul></li><li>팬텀 읽기<ul><li>트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽고, 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행합니다.</li><li>스냅숏 격리는 간단한 팬텀 읽기는 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요합니다.</li></ul></li></ul><p>완화된 격리 수준은 이런 이상 현상 중 일부는 막아주지만 나머지는 애플리케이션 개발자가 수동으로 처리해야합니다. 직렬성 격리만 이 모든 문제를 막을 수 있으며 직렬성 트랜잭션을 구현하는 방법으로 아래 세가지가 있습니다.</p><ul><li>트랜잭션을 순서대로 실행<ul><li>트랜잭션이 실행 시간이 아주 짧고 트랜잭션 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 트랜잭션 처리량이 낮다면 간단하고, 효과적인 선택입니다.</li></ul></li><li>2단계 잠금(2PL)<ul><li>직렬성을 구현하는 표준적인 방법이였으나 성능 특성 때문에 피하는 애플리케이션이 많습니다.</li></ul></li><li>직렬성 스냅숏 격리(SSI)<ul><li>앞의 결점 대부분을 피합니다.</li><li>낙관적 방법을 사용해서 트랜잭션이 차단되지 않고 진행할 수 있게 합니다.</li><li>트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않다면 어보트 시킵니다.</li></ul></li></ul><p>이번 장에서는 단일 장비에서 데이터베이스를 실행하는 맥락에서 아이디어와 알고리즘을 살펴보았습니다. 다음 두 장에서는 분산 데이터베이스에서의 트랜잭션에서 발생하는 문제에 해결책을 이야기합니다.</p><hr><ul><li><a href="https://en.wikipedia.org/wiki/Multiple_granularity_locking" target="_blank" rel="noopener noreferrer">다중 단위크기 단게 로킹</a></li><li><a href="https://brunch.co.kr/@toughrogrammer/17" target="_blank" rel="noopener noreferrer">DB 관련 꼭 읽어볼 글</a></li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/data/designing-data-intensive-applications/ch7.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-10-23T12:03:49.000Z" class="lastUpdatedDate_1WI_">10/23/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/data/designing-data-intensive-applications/ch6"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 6. 파티셔닝</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/data/designing-data-intensive-applications/ch8"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">8. 분산 시스템의 골칫거리 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#애매모호한-트랜잭션의-개념" class="table-of-contents__link">애매모호한 트랜잭션의 개념</a><ul><li><a href="#acid의-의미" class="table-of-contents__link">ACID의 의미</a></li><li><a href="#단일-객체-연산과-다중-객체-연산" class="table-of-contents__link">단일 객체 연산과 다중 객체 연산</a></li></ul></li><li><a href="#완화된-격리-수준" class="table-of-contents__link">완화된 격리 수준</a><ul><li><a href="#커밋-후-읽기" class="table-of-contents__link">커밋 후 읽기</a></li><li><a href="#스냅숏-격리와-반복-읽기" class="table-of-contents__link">스냅숏 격리와 반복 읽기</a></li><li><a href="#갱신-손실-방지" class="table-of-contents__link">갱신 손실 방지</a></li><li><a href="#쓰기-스큐와-팬텀" class="table-of-contents__link">쓰기 스큐와 팬텀</a></li></ul></li><li><a href="#직렬성" class="table-of-contents__link">직렬성</a><ul><li><a href="#실제적인-직렬-실행" class="table-of-contents__link">실제적인 직렬 실행</a></li><li><a href="#2단계-잠금2pl" class="table-of-contents__link">2단계 잠금(2PL)</a></li><li><a href="#직렬성-스냅숏-격리ssi" class="table-of-contents__link">직렬성 스냅숏 격리(SSI)</a></li></ul></li><li><a href="#정리" class="table-of-contents__link">정리</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.f33c1eac.js"></script>
<script src="/til/assets/js/main.f4846ab0.js"></script>
</body>
</html>