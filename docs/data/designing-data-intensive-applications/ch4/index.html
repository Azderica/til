<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/til/blog/rss.xml" title="Log that Today I Learned Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/til/blog/atom.xml" title="Log that Today I Learned Blog Atom Feed"><title data-react-helmet="true">4. 부호화와 발전 | Log that Today I Learned</title><meta data-react-helmet="true" property="og:url" content="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch4"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="4. 부호화와 발전 | Log that Today I Learned"><meta data-react-helmet="true" name="description" content="만물은 변한다. 그대로 있는 것은 아무것도 없다."><meta data-react-helmet="true" property="og:description" content="만물은 변한다. 그대로 있는 것은 아무것도 없다."><link data-react-helmet="true" rel="shortcut icon" href="/til/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch4"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch4" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://Azderica.github.io/til/docs/data/designing-data-intensive-applications/ch4" hreflang="x-default"><link rel="stylesheet" href="/til/assets/css/styles.dc5e9681.css">
<link rel="preload" href="/til/assets/js/runtime~main.1cdd1183.js" as="script">
<link rel="preload" href="/til/assets/js/main.63620547.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/til/docs/intro">Docs</a><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Blog</a><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/til/"><strong class="navbar__title">Azderica TIL</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/til/docs/intro">Docs</a></li><li class="menu__list-item"><a href="https://Azderica.github.io" target="_blank" rel="noopener noreferrer" class="menu__link">Blog</a></li><li class="menu__list-item"><a href="https://github.com/Azderica" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/til/docs/intro">📚Welcome TIL</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">data</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">데이터 중심 애플리케이션 설계</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch1">1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch2">2. 데이터 모델과 질의 언어</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch3">3. 저장소와 검색</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch4">4. 부호화와 발전</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch5">5. 복제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch6">6. 파티셔닝</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch7">7. 트랜잭션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch8">8. 분산 시스템의 골칫거리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch9">9. 일관성과 합의</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch10">10. 일괄 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch11">11. 스트림 처리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/til/docs/data/designing-data-intensive-applications/ch12">12. 데이터 시스템의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">dev</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Architecture</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch1">1부. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch2">2부. 벽돌부터 시작하기: 프로그래밍 패러다임</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch3">3. 설계 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch4">4. 컴포넌트 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch5">5. 아키텍처</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-architecture/ch6">6. 세부사항</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Clean Code</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch1">Clean Code 내용 정리 - 1</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch2">Clean Code 내용 정리 - 2</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch3">Clean Code 내용 정리 - 3</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch4">Clean Code 내용 정리 - 4</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch5">Clean Code 내용 정리 - 5</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/clean-code/ch6">Clean Code 내용 정리 - 6</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">DDD START!</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch1">1. 도메인 모델 시작</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch2">2. 아키텍처 개요</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch3">3. 애그리거트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch4">4. 리포지터리와 모델구현 (JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch5">리포지터리의 조회 기능(JPA 중심)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch6">6. 응용 서비스와 표현 영역</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch7">7. 도메인 서비스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch8">8. 애그리거트 트랜잭션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch9">9. 도메인 모델과 BOUNDED CONTEXT</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch10">10. 이벤트</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/ddd-start/ch11">11. CQRS</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체 지향과 디자인 패턴</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch1">객체 지향</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch2">설계 원칙/ DI와 서비스 로케이터</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/object-orientation-and-design-patterns/ch3">주요 디자인 패턴</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Refactoring</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch1">1. 리팩터링: 첫 번째 예시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch2">2. 리팩토링 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch3">3. 코드에서 나는 악취</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch4">4. 테스트 구축하기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch5">5. 리팩토링 카탈로그 보는 법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch6">6. 기본적인 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch7">7. 캡슐화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch8">8. 기능 이동</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch9">9. 데이터 조직화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch10">10. 조건부 로직 간소화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch11">11. API 리팩터링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/refactoring/ch12">12. 상속 다루기</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">객체지향의 사실과 오해</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch1">1. 협력하는 객체들의 공동체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch2">2. 이상한 나라의 객체</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch3">3. 타입과 추상화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch4">4. 역할, 책임, 협력</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch5">5. 책임과 메시지</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch6">6. 객체 지도</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch7">7. 함께 모으기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-essence-of-object-orientation/ch8">부록. 추상화 기법</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">실용주의 프로그래머</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch0">0. 실용주의 프로그래머</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch1">1. 실용주의 철학</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch2">2. 실용주의 접근법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch3">3. 기본적인 도구</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch4">4. 실용주의 편집증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch5">5. 구부러지거나 부러지거나</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch6">6. 코딩하는 동안 해야 할 일들</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch7">7. 프로젝트 전에</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/dev/the-pragmatic-programmer/ch8">8. 실용주의 프로젝트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">java</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch1">1. 소개</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch2">2. 객체 생성과 삭제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch3">3. 모든 객체의 공통적인 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch4">4. 클래스와 인터페이스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch5">5. 제네릭</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch6">6. Enums 타입과 어노테이션</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch7">7. 람다와 스트림</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch8">8. 메소드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch9">9. 일반적인 프로그래밍 원칙</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch10">10. 예외</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch11">11. 동시성, Concurrency</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/effective-java/ch12">12. 직렬화, Serialization</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Optimizing Java</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch1">1. 성능과 최적화</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch2">2. JVM 이야기</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch3">3. 하드웨어와 운영체제</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch4">4. 성능 테스트 패턴 및 안티패턴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch5">5. 마이크로벤치마킹과 통계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch6">6. 가비지 수집 기초</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch7">7. 가비지 수집 고급</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch8">8. GC 로깅, 모니터링, 튜닝, 툴</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch9">9. JVM의 코드 실행</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch10">10. JIT 컴파일의 세계로</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch11">11. 자바 언어의 성능 향상 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch12">12. 동시 성능 기법</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch13">13. 프로파일링</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch14">14. 고성능 로깅 및 메시징</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/java/optimizing-java/ch15">15. 자바 9와의 미래</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">kotlin</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Effective Kotlin</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/effective-kotlin/ch1">1. 안정성</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Kotlin IN Action</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/kotlin/kotlin-in-action/ch1">1. 코틀린이란 무엇이며, 왜 필요한가?</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">spring</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">토비의 스프링</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch1">1장. 오브젝트와 의존관계</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/spring/toby-spring/ch2">2. 테스트</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">web</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">HTTP 완벽 가이드</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch1">1. HTTP 개관</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch2">2. URL과 리소스</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch3">3. HTTP 메서드</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch4">4. 커넥션 관리</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch5">5. 웹 서버</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch6">6. 프락시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch7">7. 캐시</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch8">8. 통합점: 게이트웨이, 터널, 릴레이</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch9">9. 웹 로봇</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch10">10. HTTP/2.0</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch11">11. 클라이언트 식별과 쿠키</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch12">12. 기본 인증</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/til/docs/web/http-perfect-guide/ch13">13. 다이제스트 인증</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">4. 부호화와 발전</h1></header><div class="markdown"><blockquote><p>만물은 변한다. 그대로 있는 것은 아무것도 없다.</p></blockquote><ul><li>애플리케이션은 필연적으로 시간이 지남에 따라 변합니다. 새로운 제품이 출시하거나 요구사항을 잘 이해 혹은 환경이 변함에 따라 기능이 추가되거나 변경됩니다.</li><li>이러한 경우, 애플리케이션 기능을 변경하려면 저장하는 데이터도 변경해야합니다. 다만 스키마가 변경될 수도 있기 때문에 이전 데이터 타입과 새로운 데이터 타입이 섞여 포함될 수 있습니다.</li><li>대규모 애플리케이션에서 코드 변경은 즉시 반영이 힘듭니다.<ul><li>서버측에서는 rolling upgrade, 혹은 staged rollout 이라고 불리는 순회식 업그레이드를 진행합니다.</li><li>클라이언트 측은 애플리케이션에 의해 전적으로 좌우되며 업데이트를 설치하지 않을 수도 있습니다.</li></ul></li><li>즉, 예전 버전의 코드와 새로운 버전의 코드가 공존할 수 있다는 이야기입니다.<ul><li><strong>하위 호환성</strong> : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 합니다.</li><li><strong>상위 호환성</strong> : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 합니다.</li><li>하위 호환성은 일반적으로 어렵지 않으나 상위 호환성은 어렵습니다.</li></ul></li><li>아래의 챔터에서는 JSON, XML, Protocol Buffers등의 데이터 부호화를 위한 다양한 형식을 살펴봅니다.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-부호화-형식"></a>데이터 부호화 형식<a class="hash-link" href="#데이터-부호화-형식" title="Direct link to heading">#</a></h2><ul><li>프로그램은 보통 두가지 형태로 표현된 데이터를 사용해 동작합니다.<ul><li>object, struct, list, array, hash, tree 등의 데이터 구조, <strong>인메모리</strong></li><li>일련의 <strong>바이트</strong>열(ex, JSON 문서)</li><li>인메모리 표현에서 바이트열로의 전환을 <strong>부호화(직렬화나 마샬링)</strong>이라고 하며 반대를 <strong>복호화(파싱, 역직렬화, 언마샬링)</strong>이라고 합니다.</li></ul></li></ul><blockquote><p>직렬화는 트랜잭션에서도 사용되기 때문에 이 책에서는 부호화라고 합니다.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="언어별-형식"></a>언어별 형식<a class="hash-link" href="#언어별-형식" title="Direct link to heading">#</a></h3><ul><li>많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 제공합니다.<ul><li>ex) 자바의 <code>java.io.Serializable</code>, 루비의 <code>Marshal</code>, 파이썬의 <code>pickle</code> 등</li></ul></li><li>프로그래밍 언어에 내장된 부호화 라이브러리는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있기 때문에 매우 편리하나 심각한 문제점 또한 많습니다.<ul><li>부호화는 보통 특정 프로그래밍 언어와 묶여 있는 경우가 많습니다.</li><li>동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 합니다. 이는 보안에서의 문제가 될 수도 있습니다.</li><li>데이터 버전 관리는 보통 부호화 라이브러리에서는 나중에 생각하게 됩니다. 위에 언급된 상위, 하위 호환성의 불편만 문제가 등한시 됩니다.</li><li>효율성도 종종 나중에 생각하게 됩니다. (자바가 그런 경우의 대표라고 합니다.)</li></ul></li><li>매우 일시적인 목적 외에는 언어에 내장된 부호화를 사용하는 방식은 일반적으로 좋지 않습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="json과-xml-이진-변형"></a>JSON과 XML, 이진 변형<a class="hash-link" href="#json과-xml-이진-변형" title="Direct link to heading">#</a></h3><ul><li>많은 프로그래밍에서 읽고 쓸 수 있는 표준화 부호화로 JSON과 XML이 있습니다. 그외에도 CSV가 있습니다.</li><li>JSON, XML, CSV는 텍스트 형식이라 어느 정도 사람이 읽을 수 있습니다. 그러나 몇 가지 문제점이 있습니다.<ul><li>XML과 CSV에서는 수와 digit를 구분할 수 없습니다.</li><li>큰 수를 다룰 때, 부동소수점 수를 사용하는 js 언어에서 파싱할 때 부정확해질 수 있습니다.</li><li>JSON과 XML은 유니코드 문자열을 잘 지원하나 이진 문자열을 지원하지 않습니다.</li></ul></li><li>JSON, XNL, CSV는 다양한 용도에서 장점을 가지며 특히 데이터 교환 형식에서 매우 좋습니다.</li><li>특히 이러한 상황에서는 다른 조직의 동의를 얻는 작업이 어렵습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="이진-부호화"></a>이진 부호화<a class="hash-link" href="#이진-부호화" title="Direct link to heading">#</a></h4><ul><li>조직 내에서 사용하는 경우, 최소공통분모 부호화 형식을 사용해야 하는 부담감이 덜합니다. 즉, 더 간편하고 파싱이 빠른 형식을 쓸 수 있습니다.</li><li>데이터 셋의 크기는 용량이 커질 수록 이득이 커집니다.</li><li>JSON과 XML은 이진 형식에 비교하면 둘 다 훨씬 많은 공간을 사용합니다.</li><li>메시지팩이 대표적인 예시며 JSON용 이진 부호화 형식입니다.</li></ul><p><img src="https://user-images.githubusercontent.com/42582516/137404707-6841c1b9-2f6e-4235-adf1-4b48eaa41548.png" alt="json-messagepack"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스리프트와-프로토콜-버퍼"></a>스리프트와 프로토콜 버퍼<a class="hash-link" href="#스리프트와-프로토콜-버퍼" title="Direct link to heading">#</a></h3><ul><li>아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers)는 같은 원리를 기반으로 한 이진ㄷ 부호화 라이브러리입니다.</li><li>스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요합니다.</li></ul><p>스리프트 예제</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly json"><div tabindex="0" class="prism-code language-json codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct Person </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> required string    userName</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token number" style="color:rgb(247, 140, 108)">2</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> optional i64       favoriteNumber;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  </span><span class="token number" style="color:rgb(247, 140, 108)">3</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> optional list&lt;string&gt; interests</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>프로토콜 예제</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly json"><div tabindex="0" class="prism-code language-json codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">message Person </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  required string user_name      = </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  optional int64 favorite_number = </span><span class="token number" style="color:rgb(247, 140, 108)">2</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  repeated string interests      = </span><span class="token number" style="color:rgb(247, 140, 108)">3</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>스리프트와 프로토콜 버퍼는 각각 여기서 본 것처럼 스키마 정의를 사용해 코드를 생성하는 도구가 있습니다.<ul><li>이 도구를 통해서 다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성합니다.</li><li>애플리케이션 코드는 생성된 코드를 호출해 스키마의 레코드를 부호화하고 복호화합니다.</li></ul></li><li>스리프트는 <strong>바이너리프로토콜(BinaryProtocol)</strong> 과 <strong>컴팩트프로토콜(CompactProtocol)</strong> 이라는 두 가지 이진 부호화 형식이 있습니다.<ul><li>바이너리프로토콜은 필드 이름 대신 <strong>필드 태그(field tag)</strong> 를 포함합니다.</li><li>컴팩트프로토콜은 의미는 같으나 동일한 정보를 34바이트로 줄여서 부호화합니다. (필드 타입과 태그 숫자를 단일 바이트로 줄이고, 가변 길이 변수를 사용합니다.)</li></ul></li><li>프로토콜 버퍼는 스리프트의 컴팩트프로토콜과 비슷하며 같은 데이터를 33바이트로 만듭니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="필드-태그와-스키마-발전"></a>필드 태그와 스키마 발전<a class="hash-link" href="#필드-태그와-스키마-발전" title="Direct link to heading">#</a></h4><ul><li>스키마는 필연적으로 시간이 지남에 따라 변하는 것을 <strong>스키마 발전(schema evolution)</strong> 이라고 부릅니다.</li><li>스리프트와 프로토콜 버퍼는 하위 호환성과 상위 호환성을 유지하기 위해서는 다음의 기능을 제공하빈다.<ul><li>상위 호환성의 경우, 필드에 새로운 태그 번호를 줌으로서 예전 코드가 새로운 코드를 읽을 수 있습니다.</li><li>하위 호환성의 경우, 각 필드에 고유한 태그 번호가 있는 동안에는 같은 의미를 가지고 있기 때문에 예전 데이터를 항상 볼 수 있습니다.</li><li>삭제의 경우, 하위 호환성과 상위 호환성 문제를 해결하는 방식과 반대로 하면 됩니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터타입과-스키마-발전"></a>데이터타입과 스키마 발전<a class="hash-link" href="#데이터타입과-스키마-발전" title="Direct link to heading">#</a></h4><ul><li>필드의 데이터타입을 변경하는 경우는 값이 정확하지 않거나 잘릴 위험이 있습니다.</li><li>프로토콜 버퍼의 기능으로 필드에 repeated 표시자와 optional 필드가 있는데, optional 필드를 repeated 필드로 변경해도 상관이 없습니다.<ul><li>이전 데이터를 읽는 새로운 코드는 0이나 1개의 엘리먼트가 있는 목록으로 봅니다.</li><li>새로운 데이터를 읽는 예전 코드는 목록의 마지막 엘리먼트만 보게 됩니다.</li></ul></li><li>스리프트는 전용 목록 데이터타입이 있으며 목록 데이터타입은 목록 엘리먼트의 데이터타입을 매개변수로 받으며 중첩된 목록을 지원한다는 장점이 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="아브로"></a>아브로<a class="hash-link" href="#아브로" title="Direct link to heading">#</a></h3><ul><li><strong>아파치 아브로</strong>는 프로토콜 버퍼와 스리프트와는 다른 또 하나의 이진 부호화 형식입니다.</li><li>아브로의 예제 스키마는 다음과 같습니다.</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly json"><div tabindex="0" class="prism-code language-json codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">record Person </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  string             userName;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  union </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token null keyword" style="font-style:italic">null</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> long</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"> favoriteNumber = </span><span class="token null keyword" style="font-style:italic">null</span><span class="token plain">;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  array&lt;string&gt;      interests;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><ul><li>바이트열에 필드나 데이터타입을 식별하기 위한 정보가 없습니다.</li><li>아브로를 통해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필드의 데이터타입을 미리 파악해야합니다.<ul><li>정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있습니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="쓰기-스키마와-읽기-스키마"></a>쓰기 스키마와 읽기 스키마<a class="hash-link" href="#쓰기-스키마와-읽기-스키마" title="Direct link to heading">#</a></h4><ul><li>애플리케이션이 파일인 데이터베이스에 쓰거나 전송 등의 목적으로 어떤 데이터를 아브로로 부호화하길 원한다면 알고 있는 스키마 버전을 사용해 데이터를 부호화합니다. 이 스키마를 <strong>쓰기 스키마(writer&#x27;s schema)</strong> 라고 합니다.</li><li>애플리케이션이 파일이나 데이터베이스에서 또는 네트워크로부터 수신 등으로 읽은 어떤 데이터를 복호화하길 원한다면 데이터가 특정 스키마로 복호화하기를 기대합니다. 이 스키마를 <strong>읽기 스키마(reader&#x27;s schema)</strong> 라고 합니다.</li><li>아브리의 핵심 아이디어는 쓰기 스키마와 읽기 스키마가 동일하지 않아도 되며 <strong>단지 호환가능하면 된다는 것</strong>입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스키마-발전-규칙"></a>스키마 발전 규칙<a class="hash-link" href="#스키마-발전-규칙" title="Direct link to heading">#</a></h4><ul><li>아브로에서 상위 호환성은 새로운 버전의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음을 의미합니다.</li><li>호환성을 유지하기 위해서는 기본 값이 있는 필드만 추가하거나 삭제할 수 있습니다.</li><li>기본값이 없는 필드를 추가하면 새로운 읽기는 예전 쓰기가 기롭된 데이터를 읽을 수 없기 때문에 하위 호환성이 깨집니다.</li><li>아브로에서는 널을 허용하기 위해 <strong>유니온 타입(union type)</strong> 을 사용해야 합니다.</li><li>아브로는 프로토콜 버퍼, 스리프트와 동일한 방식의 optional과 required 표시자를 가지고 있지 않습니다.</li><li>아브로는 타입을 변환할 수 있으므로 필드의 데이터타입 변경이 가능합니다. 필드 이름 변경도 가능하지만 조금 까다롭습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="그러면-쓰기-스키마는-무엇인가"></a>그러면 쓰기 스키마는 무엇인가<a class="hash-link" href="#그러면-쓰기-스키마는-무엇인가" title="Direct link to heading">#</a></h4><ul><li>모든 레코드에 전체 스키마를 포함시킬 수는 없습니다. 왜냐하면 스키마는 부호화된 데이터보다 훨씬 클 가능성이 있습니다.</li><li>아브로를 사용하는 상황에 따라 다릅니다.<ul><li>(1) 많은 레코드가 있는 대용량 파일<ul><li>아브로의 일반적인 용도, 쓰기 시작 부분에 한번만 쓰기 스키마를 포함시키면 됩니다.</li></ul></li><li>(2) 개별적으로 기록된 레코드를 가진 데이터베이스<ul><li>레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스에 스키마 버전 목록을 유지합니다.</li></ul></li><li>(3) 네트워크 연결을 통해 레코드 보내기<ul><li>두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 스키마 버전 합의를 할 수 있습니다.</li></ul></li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="동적-생성-스키마"></a>동적 생성 스키마<a class="hash-link" href="#동적-생성-스키마" title="Direct link to heading">#</a></h4><ul><li>아브로는 스키마에 <strong>태그 번호가 포함되어 있지 않는 다는 장점</strong>을 가집니다.</li><li>이는 아브로가 동적 생성 스키마에 더 친숙하다는 장점을 가집니다. 이를 통해 상당히 쉽게 스키마를 생성할 수 있습니다.</li><li>데이터베이스 스키마가 변경될 때도 유연함을 가집니다. 스리프트나 프로토콜 버퍼는 필드 태그를 수동으로 할당해야합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="코드-생성과-동적-타입-언어"></a>코드 생성과 동적 타입 언어<a class="hash-link" href="#코드-생성과-동적-타입-언어" title="Direct link to heading">#</a></h4><ul><li>스리프트와 프로토콜 버퍼는 코드 생성에 의존합니다. 자바, C++, C# 같은 정적 타입언어에서 유용합니다.</li><li>자바 스크립트, 루비, 파이썬 같은 동적 타입 프로그래밍 언어에서는 타입 검사기가 없으므로 코드 생성은 데이터를 가져오는데 불필요합니다.</li><li>아브로는 정적 타입 프로그래밍 언어를 위해 코드 생성을 선택적으로 제공합니다.</li><li>객체 컨테이너 파일이 있다면 아브로 라이브러리를 사용해 간단히 열어 JSON 파일을 보는 것과 같이 데이터를 볼 수 있으며 이를 <strong>자기 기술(self-describing)</strong> 이라고 합니다.</li><li>특성은 아파치 피그 같은 동적 타입 데이터 처리 언어와 함께 사용할 때 특히 유용합니다. 피그에서는 아브로 파일만 있으면 즉시 열어 분석을 시작할 수 있으며 스키마를 생각하지 않고도 아브로 형식으로 출력 파일에 파생 데이터를 기록할 수 있습니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="스키마의-장점"></a>스키마의 장점<a class="hash-link" href="#스키마의-장점" title="Direct link to heading">#</a></h3><ul><li>위의 프로토콜 버퍼, 스리프트, 아브로는 스키마를 통해 이진 부호화 형식을 가지며 XML 스키마나 JSON 스키마보다 훨씬 간단하며 더 자세한 유효성 검사를 지원합니다.</li><li>많은 데이터 시스템이 이진 부호화를 독자적으로 구현하기도 합니다. (ex. ODBC, JDBC API)</li><li>이진 부호화에는 좋은 속성이 많이 있습니다.<ul><li>부호화된 데이터에서 필드 이름을 생략할 수 있기 때문에 다양한 &quot;이진 JSON&quot; 변형보다 크기가 더 작을 수 있습니다.</li><li>스키마는 유용한 문서화 형식이므로 복호화시 스키마가 최신 상태인지를 확인할 수 있습니다.</li><li>스키마 데이터베이스를 유지하며 스키마 변경이 적용되기 전에 상위 호환성과 하위 호환성을 확인할 수 있습니다.</li><li>정적 타입 프로그래밍 언어 사용자에게 스키마로부터 코드를 생성하는 기능은 유용합니다. 컴파일 시점에 타입 체크를 할 수 있습니다.</li></ul></li><li>즉, 스키마 발전은 schemaless 또는 읽기 스키마(schema-on-read) JSON 데이터베이스가 제공하는 것과 동일한 종류의 유연성을 제공하며 데이터나 도구 지원도 더 잘 보장합니다.</li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터플로-모드"></a>데이터플로 모드<a class="hash-link" href="#데이터플로-모드" title="Direct link to heading">#</a></h2><p>데이터플로는 매우 추장적인 개념이며 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법입니다.</p><p>아래는 보편화 방법입니다.</p><ul><li>데이터베이스를 통한 데이터플로</li><li>서비스 호출을 통한 데이터플로</li><li>비동기 메시지 전달을 통한 데이터플로</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터베이스를-통한-데이터-플로"></a>데이터베이스를 통한 데이터 플로<a class="hash-link" href="#데이터베이스를-통한-데이터-플로" title="Direct link to heading">#</a></h3><ul><li>데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 데이터베이스에서 읽는 프로세스는 데이터를 복호화합니다.</li><li>데이터베이스에 뭔가를 저장하는 일을 <strong>미래의 자신에게 메시지를 보내는 일</strong>처럼 생각할 수 있습니다.<ul><li>이때 하위 호환성은 반드시 필요합니다. (이전 기록 내용을 복호화할 수 있어야하기 때문에)</li></ul></li><li>동시에 다양한 프로세스가 데이터베이스를 접근하는 일은 흔합니다.<ul><li>이는 데이터베이스 내 값이 <strong>새로운</strong> 버전의 코드로 기록된 다음 현재 수행 중인 <strong>예전 버전</strong>의 코드로 그 값을 읽을 가능성이 있음을 의미합니다.</li></ul></li><li>애플리케이션에서 데이터베이스 값을 모델 객체로 복호화하고 나중에 이 모델 객체를 다시 재부호화하면 변환 과정에서 <strong>알지 못하는 필드가 유실될 수 있습니다.</strong></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="다양한-시점에-기록된-다양한-값"></a>다양한 시점에 기록된 다양한 값<a class="hash-link" href="#다양한-시점에-기록된-다양한-값" title="Direct link to heading">#</a></h4><ul><li>데이터베이스는 일반적으로 언제나 값을 갱신할 수 있습니다.</li><li>데이터는 다시 기록하지 않는 한, 원래의 부호화 상태로 있기 때문에 이를 <strong>데이터가 코드보다 더 오래 산다(data outlives code)</strong> 라고 합니다.</li><li>데이터를 새로운 스키마로 다시 기록(rewriting, 마이그레이션) 하는 작업은 가능하나 비용이 매우 비쌉니다.</li><li>따라서 대부분의 관계형 데이터베이스는 기존 데이터를 다시 기록하지 않고 <strong>널을 기본값으로 갖는 새로운 칼럼</strong>을 추가하는 간단한 스키마 변경을 허용합니다.</li></ul><p>이러한 스키마의 발전은 기본 저장소가 여러 가지 버전의 스키마로 부호화된 레코드를 포함해도 전체 데이터베이스가 단일 스키마로 부호화된 것처럼 보이게 합니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="보관-저장소"></a>보관 저장소<a class="hash-link" href="#보관-저장소" title="Direct link to heading">#</a></h4><ul><li>백업 목적이나 데이터 웨어하우스로 적재하기 위해 데이터베이스의 스냅샷을 만들때는 <strong>최신 스키마를 사용해 부호화합니다.</strong></li><li>데이터 덤프는 한 번에 기록하고 이후에는 변하지 않으므로 아브로 객체 컨테이너 파일과 같은 형식이 적합합니다.</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="서비스를-통한-데이터플로-rest와-rpc"></a>서비스를 통한 데이터플로: REST와 RPC<a class="hash-link" href="#서비스를-통한-데이터플로-rest와-rpc" title="Direct link to heading">#</a></h3><ul><li>네트워크를 통해 통신해야 하는 프로세스가 있을 때 해당 통신을 배치하는 몇 가지 방법이 있습니다.</li><li>가장 일반적인 방법으로 <strong>클라이언트</strong>와 <strong>서버</strong>의 두 역할로 배치합니다.<ul><li>서버는 네트워크를 통해 API를 공개하고 클라이언트는 이 API로 요청을 만들어 서버에 연결할 수 있습니다.</li><li>서버가 공개한 API를 <strong>서비스</strong>라고 합니다.</li></ul></li><li>API는 표준화된 프로토콜과 데이터 타입(HTTP, URL, SSL/TLS, HTML 등)으로 구성됩니다.</li><li>서비스 지향 및 마이크로서비스 아키텍처의 핵심 설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 <strong>애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것</strong>입니다.</li><li><strong>서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능</strong>해야 합니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="웹-서비스"></a>웹 서비스<a class="hash-link" href="#웹-서비스" title="Direct link to heading">#</a></h4><ul><li>서비스와 통신하기 위한 기본 프로토콜로 HTTP를 사용할 때 이를 <strong>웹 서비스</strong>라고 합니다.<ul><li>사용자 띠바이스에서 실행하며 HTTP를 통해 서비스에 요청하는 클라이언트 애플리케이션</li><li>서비스 지향/마이크로서비스 아키텍처의 일부인 경우</li><li>보통의 인터넷을 통해 다른 조직의 서비스에 요청하는 서비스</li></ul></li><li>웹 서비스에는 대중적인 두 가지 방법인 <strong>REST</strong>와 <strong>SOAP</strong>가 있습니다.</li><li>REST는 프로토콜이 아니라 HTTP의 원칙을 토대로 한 설계 철학입니다.<ul><li>REST는 간단한 데이터 타입을 강조하며 URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 HTP 기능을 사용합니다.</li></ul></li><li>SOAP는 네트워크 API 요청을 위한 XML 기반 프로토콜입니다.<ul><li>SOAP는 HTTP 상에서 가장 일반적으로 사용되지만 HTTP와 독립적이며 대부분의 HTTP 기능을 사용하지 않습니다.</li><li>다양한 기능을 추가한 광범위하고 복잡한 여러 관련 표준(WS, 웹 서비스 프레임워크)을 제공합니다.</li><li>SOAP 웹 서비스의 API는 웹 서비스 기술 언어(Web Services Description Language) 또는 WSDL이라고 부르는 XML 기반 언어를 사용해 기술합니다.</li><li>WSDL은 사람이 읽을 수 있게 설계하지 않았고 대개 SOAP 메시지를 수동으로 구성하기에 너무 복잡합니다.</li></ul></li><li>RESTful API는 간단한 접근 방식을 선호합니다.<ul><li>일반적으로 코드 생성과 자동화된 도구와 관련되지 않은 접근 방식을 의미합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="원격-프로시저-호출rpc-문제"></a>원격 프로시저 호출(RPC) 문제<a class="hash-link" href="#원격-프로시저-호출rpc-문제" title="Direct link to heading">#</a></h4><ul><li>웹 서비스는 네트워크 상에서 API 요청을 하기 위한 여러 기술 중 가장 최신 형상일 뿐입니다.</li><li>웹 서비스는 <strong>원격 프로시저 호출(remote procedure call, RPC)</strong> 의 아이디어를 기반으로 합니다.</li><li>RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해줍니다.(이러한 추상화를 <strong>위치 투명성(location transparency)</strong> 라고 합니다.)</li><li>로컬 함수 호출은 예측이 가능하지만 네트워크 요청은 예측이 어렵습니다.<ul><li>로컬 함수 호출은 결과를 반환하거나 예외, 반환을 하지 않는 결과라면 네트워크는 타임아웃으로 결과 없이 반환도 가능합니다.</li><li>실패한 네트워크 요청을 다시 시도할 때 요청이 실제로 처리되고 응답만 유실될 수 있습니다.</li><li>로컬 함수를 호출할 때마다 보통 거의 같은 실행 시간이 소요되나 네트워크 요청은 훨씬 느리고 지연 시간이 매우 다양합니다.</li><li>로컬 함수를 호출하는 경우, 참조를 로컬 메모리의 객체에 효율적으로 전달하며 네트워크로 요청하는 경우에는 모든 매개변수는 네트워크를 통해 전송할 수 있게끔 바이트열로 부호화해야 합니다.</li><li>클라이언트와 서비스는 다른 프로그래밍 언어로 구현할 수 있으므로 따라서 RPC 프레임워크는 하나의 언어에서 다른 언어로 데이터타입을 변환해야합니다.</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="rpc의-현재-방향"></a>RPC의 현재 방향<a class="hash-link" href="#rpc의-현재-방향" title="Direct link to heading">#</a></h4><ul><li>RPC에는 이러한 문제가 있어서 차세대 RPC 프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 더 분명히 합니다.</li><li>실패할지도 모르는 비동기 작업을 캡슐화하기 위해 퓨처(promise)를 사용합니다.</li><li>퓨처는 병렬로 여러 서비스에 요청을 보내야 하는 상황을 간소화하고 요청 결과를 취합합니다.</li><li>이런 프레임워크 중 일부는 <strong>서비스 찾기(service discovery)</strong> 를 제공합니다.</li><li>REST 상에서 이진 부호화 형식이 우수한 성능을 제공할지도 모르나 RESTful API는 실험과 디버깅에 적합합니다.</li><li>이러한 이유로 REST는 공개 API의 주요한 방식입니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="데이터-부호화와-rpc의-발전"></a>데이터 부호화와 RPC의 발전<a class="hash-link" href="#데이터-부호화와-rpc의-발전" title="Direct link to heading">#</a></h4><ul><li>발전성이 있으려면 RPC 클라이언트와 서버를 독립적으로 변경하고 배포할 수 있어야합니다.</li><li>데이터베이스를 통한 데이터플로에 비해 서비스를 통한 데이터플오의 발전성을 가정을 단순화할 수 있습니다.</li><li>RPC 스키마의 상하위 호환 속성은 사용된 모든 부호화로부터 상속됩니다.<ul><li>스리프트, gRPC는 각 부호화 형식의 호환성 규칙에 따라 발전할 수 있습니다.</li><li>SOAP에서 요청과 응답은 XML 스키마로 지정됩니다.</li><li>RESTful API는 응답에 JSON을 가장 일반적으로 사용합니다.</li></ul></li><li>RPC가 조직 경계를 넘나드는 통신에 사용되면 이는 서비스 호환성 유지를 어렵게 합니다.</li><li>API 버전 관리가 반드시 어떤 방식으로 동작해야하는 협의는 없습니다.<ul><li>RESTful API는 URL이나 HTTP Accept 헤더에 버전 번호를 사용하는 방식이 일반적입니다.</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메시지-전달-데이터플로"></a>메시지 전달 데이터플로<a class="hash-link" href="#메시지-전달-데이터플로" title="Direct link to heading">#</a></h3><p>아래에서는 RPC와 데이터베이스 간 비동기 메시지 전달 시스템(asynchronous message passing system)을 간단히 살펴봅니다.</p><ul><li>이 시스템은 클라이언트 요청(보통 메시지)을 낮은 지연 시간으로 다른 프로세스에 전달하는 점에서는 RPC와 비슷합니다.</li><li>메시지를 직접 네트워크 연결로 전송하지 않고 임시로 메시지를 저장하는 메시지 브로커(message broker, 또는 메시지큐나 메시지 지향 미들웨어)라는 중간 단계를 거치는 것은 데이터베이스와 유사합니다.</li></ul><p>메시지 브로커를 사용하는 방식은 직접 RPC를 사용하는 방식과 비교했을 때 여러 장점이 있습니다.</p><ul><li>수신자가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있기 때문에 시스템 안전성이 향상됩니다.</li><li>죽었던 프로세스에 메시지를 다시 전달할 수 있기 때문에 메시지 유실을 방지할 수 있습니다.</li><li>송신자가 수신자의 IP주소나 포트 번호를 알 필요가 없습니다.</li><li>하나의 메시지를 여러 수신자로 전송할 수 있습니다.</li><li>논리적으로 송신자는 수신자와 분리됩니다.</li></ul><p>메시지 전달 통신은 일반적으로 단방향이라는 점이 RPC와 다릅니다. 즉, 이러한 통신 패턴은 비동기입니다.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="메시지-브로커"></a>메시지 브로커<a class="hash-link" href="#메시지-브로커" title="Direct link to heading">#</a></h4><ul><li>대표적인 예시는 아파치 카프카와 같습니다.</li><li>일반적으로 메시지 브로커는 다음과 같이 사용합니다.<ul><li>프로세스 하나가 메시지를 이름이 지정된 큐나 토픽으로 전송하고 브로커는 해당 <strong>큐</strong>나 <strong>토픽</strong>으로 전송하고 브로커는 해당 큐나 토픽 하나 이상의 <strong>소비자(consumer)</strong> 또는 <strong>구독자(subscriber)</strong> 에게 메시지를 전달합니다.</li><li>동일한 토픽에 여러 생산자(producer)와 소비자가 있을 수 있습니다.</li></ul></li><li>토픽은 단방향 데이터플로만 제공합니다.</li><li>메시지 브로커는 보통 특정 데이터 모델을 강요하지 않습니다.</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="분산-액터-프레임워크"></a>분산 액터 프레임워크<a class="hash-link" href="#분산-액터-프레임워크" title="Direct link to heading">#</a></h4><p><strong>액터 모델(actor model)</strong> 은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델입니다.</p><ul><li>스레드(경쟁 조건, 잠금, 교착 상태와 연관된 문제들)을 직접 처리하는 대신 로직이 <strong>액터</strong>에 캡슐화 됩니다.</li><li>보통 각 액터는 하나의 클라이언트나 엔티티를 나타냅니다.</li><li>액터는 비동기 메시지의 송수신으로 다른 액터와 통신하며 액터는 메시지 전달을 보장하지 않습니다.</li><li>각 액터는 한 번에 하나의 메시지만 처리하므로 스레드에 대해 걱정할 필요가 없으며 프레임워크와 독집적으로 실행합니다.</li></ul><p><strong>분산 액터 프레임워크</strong>에서 이 프로그래밍 모델은 여러 노드 간의 애플리케이션 확장에 사용됩니다.</p><ul><li>송신자와 수신자가 같은 노드에 있는지 다른 노드에 있는지 관계없이 동일한 메시지 전달 구조를 사용합니다.</li><li>다른 노드에 있는 경우 메시지를 부호화되고 네트워크를 통해 전송된 후 복호화됩니다.</li><li>액터 모델을 사용하는 경우 로컬과 원격 통신 간 근본적인 불일치가 적습니다.</li><li>분산 액터 프레임워크는 기본적으로 메시지 브로커와 액터 프로그래밍 모델을 단일 프레임워크에 통합합니다.</li><li>터터 기반 애플리케이션의 순회식 업그레이드은 상하위 호환성에 주의해야 합니다.</li><li>인기 있는 분산 액터 프레임워크 세 가지는 다음과 같이 메시지 부호화를 처리합니다.<ul><li><strong>아카(Akka)</strong> 는 기본적으로 자바의 내장 직렬화를 사용합니다. 이는 상위 호환성이나 하위 호환성을 제공하지 않으나 프로토콜 버퍼와 같은 부호화 형식으로 대체할 수 있습니다.<ul><li><a href="https://azderica.github.io/00-akka-starter/" target="_blank" rel="noopener noreferrer">아카 개념 간단 정리</a></li></ul></li><li><strong>올리언스(Orleans)</strong> 는 기본적으로 사용자 정의 데이터 부호화 형식을 사용합니다.</li><li><strong>얼랭(erlang)</strong> 에서는 순회식 업그레이드는 가능하지만 신중하게 계획해야합니다. (어려움)</li></ul></li></ul><br><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="정리"></a>정리<a class="hash-link" href="#정리" title="Direct link to heading">#</a></h2><ul><li>해당 내용에서는 데이터 구조를 네트워크나 디스크 상의 바이트로 변환하는 다양한 방법에 대해 이야기 합니다.</li><li>많은 서비스가 새로운 버전의 서비스를 동시에 모든 노드에 배포하는 방식보다 서서히 배포하는 순회식 업그레이드가 필요합니다. 이는 변경을 쉽게 할 수 있는 발전성에 도움이 많이 됩니다.</li><li>다양한 노드에서 다른 버전의 애플리케이션이 돌아가므로 시스템을 흐르는 모든 데이터는 <strong>하위 호환성(새로운 코드가 예전 데이터를 읽을 수 있음)</strong> 과 <strong>상위 호환성(예전 코드가 새로운 데이터를 읽을 수 있음)</strong> 을 제공하는 방식으로 부호화 해야합니다.</li><li>다양한 데이터 부호화 형식과 호환성 속성이 있습니다.<ul><li>프로그래밍 언어에 특화된 부호화는 단일 프로그래밍 언어로 제한되며 상위, 하위 호환성을 제공하지 못하는 경우가 종종 있습니다.</li><li>JSON, XML, CSV 같은 테스트 형식은 널리 사용되며 이들 간 호환성은 이 형식들을 사용하는 방법에 달려있습니다.</li><li>스리프트, 프로토콜 버퍼, 아브로 같은 이진 스키마 기반 형식은 짧은 길이로 부호화되며 명확하게 정의된 상위 호환성과 하위 호환성의 맥악에서 효율적인 부호화를 지원합니다.</li></ul></li><li>데이터 부호화의 중요성에 대한 여러 시나리오를 보여주는 다양한 데이터플로 모드를 설명합니다.<ul><li>데이터베이스에 기록하는 프로세스가 부호화하고 데이터베이스에서 읽는 프로세스가 복호화하는 데이터베이스</li><li>클라이언트가 요청을 부호화하고 서버는 요청을 복호화하고 응답을 부호화하고 최종적으로 클라이언트가 응답을 복호화하는 RPC와 REST API</li><li>송신자가 부호화하고 수신자가 복호화하는 메시지를 서로 전송해서 노드 간 통신하는 비동기 메시지 전달(메시지 브로커나 액터를 이용)</li></ul></li><li>약간의 주의를 통해 상하위 호환성과 순회식 업그레이드가 가능하며 애플리케이션의 발전은 더욱 빨라지고 배포 빈도도 높아집니다.</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/Azderica/til/edit/master/docs/data/designing-data-intensive-applications/ch4.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2022-04-03T09:26:21.000Z" class="lastUpdatedDate_1WI_">4/3/2022</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/til/docs/data/designing-data-intensive-applications/ch3"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 3. 저장소와 검색</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/til/docs/data/designing-data-intensive-applications/ch5"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">5. 복제 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#데이터-부호화-형식" class="table-of-contents__link">데이터 부호화 형식</a><ul><li><a href="#언어별-형식" class="table-of-contents__link">언어별 형식</a></li><li><a href="#json과-xml-이진-변형" class="table-of-contents__link">JSON과 XML, 이진 변형</a></li><li><a href="#스리프트와-프로토콜-버퍼" class="table-of-contents__link">스리프트와 프로토콜 버퍼</a></li><li><a href="#아브로" class="table-of-contents__link">아브로</a></li><li><a href="#스키마의-장점" class="table-of-contents__link">스키마의 장점</a></li></ul></li><li><a href="#데이터플로-모드" class="table-of-contents__link">데이터플로 모드</a><ul><li><a href="#데이터베이스를-통한-데이터-플로" class="table-of-contents__link">데이터베이스를 통한 데이터 플로</a></li><li><a href="#서비스를-통한-데이터플로-rest와-rpc" class="table-of-contents__link">서비스를 통한 데이터플로: REST와 RPC</a></li><li><a href="#메시지-전달-데이터플로" class="table-of-contents__link">메시지 전달 데이터플로</a></li></ul></li><li><a href="#정리" class="table-of-contents__link">정리</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Myeonghun's Study, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/til/assets/js/runtime~main.1cdd1183.js"></script>
<script src="/til/assets/js/main.63620547.js"></script>
</body>
</html>